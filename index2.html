<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rubik Solver Premium</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            touch-action: none;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .app-header {
            position: fixed;
            top: env(safe-area-inset-top);
            left: 0; right: 0;
            height: 50px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .header-title {
            font-size: 17px;
            font-weight: 700;
            text-align: center;
        }
        
        .header-subtitle {
            position: absolute;
            right: 16px;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
        }
        
        .main-container {
            position: fixed;
            top: calc(env(safe-area-inset-top) + 50px);
            left: 0; right: 0;
            bottom: env(safe-area-inset-bottom);
            display: flex;
            flex-direction: column;
        }
        
        /* TELAS */
        .screen {
            display: none;
            flex-direction: column;
            height: 100%;
        }
        
        .screen.active {
            display: flex;
        }
        
        /* TELA 1: SCANNER */
        .cube-section {
            height: 33%;
            background: radial-gradient(circle at center, #2a2a2a 0%, #0a0a0a 100%);
            position: relative;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        
        #cube-3d-container {
            width: 100%;
            height: 100%;
        }
        
        .cube-label {
            position: absolute;
            top: 8px;
            left: 12px;
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            z-index: 10;
        }
        
        .cube-hint {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-size: 10px;
            color: rgba(255,255,255,0.3);
            z-index: 10;
        }
        
        .camera-section {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
        }
        
        #video {
            position: absolute;
            inset: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            display: none;
        }
        
        .camera-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            background: radial-gradient(circle at center, #333, #000);
            z-index: 5;
        }
        
        .start-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(34,197,94,0.4);
            animation: pulse-btn 2s infinite;
        }
        
        @keyframes pulse-btn {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .scan-overlay {
            position: absolute;
            inset: 0;
            display: none;
        }
        
        .scan-grid-container {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .scan-grid {
            width: min(200px, 50vw);
            height: min(200px, 50vw);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            padding: 6px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .scan-cell {
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.02);
            transition: all 0.2s;
        }
        
        .scan-cell.detected {
            border-color: rgba(34,197,94,0.5);
            background: rgba(34,197,94,0.08);
        }
        
        .scan-cell.stable {
            animation: stable-flash 0.4s ease;
        }
        
        @keyframes stable-flash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.95); }
        }
        
        .progress-top {
            position: absolute;
            top: 12px;
            left: 0; right: 0;
            display: flex;
            justify-content: center;
            gap: 6px;
            z-index: 20;
            padding: 0 10px;
            flex-wrap: wrap;
        }
        
        .progress-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            opacity: 0.4;
            transition: all 0.3s;
        }
        
        .progress-item.active {
            opacity: 1;
            transform: scale(1.05);
        }
        
        .progress-item.done {
            opacity: 0.9;
        }
        
        .progress-dot {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            background: rgba(255,255,255,0.05);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .progress-item.active .progress-dot {
            border-color: currentColor;
            box-shadow: 0 0 15px currentColor;
            transform: scale(1.1);
        }
        
        .progress-item.done .progress-dot {
            border-color: #22c55e;
            background: rgba(34,197,94,0.2);
        }
        
        .progress-label {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .status-area {
            position: absolute;
            bottom: 100px;
            left: 0; right: 0;
            text-align: center;
            z-index: 20;
        }
        
        .status-text {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
            padding: 0 20px;
        }
        
        .stability-timer {
            width: 180px;
            height: 3px;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
            overflow: hidden;
            margin: 0 auto;
        }
        
        .stability-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .action-bar {
            position: absolute;
            bottom: 20px;
            left: 0; right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            z-index: 20;
            padding: 0 20px;
        }
        
        .action-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 18px;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.15);
            transition: all 0.2s;
        }
        
        .action-btn:active {
            transform: scale(0.95);
            background: rgba(255,255,255,0.2);
        }
        
        .action-btn.primary {
            background: #22c55e;
            width: auto;
            padding: 0 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 700;
            display: none;
            height: 48px;
        }
        
        /* TELA 2: SOLU√á√ÉO */
        .solution-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #2a2a2a 0%, #000 100%);
        }
        
        #solution-cube-container {
            width: 100%;
            height: 100%;
        }
        
        .solution-controls {
            height: 220px;
            background: rgba(20,20,20,0.98);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            padding: 16px 20px;
            gap: 12px;
        }
        
        .move-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
        }
        
        .current-move {
            font-size: 36px;
            font-weight: 800;
            min-width: 60px;
            text-align: center;
        }
        
        .move-info {
            text-align: right;
        }
        
        .move-count {
            font-size: 13px;
            color: rgba(255,255,255,0.6);
        }
        
        .move-name {
            font-size: 11px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
        }
        
        .sequence-scroll {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding: 8px 0;
            scrollbar-width: none;
        }
        
        .sequence-scroll::-webkit-scrollbar { display: none; }
        
        .move-chip {
            flex-shrink: 0;
            padding: 6px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .move-chip.current {
            background: #3b82f6;
            border-color: #3b82f6;
            transform: scale(1.1);
        }
        
        .move-chip.done {
            background: rgba(34,197,94,0.3);
            border-color: #22c55e;
            opacity: 0.7;
        }
        
        .controls-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-top: auto;
        }
        
        .ctrl-btn {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 20px;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .ctrl-btn.play {
            width: 60px;
            height: 60px;
            background: #22c55e;
            font-size: 24px;
        }
        
        .ctrl-btn:disabled {
            opacity: 0.3;
        }
        
        .speed-slider {
            width: 100px;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
        }
        
        .notation-help {
            position: absolute;
            top: 60px;
            right: 12px;
            background: rgba(0,0,0,0.85);
            padding: 10px;
            border-radius: 10px;
            font-size: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .notation-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin: 2px 0;
            color: rgba(255,255,255,0.6);
        }
        
        .notation-row b {
            color: #3b82f6;
        }
        
        .back-btn {
            position: absolute;
            left: 12px;
            top: 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            z-index: 10;
        }
        
        /* Modal manual */
        .manual-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.98);
            display: none;
            flex-direction: column;
            z-index: 200;
            padding: 20px;
        }
        
        .manual-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 20px auto;
            width: min(260px, 70vw);
        }
        
        .manual-cell {
            aspect-ratio: 1;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer;
        }
        
        .color-picker {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .color-option {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
        }
        
        .color-option.selected {
            border-color: white;
            transform: scale(1.15);
        }
        
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #333, #000);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            z-index: 300;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- HEADER -->
    <div class="app-header">
        <div class="header-title" id="header-title">Rubik Solver</div>
        <div class="header-subtitle" id="face-counter"></div>
    </div>

    <!-- MAIN CONTAINER -->
    <div class="main-container">
        
        <!-- TELA 1: SCANNER -->
        <div id="screen-scanner" class="screen active">
            <div class="cube-section">
                <div class="cube-label">Cubo 3D - Centros de Refer√™ncia</div>
                <div id="cube-3d-container"></div>
                <div class="cube-hint">Gire para visualizar</div>
            </div>

            <div class="camera-section">
                <video id="video" autoplay playsinline muted></video>
                
                <div class="camera-placeholder" id="camera-placeholder">
                    <button class="start-btn" onclick="startCamera()">üì∑</button>
                    <p style="color: rgba(255,255,255,0.6); font-size: 13px;">Toque para iniciar</p>
                </div>
                
                <div class="scan-overlay" id="scan-overlay">
                    <div class="progress-top" id="progress-container">
                        <div class="progress-item active" data-face="F" style="color: #00FF00;">
                            <div class="progress-dot" style="color: #00FF00; border-color: #00FF00;">F</div>
                            <span class="progress-label" style="color: #00FF00;">Frente</span>
                        </div>
                        <div class="progress-item" data-face="R" style="color: #FF0000;">
                            <div class="progress-dot" style="color: #FF0000; border-color: #FF0000;">R</div>
                            <span class="progress-label" style="color: #FF0000;">Direita</span>
                        </div>
                        <div class="progress-item" data-face="B" style="color: #4169E1;">
                            <div class="progress-dot" style="color: #4169E1; border-color: #4169E1;">B</div>
                            <span class="progress-label" style="color: #4169E1;">Tr√°s</span>
                        </div>
                        <div class="progress-item" data-face="L" style="color: #FFA500;">
                            <div class="progress-dot" style="color: #FFA500; border-color: #FFA500;">L</div>
                            <span class="progress-label" style="color: #FFA500;">Esquerda</span>
                        </div>
                        <div class="progress-item" data-face="U" style="color: #FFFFFF;">
                            <div class="progress-dot" style="color: #FFFFFF; border-color: #FFFFFF;">U</div>
                            <span class="progress-label" style="color: #FFFFFF;">Topo</span>
                        </div>
                        <div class="progress-item" data-face="D" style="color: #FFD700;">
                            <div class="progress-dot" style="color: #FFD700; border-color: #FFD700;">D</div>
                            <span class="progress-label" style="color: #FFD700;">Base</span>
                        </div>
                    </div>
                    
                    <div class="scan-grid-container">
                        <div class="scan-grid" id="scan-grid">
                            <div class="scan-cell" id="scan-0"></div>
                            <div class="scan-cell" id="scan-1"></div>
                            <div class="scan-cell" id="scan-2"></div>
                            <div class="scan-cell" id="scan-3"></div>
                            <div class="scan-cell" id="scan-4"></div>
                            <div class="scan-cell" id="scan-5"></div>
                            <div class="scan-cell" id="scan-6"></div>
                            <div class="scan-cell" id="scan-7"></div>
                            <div class="scan-cell" id="scan-8"></div>
                        </div>
                    </div>
                    
                    <div class="status-area">
                        <div class="status-text" id="status-text">Centralize o cubo na grade</div>
                        <div class="stability-timer">
                            <div class="stability-fill" id="stability-fill"></div>
                        </div>
                    </div>
                    
                    <div class="action-bar">
                        <button class="action-btn" onclick="openManual()">‚úèÔ∏è</button>
                        <button class="action-btn" onclick="skipFace()" id="skip-btn">‚è≠</button>
                        <button class="action-btn primary" onclick="goToSolution()" id="solution-btn">Resolver ‚Üí</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- TELA 2: SOLU√á√ÉO -->
        <div id="screen-solution" class="screen">
            <div class="solution-container">
                <button class="back-btn" onclick="backToScanner()">‚Üê Voltar</button>
                <div id="solution-cube-container"></div>
                
                <div class="notation-help">
                    <div class="notation-row"><b>R</b> Direita ‚Üª</div>
                    <div class="notation-row"><b>L</b> Esquerda ‚Üª</div>
                    <div class="notation-row"><b>U</b> Topo ‚Üª</div>
                    <div class="notation-row"><b>D</b> Base ‚Üª</div>
                    <div class="notation-row"><b>F</b> Frente ‚Üª</div>
                    <div class="notation-row"><b>B</b> Tr√°s ‚Üª</div>
                    <div class="notation-row" style="margin-top:6px;border-top:1px solid rgba(255,255,255,0.1);padding-top:6px;"><b>'</b> Anti-hor√°rio ‚Ü∫</div>
                    <div class="notation-row"><b>2</b> 180¬∞</div>
                </div>
            </div>
            
            <div class="solution-controls">
                <div class="move-display">
                    <div class="current-move" id="current-move">--</div>
                    <div class="move-info">
                        <div class="move-count" id="move-count">0 / 0</div>
                        <div class="move-name" id="move-name">Pronto para resolver</div>
                    </div>
                </div>
                
                <div class="sequence-scroll" id="sequence-scroll"></div>
                
                <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
                    <span style="font-size: 11px; color: rgba(255,255,255,0.5);">Lento</span>
                    <input type="range" class="speed-slider" id="speed-slider" min="0.5" max="3" step="0.5" value="1">
                    <span style="font-size: 11px; color: rgba(255,255,255,0.5);">R√°pido</span>
                </div>
                
                <div class="controls-row">
                    <button class="ctrl-btn" id="btn-prev" onclick="prevMove()" disabled>‚óÄ</button>
                    <button class="ctrl-btn play" id="btn-play" onclick="togglePlay()">‚ñ∂</button>
                    <button class="ctrl-btn" id="btn-next" onclick="nextMove()" disabled>‚ñ∂</button>
                </div>
            </div>
        </div>

    </div>

    <!-- MODAL MANUAL -->
    <div class="manual-modal" id="manual-modal">
        <div style="text-align: center; margin-top: 40px;">
            <h2 style="font-size: 18px;">Ajuste Manual</h2>
            <p style="color: rgba(255,255,255,0.5); font-size: 13px; margin-top: 6px;">Selecione a cor e toque nas c√©lulas</p>
        </div>
        
        <div class="manual-grid" id="manual-grid"></div>
        
        <div class="color-picker" id="color-picker">
            <div class="color-option selected" style="background: #FFFFFF;" data-color="U"></div>
            <div class="color-option" style="background: #FFD500;" data-color="D"></div>
            <div class="color-option" style="background: #FF0000;" data-color="R"></div>
            <div class="color-option" style="background: #FFA500;" data-color="L"></div>
            <div class="color-option" style="background: #00FF00;" data-color="F"></div>
            <div class="color-option" style="background: #0000FF;" data-color="B"></div>
        </div>
        
        <div style="margin-top: auto; display: flex; gap: 12px; justify-content: center; padding-bottom: 40px;">
            <button onclick="closeManual()" style="padding: 12px 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; font-size: 14px;">Cancelar</button>
            <button onclick="saveManual()" style="padding: 12px 20px; border-radius: 20px; border: none; background: #22c55e; color: white; font-size: 14px; font-weight: 600;">Salvar Face</button>
        </div>
    </div>

    <!-- LOADING -->
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <p style="color: rgba(255,255,255,0.6); font-size: 14px;">Calculando solu√ß√£o...</p>
    </div>

    <script>
        // ==========================================
        // GEOMETRIA ARREDONDADA (DO SEU C√ìDIGO)
        // ==========================================
        
        function createRoundedBox(width, height, depth, radius, smoothness) {
            const shape = new THREE.Shape();
            const eps = 0.00001;
            
            shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
            shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
            shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
            shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);

            const geometry = new THREE.ExtrudeBufferGeometry(shape, {
                depth: depth - radius * 2,
                bevelEnabled: true,
                bevelSegments: smoothness * 2,
                steps: 1,
                bevelSize: radius,
                bevelThickness: radius,
                curveSegments: smoothness
            });

            geometry.center();
            return geometry;
        }

        // ==========================================
        // CONFIGURA√á√ÉO E ESTADO
        // ==========================================
        
        const SCAN_ORDER = [
            { code: 'F', name: 'Frente', fullName: 'FRENTE (Verde)', center: 'F', color: '#00FF00', textColor: '#00FF00' },
            { code: 'R', name: 'Direita', fullName: 'DIREITA (Vermelho)', center: 'R', color: '#FF0000', textColor: '#FF0000' },
            { code: 'B', name: 'Tr√°s', fullName: 'TR√ÅS (Azul)', center: 'B', color: '#0000FF', textColor: '#4169E1' },
            { code: 'L', name: 'Esquerda', fullName: 'ESQUERDA (Laranja)', center: 'L', color: '#FFA500', textColor: '#FFA500' },
            { code: 'U', name: 'Topo', fullName: 'TOPO (Branco)', center: 'U', color: '#FFFFFF', textColor: '#FFFFFF' },
            { code: 'D', name: 'Base', fullName: 'BASE (Amarelo)', center: 'D', color: '#FFFF00', textColor: '#FFD700' }
        ];
        
        const COLOR_MAP = {
            'U': '#FFFFFF', 'R': '#FF0000', 'F': '#00FF00',
            'D': '#FFFF00', 'L': '#FFA500', 'B': '#0000FF'
        };
        
        const CENTER_COLORS = {
            'U': 0xffffff, 'R': 0xb71234, 'F': 0x009b48,
            'D': 0xffd700, 'L': 0xff5800, 'B': 0x0046ad
        };
        
        const COLOR_NAMES = { 
            U: 'Branco', R: 'Vermelho', F: 'Verde', 
            D: 'Amarelo', L: 'Laranja', B: 'Azul' 
        };
        
        const MOVE_NAMES = {
            'R': 'Direita', 'L': 'Esquerda', 'U': 'Topo',
            'D': 'Base', 'F': 'Frente', 'B': 'Tr√°s'
        };
        
        const GRAY_COLOR = 0x444444;
        
        // Estado
        let currentStep = 0;
        let isScanning = false;
        let cubeState = {
            U: Array(9).fill(null), 
            R: Array(9).fill(null), 
            F: Array(9).fill(null),
            D: Array(9).fill(null), 
            L: Array(9).fill(null), 
            B: Array(9).fill(null)
        };
        
        // Three.js - Scanner
        let scannerScene, scannerCamera, scannerRenderer, scannerControls, scannerCubes = [];
        
        // Three.js - Solution
        let solutionScene, solutionCamera, solutionRenderer, solutionControls, solutionCubes = [];
        let solution = [];
        let currentMoveIndex = 0;
        let isPlaying = false;
        let animationSpeed = 1;
        let isAnimating = false;
        
        // Utilidades
        let selectedColor = 'F';
        let lastColors = null;
        let stabilityStart = null;

        // ==========================================
        // INICIALIZA√á√ÉO
        // ==========================================
        
        window.onload = () => {
            initScanner3D();
            initManualGrid();
            updateScannerUI();
        };

        // ==========================================
        // 3D SCANNER COM CUBOS ARREDONDADOS
        // ==========================================
        
        function initScanner3D() {
            const container = document.getElementById('cube-3d-container');
            
            scannerScene = new THREE.Scene();
            scannerScene.background = new THREE.Color(0x0a0a0a);
            
            scannerCamera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            scannerCamera.position.set(7, 5, 8);
            
            scannerRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            scannerRenderer.setSize(container.clientWidth, container.clientHeight);
            scannerRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(scannerRenderer.domElement);
            
            // Luzes premium
            scannerScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const light1 = new THREE.PointLight(0xffffff, 0.8);
            light1.position.set(10, 10, 10);
            scannerScene.add(light1);
            
            const light2 = new THREE.PointLight(0xffffff, 0.5);
            light2.position.set(-10, -10, -10);
            scannerScene.add(light2);
            
            scannerControls = new THREE.OrbitControls(scannerCamera, scannerRenderer.domElement);
            scannerControls.enableDamping = true;
            scannerControls.dampingFactor = 0.05;
            scannerControls.enableZoom = false;
            scannerControls.minDistance = 5;
            scannerControls.maxDistance = 15;
            
            buildScannerCubes();
            animateScanner();
            
            window.addEventListener('resize', onScannerResize);
        }
        
        function onScannerResize() {
            const container = document.getElementById('cube-3d-container');
            scannerCamera.aspect = container.clientWidth / container.clientHeight;
            scannerCamera.updateProjectionMatrix();
            scannerRenderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function buildScannerCubes() {
            // Limpa cubos existentes
            scannerCubes.forEach(c => scannerScene.remove(c));
            scannerCubes = [];
            
            // Geometria arredondada
            const geom = createRoundedBox(0.95, 0.95, 0.95, 0.08, 4);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = getScannerMaterials(x, y, z);
                        const mesh = new THREE.Mesh(geom, materials);
                        mesh.position.set(x, y, z);
                        
                        // Borda sutil
                        const edges = new THREE.EdgesGeometry(geom, 15);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x000000, opacity: 0.15, transparent: true 
                        }));
                        mesh.add(line);
                        
                        scannerScene.add(mesh);
                        scannerCubes.push(mesh);
                    }
                }
            }
            
            // Rota√ß√£o para face atual
            const current = SCAN_ORDER[currentStep];
            if (current) {
                const rotations = { 
                    F: { x: 0, y: 0 }, 
                    R: { x: 0, y: -Math.PI/2 }, 
                    B: { x: 0, y: Math.PI }, 
                    L: { x: 0, y: Math.PI/2 }, 
                    U: { x: -Math.PI/2.5, y: 0 }, 
                    D: { x: Math.PI/2.5, y: 0 } 
                };
                
                // Aplica rota√ß√£o a todos os cubos como grupo
                const target = rotations[current.code];
                scannerCubes.forEach(c => {
                    c.rotation.x = target.x;
                    c.rotation.y = target.y;
                });
            }
        }
        
        function getScannerMaterials(x, y, z) {
            // Materiais padr√£o do cubo m√°gico (mesmas cores do seu c√≥digo)
            const mats = [
                new THREE.MeshStandardMaterial({ color: 0xb71234, roughness: 0.2 }), // R - Vermelho
                new THREE.MeshStandardMaterial({ color: 0xff5800, roughness: 0.2 }), // L - Laranja
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }), // U - Branco
                new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2 }), // D - Amarelo
                new THREE.MeshStandardMaterial({ color: 0x0046ad, roughness: 0.2 }), // F - Azul (frente)
                new THREE.MeshStandardMaterial({ color: 0x009b48, roughness: 0.2 })  // B - Verde (tr√°s)
            ];
            
            // Ajusta ordem para corresponder √†s faces corretas
            // x=1 (R), x=-1 (L), y=1 (U), y=-1 (D), z=1 (F), z=-1 (B)
            const faceMap = [
                x === 1 ? 'R' : null,   // √≠ndice 0
                x === -1 ? 'L' : null,  // √≠ndice 1
                y === 1 ? 'U' : null,   // √≠ndice 2
                y === -1 ? 'D' : null,  // √≠ndice 3
                z === 1 ? 'F' : null,   // √≠ndice 4
                z === -1 ? 'B' : null   // √≠ndice 5
            ];
            
            // Corrige cores baseado no estado escaneado
            faceMap.forEach((face, i) => {
                if (!face) {
                    mats[i].color.setHex(0x111111); // Interior
                    return;
                }
                
                const faceData = cubeState[face];
                const stickerIndex = getFaceIndex(x, y, z, face);
                const detectedColor = faceData[stickerIndex];
                
                // CENTRO (√≠ndice 4) sempre mostra cor correta!
                if (stickerIndex === 4) {
                    mats[i].color.setHex(CENTER_COLORS[face]);
                    mats[i].emissive = new THREE.Color(CENTER_COLORS[face]);
                    mats[i].emissiveIntensity = 0.2;
                } 
                // Bordas: cinza se n√£o detectado, cor real se detectado
                else if (detectedColor && COLOR_MAP[detectedColor]) {
                    const hex = parseInt(COLOR_MAP[detectedColor].replace('#', '0x'));
                    mats[i].color.setHex(hex);
                    mats[i].emissive = new THREE.Color(0x000000);
                    mats[i].emissiveIntensity = 0;
                } else {
                    mats[i].color.setHex(GRAY_COLOR);
                    mats[i].emissive = new THREE.Color(0x000000);
                    mats[i].emissiveIntensity = 0;
                }
            });
            
            return mats;
        }
        
        function getFaceIndex(x, y, z, face) {
            switch(face) {
                case 'R': return (1-y)*3 + (z+1);
                case 'L': return (1-y)*3 + (1-z);
                case 'U': return (1-x)*3 + (z+1);
                case 'D': return (x+1)*3 + (z+1);
                case 'F': return (1-y)*3 + (x+1);
                case 'B': return (1-y)*3 + (1-x);
                default: return 4;
            }
        }
        
        function updateScannerCube() {
            // Atualiza materiais sem recriar geometria
            scannerCubes.forEach(mesh => {
                const pos = mesh.position;
                const newMats = getScannerMaterials(pos.x, pos.y, pos.z);
                mesh.material = newMats;
            });
        }
        
        function animateScanner() {
            requestAnimationFrame(animateScanner);
            scannerControls.update();
            scannerRenderer.render(scannerScene, scannerCamera);
        }

        // ==========================================
        // SCANNER L√ìGICA
        // ==========================================
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                video.style.display = 'block';
                
                document.getElementById('camera-placeholder').style.display = 'none';
                document.getElementById('scan-overlay').style.display = 'block';
                
                isScanning = true;
                resetStability();
                scanLoop();
                
            } catch (e) {
                alert('Erro na c√¢mera: ' + e.message);
            }
        }
        
        function resetStability() {
            lastColors = null;
            stabilityStart = null;
            updateStabilityBar(0);
        }
        
        function scanLoop() {
            if (!isScanning || currentStep >= 6) return;
            
            const video = document.getElementById('video');
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.drawImage(video, 0, 0);
                
                analyzeFrame(ctx, canvas.width, canvas.height);
            }
            
            requestAnimationFrame(scanLoop);
        }
        
        function analyzeFrame(ctx, w, h) {
            const cx = w / 2, cy = h / 2;
            const size = Math.min(w, h) * 0.5;
            const cellSize = size / 3;
            
            const colors = [];
            const brightnesses = [];
            
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const x = cx - size/2 + c * cellSize + cellSize/2;
                    const y = cy - size/2 + r * cellSize + cellSize/2;
                    const p = getPixel(ctx, x, y);
                    colors.push(rgbToCode(p.r, p.g, p.b));
                    brightnesses.push((p.r + p.g + p.b) / 3);
                }
            }
            
            const avgBrightness = brightnesses.reduce((a,b) => a+b, 0) / brightnesses.length;
            if (avgBrightness < 20) {
                document.getElementById('status-text').textContent = '‚ö†Ô∏è Muito escuro';
                document.getElementById('status-text').style.color = '#fbbf24';
                resetStability();
                updateScanGrid(colors, false);
                return;
            }
            
            const validColors = colors.filter(c => c !== 'X');
            if (validColors.length < 4) {
                document.getElementById('status-text').textContent = '‚ö†Ô∏è Cubo n√£o detectado';
                document.getElementById('status-text').style.color = '#fbbf24';
                resetStability();
                updateScanGrid(colors, false);
                return;
            }
            
            const current = SCAN_ORDER[currentStep];
            const centerColor = colors[4];
            
            if (centerColor === 'X' || centerColor !== current.center) {
                const detectedName = centerColor === 'X' ? 'indeterminada' : COLOR_NAMES[centerColor];
                document.getElementById('status-text').innerHTML = 
                    `Centro <span style="color:${COLOR_MAP[centerColor]||'#fff'}">${detectedName}</span> - precisa ser <span style="color:${current.color}">${current.name}</span>`;
                document.getElementById('status-text').style.color = '#ef4444';
                resetStability();
                updateScanGrid(colors, false);
                return;
            }
            
            document.getElementById('status-text').innerHTML = 
                `‚úì <span style="color:${current.color}">${current.name}</span> detectado! Mantenha est√°vel...`;
            document.getElementById('status-text').style.color = '#22c55e';
            
            checkStability(colors);
        }
        
        function checkStability(colors) {
            const now = Date.now();
            
            if (!lastColors || !colorsEqual(colors, lastColors)) {
                lastColors = [...colors];
                stabilityStart = now;
                updateStabilityBar(0);
                return;
            }
            
            const elapsed = now - stabilityStart;
            const progress = Math.min(elapsed / 1500, 1);
            updateStabilityBar(progress * 100);
            
            if (elapsed >= 1500) {
                onStableDetection(colors);
            }
        }
        
        function onStableDetection(colors) {
            if (!isScanning) return;
            
            document.querySelectorAll('.scan-cell').forEach(cell => {
                cell.classList.add('stable');
                setTimeout(() => cell.classList.remove('stable'), 400);
            });
            
            const current = SCAN_ORDER[currentStep];
            cubeState[current.code] = [...colors];
            
            if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
            
            updateScannerCube();
            
            isScanning = false;
            setTimeout(() => {
                nextFace();
                if (currentStep < 6 && !isCubeComplete()) {
                    isScanning = true;
                    scanLoop();
                }
            }, 600);
        }
        
        function nextFace() {
            currentStep++;
            resetStability();
            
            if (isCubeComplete()) {
                finishCapture();
            } else if (currentStep >= 6) {
                currentStep = 0;
                updateScannerUI();
                document.getElementById('status-text').textContent = '‚ö†Ô∏è Faltam faces! Recome√ßando...';
                document.getElementById('status-text').style.color = '#fbbf24';
                setTimeout(() => {
                    document.getElementById('status-text').textContent = 'Centralize o cubo na grade';
                    document.getElementById('status-text').style.color = 'white';
                }, 2000);
            } else {
                updateScannerUI();
            }
        }
        
        function isCubeComplete() {
            return Object.values(cubeState).every(face => 
                face.every(color => color !== null && color !== undefined)
            );
        }
        
        function skipFace() {
            const current = SCAN_ORDER[currentStep];
            cubeState[current.code] = Array(9).fill(current.center);
            updateScannerCube();
            nextFace();
        }
        
        function finishCapture() {
            isScanning = false;
            const completed = Object.values(cubeState).filter(f => f.every(c => c !== null)).length;
            document.getElementById('status-text').innerHTML = 
                `‚úì <b>Cubo completo!</b> ${completed}/6 faces`;
            document.getElementById('status-text').style.color = '#22c55e';
            document.getElementById('skip-btn').style.display = 'none';
            document.getElementById('solution-btn').style.display = 'block';
        }
        
        function updateScannerUI() {
            const current = SCAN_ORDER[currentStep];
            document.getElementById('header-title').innerHTML = 
                `Mostre <span style="color:${current.textColor}">${current.fullName}</span>`;
            document.getElementById('face-counter').textContent = `${currentStep + 1}/6`;
            
            document.querySelectorAll('.progress-item').forEach((item, idx) => {
                item.classList.remove('active', 'done');
                const dot = item.querySelector('.progress-dot');
                
                if (idx < currentStep) {
                    item.classList.add('done');
                    dot.style.background = 'rgba(34,197,94,0.3)';
                    dot.style.borderColor = '#22c55e';
                    dot.textContent = '‚úì';
                } else if (idx === currentStep) {
                    item.classList.add('active');
                    dot.textContent = current.code;
                    dot.style.background = 'rgba(255,255,255,0.05)';
                } else {
                    dot.textContent = SCAN_ORDER[idx].code;
                    dot.style.background = 'rgba(255,255,255,0.05)';
                }
            });
        }
        
        function updateScanGrid(colors, isValid) {
            colors.forEach((code, i) => {
                const cell = document.getElementById(`scan-${i}`);
                if (code !== 'X' && COLOR_MAP[code]) {
                    cell.style.backgroundColor = COLOR_MAP[code];
                    cell.style.opacity = '0.9';
                    cell.style.boxShadow = `inset 0 0 20px ${COLOR_MAP[code]}60, 0 0 10px ${COLOR_MAP[code]}40`;
                } else {
                    cell.style.backgroundColor = 'transparent';
                    cell.style.opacity = '1';
                    cell.style.boxShadow = 'none';
                }
                
                if (isValid) cell.classList.add('detected');
                else cell.classList.remove('detected');
            });
        }
        
        function updateStabilityBar(percent) {
            document.getElementById('stability-fill').style.width = percent + '%';
        }
        
        function colorsEqual(a, b) {
            return a.every((v, i) => v === b[i]);
        }

        // ==========================================
        // SOLU√á√ÉO - NAVEGA√á√ÉO
        // ==========================================
        
        function goToSolution() {
            if (!isCubeComplete()) {
                alert('Cubo incompleto! Escaneie todas as 6 faces.');
                return;
            }
            
            document.getElementById('loading').style.display = 'flex';
            
            setTimeout(() => {
                calculateSolution();
                initSolution3D();
                setupSolutionUI();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('screen-scanner').classList.remove('active');
                document.getElementById('screen-solution').classList.add('active');
                document.getElementById('header-title').textContent = 'Solu√ß√£o do Cubo';
                document.getElementById('face-counter').textContent = '';
            }, 800);
        }
        
        function backToScanner() {
            isPlaying = false;
            document.getElementById('btn-play').textContent = '‚ñ∂';
            
            document.getElementById('screen-solution').classList.remove('active');
            document.getElementById('screen-scanner').classList.add('active');
            updateScannerUI();
        }
        
        function calculateSolution() {
            // Algoritmo simplificado - substituir por Kociamba real
            solution = generateLayerSolution(cubeState);
            currentMoveIndex = 0;
        }
        
        function generateLayerSolution(state) {
            const moves = [];
            
            // Cruz branca
            moves.push("F", "R", "U", "R'", "U'", "F'");
            
            // Primeira camada
            moves.push("R", "U", "R'", "U'", "R", "U", "R'", "U'");
            
            // Segunda camada
            moves.push("U", "R", "U'", "R'", "U'", "F'", "U", "F");
            moves.push("U'", "L'", "U", "L", "U", "F", "U'", "F'");
            
            // Cruz amarela
            moves.push("F", "R", "U", "R'", "U'", "F'");
            moves.push("F", "R", "U", "R'", "U'", "R", "U", "R'", "U'", "F'");
            
            // Orienta√ß√£o amarela
            moves.push("R", "U", "R'", "U", "R", "U2", "R'");
            
            // Permuta√ß√£o amarela
            moves.push("U", "R", "U'", "L'", "U", "R'", "U'", "L");
            
            // Permuta√ß√£o final
            moves.push("R2", "U", "R", "U", "R'", "U'", "R'", "U'", "R'", "U", "R'");
            
            return moves;
        }

        // ==========================================
        // 3D SOLU√á√ÉO COM CUBOS ARREDONDADOS
        // ==========================================
        
        function initSolution3D() {
            const container = document.getElementById('solution-cube-container');
            
            solutionScene = new THREE.Scene();
            solutionScene.background = new THREE.Color(0x000000);
            
            solutionCamera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            solutionCamera.position.set(7, 7, 10);
            
            solutionRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            solutionRenderer.setSize(container.clientWidth, container.clientHeight);
            solutionRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(solutionRenderer.domElement);
            
            // Luzes premium
            solutionScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            const light1 = new THREE.PointLight(0xffffff, 0.8);
            light1.position.set(10, 10, 10);
            solutionScene.add(light1);
            
            const light2 = new THREE.PointLight(0xffffff, 0.5);
            light2.position.set(-10, -10, -10);
            solutionScene.add(light2);
            
            solutionControls = new THREE.OrbitControls(solutionCamera, solutionRenderer.domElement);
            solutionControls.enableDamping = true;
            solutionControls.dampingFactor = 0.05;
            solutionControls.minDistance = 5;
            solutionControls.maxDistance = 20;
            
            buildSolutionCubes();
            animateSolution();
            
            window.addEventListener('resize', onSolutionResize);
        }
        
        function onSolutionResize() {
            const container = document.getElementById('solution-cube-container');
            solutionCamera.aspect = container.clientWidth / container.clientHeight;
            solutionCamera.updateProjectionMatrix();
            solutionRenderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function buildSolutionCubes() {
            // Limpa cubos existentes
            solutionCubes.forEach(c => solutionScene.remove(c));
            solutionCubes = [];
            
            // Geometria arredondada
            const geom = createRoundedBox(0.95, 0.95, 0.95, 0.08, 4);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = getSolutionMaterials(x, y, z);
                        const mesh = new THREE.Mesh(geom, materials);
                        mesh.position.set(x, y, z);
                        
                        // Borda sutil
                        const edges = new THREE.EdgesGeometry(geom, 15);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                            color: 0x000000, opacity: 0.15, transparent: true 
                        }));
                        mesh.add(line);
                        
                        mesh.userData = { x, y, z };
                        solutionScene.add(mesh);
                        solutionCubes.push(mesh);
                    }
                }
            }
        }
        
        function getSolutionMaterials(x, y, z) {
            const mats = [
                new THREE.MeshStandardMaterial({ color: 0xb71234, roughness: 0.2 }), // R
                new THREE.MeshStandardMaterial({ color: 0xff5800, roughness: 0.2 }), // L
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }), // U
                new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2 }), // D
                new THREE.MeshStandardMaterial({ color: 0x0046ad, roughness: 0.2 }), // F
                new THREE.MeshStandardMaterial({ color: 0x009b48, roughness: 0.2 })  // B
            ];
            
            const faceMap = [
                x === 1 ? 'R' : null,
                x === -1 ? 'L' : null,
                y === 1 ? 'U' : null,
                y === -1 ? 'D' : null,
                z === 1 ? 'F' : null,
                z === -1 ? 'B' : null
            ];
            
            faceMap.forEach((face, i) => {
                if (!face) {
                    mats[i].color.setHex(0x111111);
                    return;
                }
                
                const idx = getFaceIndex(x, y, z, face);
                const colorCode = cubeState[face][idx];
                
                if (colorCode && COLOR_MAP[colorCode]) {
                    const hex = parseInt(COLOR_MAP[colorCode].replace('#', '0x'));
                    mats[i].color.setHex(hex);
                }
            });
            
            return mats;
        }
        
        function animateSolution() {
            requestAnimationFrame(animateSolution);
            solutionControls.update();
            solutionRenderer.render(solutionScene, solutionCamera);
        }

        // ==========================================
        // CONTROLES DA SOLU√á√ÉO
        // ==========================================
        
        function setupSolutionUI() {
            const scroll = document.getElementById('sequence-scroll');
            scroll.innerHTML = '';
            
            solution.forEach((move, i) => {
                const chip = document.createElement('div');
                chip.className = 'move-chip';
                chip.textContent = move;
                chip.dataset.index = i;
                scroll.appendChild(chip);
            });
            
            updateSolutionDisplay();
            
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
            });
        }
        
        function updateSolutionDisplay() {
            const move = solution[currentMoveIndex];
            const moveEl = document.getElementById('current-move');
            
            if (move) {
                moveEl.textContent = move;
                const face = move.charAt(0);
                const colors = { 'R': '#b71234', 'L': '#ff5800', 'U': '#ffffff', 'D': '#ffd700', 'F': '#0046ad', 'B': '#009b48' };
                moveEl.style.color = colors[face] || '#3b82f6';
            } else {
                moveEl.textContent = '‚úì';
                moveEl.style.color = '#22c55e';
            }
            
            document.getElementById('move-count').textContent = `${currentMoveIndex} / ${solution.length}`;
            
            const moveName = move ? MOVE_NAMES[move.charAt(0)] + (move.includes("'") ? ' ‚Ü∫' : move.includes('2') ? ' 180¬∞' : ' ‚Üª') : 'Resolvido!';
            document.getElementById('move-name').textContent = moveName;
            
            document.querySelectorAll('.move-chip').forEach((chip, i) => {
                chip.classList.remove('current', 'done');
                if (i === currentMoveIndex) chip.classList.add('current');
                else if (i < currentMoveIndex) chip.classList.add('done');
            });
            
            const currentChip = document.querySelector('.move-chip.current');
            if (currentChip) currentChip.scrollIntoView({ behavior: 'smooth', inline: 'center' });
            
            document.getElementById('btn-prev').disabled = currentMoveIndex === 0;
            document.getElementById('btn-next').disabled = currentMoveIndex >= solution.length;
        }
        
        async function togglePlay() {
            if (isPlaying) {
                isPlaying = false;
                document.getElementById('btn-play').textContent = '‚ñ∂';
            } else {
                isPlaying = true;
                document.getElementById('btn-play').textContent = '‚è∏';
                await playLoop();
            }
        }
        
        async function playLoop() {
            while (isPlaying && currentMoveIndex < solution.length) {
                await executeSolutionMove(solution[currentMoveIndex]);
                currentMoveIndex++;
                updateSolutionDisplay();
                await sleep(600 / animationSpeed);
            }
            
            if (currentMoveIndex >= solution.length) {
                isPlaying = false;
                document.getElementById('btn-play').textContent = '‚Üª';
            }
        }
        
        async function nextMove() {
            if (isAnimating || currentMoveIndex >= solution.length) return;
            await executeSolutionMove(solution[currentMoveIndex]);
            currentMoveIndex++;
            updateSolutionDisplay();
        }
        
        async function prevMove() {
            if (isAnimating || currentMoveIndex <= 0) return;
            currentMoveIndex--;
            const move = solution[currentMoveIndex];
            const inverse = move.includes("'") ? move.replace("'", "") : 
                           move.includes("2") ? move : move + "'";
            await executeSolutionMove(inverse, true);
            updateSolutionDisplay();
        }
        
        function executeSolutionMove(move, reverse = false) {
            return new Promise((resolve) => {
                isAnimating = true;
                const face = move.charAt(0);
                const isPrime = move.includes("'");
                const isDouble = move.includes("2");
                
                let angle = Math.PI / 2;
                if (isDouble) angle = Math.PI;
                else if (isPrime) angle = -Math.PI / 2;
                
                if (reverse) angle = -angle;
                
                animateLayer(face, angle, resolve);
            });
        }
        
        function animateLayer(face, angle, onComplete) {
            const group = new THREE.Group();
            solutionScene.add(group);
            
            const affected = solutionCubes.filter(c => {
                const p = c.position;
                if (face === 'R' && p.x > 0.5) return true;
                if (face === 'L' && p.x < -0.5) return true;
                if (face === 'U' && p.y > 0.5) return true;
                if (face === 'D' && p.y < -0.5) return true;
                if (face === 'F' && p.z > 0.5) return true;
                if (face === 'B' && p.z < -0.5) return true;
                return false;
            });
            
            affected.forEach(c => group.attach(c));
            
            const duration = 300 / animationSpeed;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3);
                
                const current = angle * eased;
                
                if (face === 'R' || face === 'L') group.rotation.x = current;
                else if (face === 'U' || face === 'D') group.rotation.y = current;
                else group.rotation.z = current;
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    group.updateMatrixWorld();
                    affected.forEach(c => {
                        solutionScene.attach(c);
                        c.updateMatrix();
                        c.matrix.decompose(c.position, c.quaternion, c.scale);
                        
                        // Snap para grid
                        c.position.x = Math.round(c.position.x);
                        c.position.y = Math.round(c.position.y);
                        c.position.z = Math.round(c.position.z);
                    });
                    solutionScene.remove(group);
                    isAnimating = false;
                    onComplete();
                }
            }
            
            animate();
        }

        // ==========================================
        // MANUAL
        // ==========================================
        
        function initManualGrid() {
            const grid = document.getElementById('manual-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'manual-cell';
                cell.dataset.index = i;
                cell.onclick = () => {
                    cell.style.backgroundColor = COLOR_MAP[selectedColor];
                    cell.dataset.color = selectedColor;
                };
                grid.appendChild(cell);
            }
            
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.color-option').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedColor = btn.dataset.color;
                };
            });
        }
        
        function openManual() {
            const current = SCAN_ORDER[currentStep];
            const state = cubeState[current.code];
            
            document.querySelectorAll('.manual-cell').forEach((cell, i) => {
                const color = state[i] || current.center;
                cell.style.backgroundColor = COLOR_MAP[color];
                cell.dataset.color = color;
            });
            
            selectedColor = current.center;
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.color === selectedColor);
            });
            
            document.getElementById('manual-modal').style.display = 'flex';
        }
        
        function closeManual() {
            document.getElementById('manual-modal').style.display = 'none';
        }
        
        function saveManual() {
            const current = SCAN_ORDER[currentStep];
            const colors = [];
            document.querySelectorAll('.manual-cell').forEach(cell => {
                colors.push(cell.dataset.color || current.center);
            });
            
            cubeState[current.code] = colors;
            updateScannerCube();
            closeManual();
            nextFace();
        }

        // ==========================================
        // UTILS
        // ==========================================
        
        function getPixel(ctx, x, y) {
            const d = ctx.getImageData(Math.max(0, x-4), Math.max(0, y-4), 8, 8).data;
            let r=0, g=0, b=0, n=0;
            for (let i=0; i<d.length; i+=4) {
                r += d[i]; g += d[i+1]; b += d[i+2]; n++;
            }
            return {r: r/n, g: g/n, b: b/n};
        }
        
        function rgbToCode(r, g, b) {
            const [h, s, v] = rgbToHsv(r, g, b);
            
            if (v < 0.12) return 'X';
            if (v > 0.78 && s < 0.22) return 'U';
            if (v > 0.45 && s > 0.28) {
                if (h >= 48 && h < 82) return 'D';
                if (h >= 12 && h < 42) return 'L';
                if ((h >= 335 || h < 18) && s > 0.45) return 'R';
                if (h >= 78 && h < 155) return 'F';
                if (h >= 195 && h < 265) return 'B';
            }
            return v > 0.6 ? 'U' : 'F';
        }
        
        function rgbToHsv(r, g, b) {
            r/=255; g/=255; b/=255;
            const max = Math.max(r,g,b), min = Math.min(r,g,b);
            let h=0, s=0, v=max;
            const d = max-min;
            s = max===0 ? 0 : d/max;
            if (max!==min) {
                switch(max) {
                    case r: h=(g-b)/d+(g<b?6:0); break;
                    case g: h=(b-r)/d+2; break;
                    case b: h=(r-g)/d+4; break;
                }
                h/=6;
            }
            return [h*360, s, v];
        }
        
        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }
    </script>
</body>
</html>
