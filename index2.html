<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Rubik Scanner</title>

<style>

body{
    margin:0;
    background:#000;
    color:#fff;
    font-family:Arial, Helvetica, sans-serif;
    overflow:hidden;
}

#app{
    position:relative;
    width:100vw;
    height:100vh;
}

/* CÂMERA */
video, canvas{
    position:absolute;
    width:100%;
    height:100%;
    object-fit:cover;
}

/* INSTRUÇÕES */
#info{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,.7);
    padding:15px 25px;
    border-radius:20px;
    text-align:center;
    font-size:16px;
}

/* PREVIEW 3x3 */
#preview{
    position:absolute;
    top:15px;
    left:15px;
    display:grid;
    grid-template-columns:repeat(3,28px);
    gap:4px;
}

.cell{
    width:28px;
    height:28px;
    border-radius:6px;
    border:1px solid #555;
}

</style>
</head>

<body>

<div id="app">

    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>

    <div id="preview"></div>

    <div id="info"></div>

</div>


<script>

////////////////////////////////////////////////////
// CONFIG
////////////////////////////////////////////////////

// Ordem oficial URFDLB
const ORDER = [
 {key:"U", name:"Topo", color:"white", label:"Branco", hint:"Coloque o branco para cima"},
 {key:"R", name:"Direita", color:"red", label:"Vermelho", hint:"Gire o cubo para a direita"},
 {key:"F", name:"Frente", color:"green", label:"Verde", hint:"Aponte o verde para a câmera"},
 {key:"D", name:"Base", color:"yellow", label:"Amarelo", hint:"Vire o cubo para baixo"},
 {key:"L", name:"Esquerda", color:"orange", label:"Laranja", hint:"Gire para a esquerda"},
 {key:"B", name:"Trás", color:"blue", label:"Azul", hint:"Mostre o fundo do cubo"}
];

const GRID = 3;
const STABLE_TIME = 1000; // ms


////////////////////////////////////////////////////
// VARIÁVEIS
////////////////////////////////////////////////////

const video   = document.getElementById("video");
const canvas  = document.getElementById("canvas");
const ctx     = canvas.getContext("2d");

const preview = document.getElementById("preview");
const info    = document.getElementById("info");

let faceIndex = 0;

let lastColors = null;
let stableTimer = null;

let cube = {}; // {U:[],R:[],...}


////////////////////////////////////////////////////
// INIT
////////////////////////////////////////////////////

async function start(){

    const stream = await navigator.mediaDevices.getUserMedia({
        video:{
            facingMode:"environment",
            width:{ideal:1280},
            height:{ideal:720}
        }
    });

    video.srcObject = stream;

    video.onloadedmetadata = ()=>{

        canvas.width  = video.videoWidth;
        canvas.height = video.videoHeight;

        initPreview();
        updateInfo();

        loop();
    };
}

////////////////////////////////////////////////////
// UI
////////////////////////////////////////////////////

function initPreview(){

    preview.innerHTML="";

    for(let i=0;i<9;i++){
        let d = document.createElement("div");
        d.className = "cell";
        preview.appendChild(d);
    }
}

function updatePreview(colors){

    document.querySelectorAll(".cell")
    .forEach((c,i)=>{
        c.style.background = colors[i];
    });
}

function updateInfo(){

    if(faceIndex < 6){

        let f = ORDER[faceIndex];

        info.innerHTML = `
            <b>${f.name} (${f.label})</b><br>
            ${f.hint}
        `;

    }else{

        info.innerText = "Escaneamento concluído!";
    }
}


////////////////////////////////////////////////////
// LOOP PRINCIPAL
////////////////////////////////////////////////////

function loop(){

    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    drawGrid();

    let colors = scanColors();

    if(colors){

        updatePreview(colors);

        checkStable(colors);
    }

    requestAnimationFrame(loop);
}


////////////////////////////////////////////////////
// GRID
////////////////////////////////////////////////////

function drawGrid(){

    let size = Math.min(canvas.width,canvas.height) * 0.65;

    let x0 = (canvas.width - size)/2;
    let y0 = (canvas.height - size)/2;

    let cell = size/3;

    ctx.strokeStyle = "#00ff00";
    ctx.lineWidth = 3;

    for(let i=0;i<3;i++){
        for(let j=0;j<3;j++){

            ctx.strokeRect(
                x0 + i*cell,
                y0 + j*cell,
                cell, cell
            );
        }
    }

    ctx.grid = {x0,y0,cell};
}


////////////////////////////////////////////////////
// SCAN CORES
////////////////////////////////////////////////////

function scanColors(){

    if(!ctx.grid) return;

    let {x0,y0,cell} = ctx.grid;

    let result = [];

    for(let i=0;i<3;i++){
        for(let j=0;j<3;j++){

            let cx = x0 + i*cell + cell/2;
            let cy = y0 + j*cell + cell/2;

            let img = ctx.getImageData(
                cx-6, cy-6, 12, 12
            ).data;

            let r=0,g=0,b=0,n=0;

            for(let k=0;k<img.length;k+=4){
                r+=img[k];
                g+=img[k+1];
                b+=img[k+2];
                n++;
            }

            r/=n; g/=n; b/=n;

            let hsv = rgb2hsv(r,g,b);

            let color = classify(hsv);

            result.push(color);

            // Marcador visual
            ctx.beginPath();
            ctx.arc(cx,cy,6,0,Math.PI*2);
            ctx.fillStyle = color;
            ctx.fill();
        }
    }

    return result;
}


////////////////////////////////////////////////////
// RGB -> HSV
////////////////////////////////////////////////////

function rgb2hsv(r,g,b){

    r/=255; g/=255; b/=255;

    let max = Math.max(r,g,b);
    let min = Math.min(r,g,b);

    let h,s,v = max;

    let d = max - min;

    s = max===0 ? 0 : d/max;

    if(max === min){
        h = 0;
    }else{

        switch(max){
            case r: h=(g-b)/d+(g<b?6:0); break;
            case g: h=(b-r)/d+2; break;
            case b: h=(r-g)/d+4; break;
        }

        h *= 60;
    }

    return {h,s,v};
}


////////////////////////////////////////////////////
// CLASSIFICAÇÃO HSV
////////////////////////////////////////////////////

function classify({h,s,v}){

    if(v>0.8 && s<0.25) return "white";

    if(h<15 || h>340) return "red";

    if(h>15 && h<45) return "orange";

    if(h>45 && h<70) return "yellow";

    if(h>80 && h<160) return "green";

    if(h>190 && h<260) return "blue";

    return "gray";
}


////////////////////////////////////////////////////
// VALIDAÇÃO CENTRO
////////////////////////////////////////////////////

function validateCenter(colors){

    let center = colors[4];

    let expected = ORDER[faceIndex].color;

    return center === expected;
}


////////////////////////////////////////////////////
// ESTABILIDADE
////////////////////////////////////////////////////

function checkStable(colors){

    if(colors.includes("gray")){
        resetStable();
        return;
    }

    if(!validateCenter(colors)){
        info.innerHTML = "⚠️ Face incorreta!<br>Ajuste o cubo.";
        resetStable();
        return;
    }

    if(!lastColors){
        lastColors = [...colors];
        return;
    }

    let same = true;

    for(let i=0;i<9;i++){
        if(colors[i] !== lastColors[i]){
            same = false;
            break;
        }
    }

    if(!same){
        resetStable();
        lastColors = [...colors];
        return;
    }

    if(!stableTimer){

        stableTimer = setTimeout(()=>{

            saveFace(colors);

        }, STABLE_TIME);
    }
}


function resetStable(){

    clearTimeout(stableTimer);

    stableTimer = null;
    lastColors = null;

    updateInfo();
}


////////////////////////////////////////////////////
// SALVAR FACE
////////////////////////////////////////////////////

function saveFace(colors){

    let key = ORDER[faceIndex].key;

    cube[key] = [...colors];

    console.log("Face salva:", key, colors);

    faceIndex++;

    resetStable();

    updateInfo();

    if(faceIndex >= 6){
        finish();
    }
}


////////////////////////////////////////////////////
// FINAL
////////////////////////////////////////////////////

function finish(){

    stopCamera();

    console.log("Cubo completo:", cube);

    alert("Cubo escaneado com sucesso!");

    let str = cubeToSolverString(cube);

    console.log("String Solver:", str);

    // Aqui você conecta no algoritmo de solução
}


function stopCamera(){

    if(video.srcObject){

        video.srcObject.getTracks()
        .forEach(t=>t.stop());
    }
}


////////////////////////////////////////////////////
// CONVERSÃO PARA SOLVER
////////////////////////////////////////////////////

function cubeToSolverString(cube){

    const map = {
        white:"U",
        red:"R",
        green:"F",
        yellow:"D",
        orange:"L",
        blue:"B"
    };

    const order = ["U","R","F","D","L","B"];

    let result = "";

    order.forEach(f=>{

        cube[f].forEach(c=>{
            result += map[c];
        });

    });

    return result;
}


////////////////////////////////////////////////////
// START
////////////////////////////////////////////////////

start();

</script>

</body>
</html>
