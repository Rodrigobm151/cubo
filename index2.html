<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rubik Solver - Captura</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            touch-action: none;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .app-header {
            position: fixed;
            top: env(safe-area-inset-top);
            left: 0; right: 0;
            height: 50px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .header-title {
            font-size: 17px;
            font-weight: 700;
            text-align: center;
        }
        
        .header-subtitle {
            position: absolute;
            right: 16px;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
        }
        
        /* Container principal - 1/3 cubo, 2/3 c√¢mera */
        .main-container {
            position: fixed;
            top: calc(env(safe-area-inset-top) + 50px);
            left: 0; right: 0;
            bottom: env(safe-area-inset-bottom);
            display: flex;
            flex-direction: column;
        }
        
        /* √Årea do Cubo 3D - 33% da tela */
        .cube-section {
            height: 33%;
            background: linear-gradient(180deg, #0f0f0f 0%, #1a1a1a 100%);
            position: relative;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        #cube-3d-container {
            width: 100%;
            height: 100%;
        }
        
        .cube-label {
            position: absolute;
            top: 8px;
            left: 12px;
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            z-index: 10;
        }
        
        .cube-hint {
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-size: 10px;
            color: rgba(255,255,255,0.4);
            z-index: 10;
        }
        
        /* √Årea da C√¢mera - 67% da tela */
        .camera-section {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
        }
        
        #video {
            position: absolute;
            inset: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            display: none;
        }
        
        .camera-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            z-index: 5;
        }
        
        .start-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(34,197,94,0.4);
            animation: pulse-btn 2s infinite;
        }
        
        @keyframes pulse-btn {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* Overlay da c√¢mera */
        .scan-overlay {
            position: absolute;
            inset: 0;
            display: none;
        }
        
        /* Grade centralizada e transparente */
        .scan-grid-container {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .scan-grid {
            width: min(200px, 50vw);
            height: min(200px, 50vw);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            padding: 6px;
            background: rgba(0,0,0,0.15);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .scan-cell {
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.02);
            transition: all 0.2s;
        }
        
        .scan-cell.detected {
            border-color: rgba(34,197,94,0.5);
            background: rgba(34,197,94,0.08);
        }
        
        .scan-cell.stable {
            animation: stable-flash 0.4s ease;
        }
        
        @keyframes stable-flash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.95); }
        }
        
        /* Progresso no topo da c√¢mera */
        .progress-top {
            position: absolute;
            top: 16px;
            left: 0; right: 0;
            display: flex;
            justify-content: center;
            gap: 8px;
            z-index: 20;
            padding: 0 20px;
        }
        
        .progress-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            opacity: 0.4;
            transition: all 0.3s;
            position: relative;
        }
        
        .progress-dot.active {
            opacity: 1;
            transform: scale(1.1);
            border-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59,130,246,0.5);
        }
        
        .progress-dot.done {
            opacity: 0.9;
            border-color: #22c55e;
            background: rgba(34,197,94,0.2);
        }
        
        .progress-dot::after {
            content: attr(data-label);
            position: absolute;
            bottom: -18px;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        
        /* Status e timer */
        .status-area {
            position: absolute;
            bottom: 100px;
            left: 0; right: 0;
            text-align: center;
            z-index: 20;
        }
        
        .status-text {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 8px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
            padding: 0 20px;
        }
        
        .stability-timer {
            width: 180px;
            height: 3px;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
            overflow: hidden;
            margin: 0 auto;
        }
        
        .stability-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        /* Bot√µes na parte inferior */
        .action-bar {
            position: absolute;
            bottom: 20px;
            left: 0; right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            z-index: 20;
            padding: 0 20px;
        }
        
        .action-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 18px;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.15);
            transition: all 0.2s;
        }
        
        .action-btn:active {
            transform: scale(0.95);
            background: rgba(255,255,255,0.2);
        }
        
        .action-btn.primary {
            background: #22c55e;
            width: auto;
            padding: 0 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 700;
            display: none;
            height: 48px;
        }
        
        /* Modal manual */
        .manual-modal {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.98);
            display: none;
            flex-direction: column;
            z-index: 60;
            padding: 20px;
        }
        
        .manual-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 20px auto;
            width: min(260px, 70vw);
        }
        
        .manual-cell {
            aspect-ratio: 1;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer;
        }
        
        .color-picker {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .color-option {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
        }
        
        .color-option.selected {
            border-color: white;
            transform: scale(1.15);
        }
    </style>
</head>
<body>

    <div class="app-header">
        <div class="header-title" id="header-title">Mostre a face VERDE</div>
        <div class="header-subtitle" id="face-counter">1/6</div>
    </div>

    <div class="main-container">
        <!-- Se√ß√£o do Cubo 3D (1/3 da tela) -->
        <div class="cube-section">
            <div class="cube-label">Preview do Cubo</div>
            <div id="cube-3d-container"></div>
            <div class="cube-hint">Toque e arraste para rotacionar</div>
        </div>

        <!-- Se√ß√£o da C√¢mera (2/3 da tela) -->
        <div class="camera-section">
            <video id="video" autoplay playsinline muted></video>
            
            <div class="camera-placeholder" id="camera-placeholder">
                <button class="start-btn" onclick="startCamera()">üì∑</button>
                <p style="color: rgba(255,255,255,0.6); font-size: 13px;">Toque para iniciar a c√¢mera</p>
            </div>
            
            <div class="scan-overlay" id="scan-overlay">
                <!-- Progresso topo -->
                <div class="progress-top">
                    <div class="progress-dot active" data-face="F" data-label="F" style="background: rgba(0,255,0,0.3);">F</div>
                    <div class="progress-dot" data-face="R" data-label="R" style="background: rgba(255,0,0,0.3);">R</div>
                    <div class="progress-dot" data-face="B" data-label="B" style="background: rgba(0,0,255,0.3);">B</div>
                    <div class="progress-dot" data-face="L" data-label="L" style="background: rgba(255,165,0,0.3);">L</div>
                    <div class="progress-dot" data-face="U" data-label="U" style="background: rgba(255,255,255,0.3);">U</div>
                    <div class="progress-dot" data-face="D" data-label="D" style="background: rgba(255,255,0,0.3);">D</div>
                </div>
                
                <!-- Grade de scan -->
                <div class="scan-grid-container">
                    <div class="scan-grid" id="scan-grid">
                        <div class="scan-cell" id="scan-0"></div>
                        <div class="scan-cell" id="scan-1"></div>
                        <div class="scan-cell" id="scan-2"></div>
                        <div class="scan-cell" id="scan-3"></div>
                        <div class="scan-cell" id="scan-4"></div>
                        <div class="scan-cell" id="scan-5"></div>
                        <div class="scan-cell" id="scan-6"></div>
                        <div class="scan-cell" id="scan-7"></div>
                        <div class="scan-cell" id="scan-8"></div>
                    </div>
                </div>
                
                <!-- Status -->
                <div class="status-area">
                    <div class="status-text" id="status-text">Centralize o cubo na grade</div>
                    <div class="stability-timer">
                        <div class="stability-fill" id="stability-fill"></div>
                    </div>
                </div>
                
                <!-- Bot√µes -->
                <div class="action-bar">
                    <button class="action-btn" onclick="openManual()" title="Editar manual">‚úèÔ∏è</button>
                    <button class="action-btn" onclick="skipFace()" id="skip-btn">‚è≠</button>
                    <button class="action-btn primary" onclick="goToSolution()" id="solution-btn">Ver Solu√ß√£o ‚Üí</button>
                </div>
            </div>
            
            <!-- Modal manual -->
            <div class="manual-modal" id="manual-modal">
                <div style="text-align: center; margin-top: 30px;">
                    <h2 style="font-size: 18px; margin-bottom: 6px;">Ajuste Manual</h2>
                    <p style="color: rgba(255,255,255,0.5); font-size: 13px;">Toque na cor depois na c√©lula</p>
                </div>
                
                <div class="manual-grid" id="manual-grid"></div>
                
                <div class="color-picker" id="color-picker">
                    <div class="color-option selected" style="background: #FFFFFF;" data-color="U"></div>
                    <div class="color-option" style="background: #FFD500;" data-color="D"></div>
                    <div class="color-option" style="background: #FF0000;" data-color="R"></div>
                    <div class="color-option" style="background: #FFA500;" data-color="L"></div>
                    <div class="color-option" style="background: #00FF00;" data-color="F"></div>
                    <div class="color-option" style="background: #0000FF;" data-color="B"></div>
                </div>
                
                <div style="margin-top: auto; display: flex; gap: 12px; justify-content: center; padding-bottom: 30px;">
                    <button onclick="closeManual()" style="padding: 12px 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); background: transparent; color: white; font-size: 14px;">Cancelar</button>
                    <button onclick="saveManual()" style="padding: 12px 20px; border-radius: 20px; border: none; background: #22c55e; color: white; font-size: 14px; font-weight: 600;">Salvar Face</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SCAN_ORDER = [
            { code: 'F', name: 'Frente', center: 'F' },
            { code: 'R', name: 'Direita', center: 'R' },
            { code: 'B', name: 'Tr√°s', center: 'B' },
            { code: 'L', name: 'Esquerda', center: 'L' },
            { code: 'U', name: 'Topo', center: 'U' },
            { code: 'D', name: 'Base', center: 'D' }
        ];
        
        const COLOR_MAP = {
            'U': '#FFFFFF', 'R': '#FF0000', 'F': '#00FF00',
            'D': '#FFFF00', 'L': '#FFA500', 'B': '#0000FF'
        };
        
        const COLOR_NAMES = { U: 'Branco', R: 'Vermelho', F: 'Verde', D: 'Amarelo', L: 'Laranja', B: 'Azul' };
        
        let currentStep = 0;
        let isScanning = false;
        let cubeState = {
            U: Array(9).fill(null), 
            R: Array(9).fill(null), 
            F: Array(9).fill(null),
            D: Array(9).fill(null), 
            L: Array(9).fill(null), 
            B: Array(9).fill(null)
        };
        
        // Three.js
        let scene, camera, renderer, controls, cubeGroup;
        let selectedColor = 'U';
        
        window.onload = () => {
            init3D();
            updateUI();
            initManualGrid();
        };
        
        function init3D() {
            const container = document.getElementById('cube-3d-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(3.5, 2.5, 4);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            // Luzes
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 10, 7);
            scene.add(dir);
            
            const point = new THREE.PointLight(0x3b82f6, 0.4);
            point.position.set(-5, -5, -5);
            scene.add(point);
            
            // Controles (usu√°rio pode rotacionar)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = false;
            controls.autoRotate = false;
            
            buildCube();
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
        
        function buildCube() {
            if (cubeGroup) scene.remove(cubeGroup);
            cubeGroup = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            // Cria os 27 cubinhos
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = getMaterials(x, y, z);
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(x, y, z);
                        cubie.castShadow = true;
                        cubie.receiveShadow = true;
                        cubeGroup.add(cubie);
                    }
                }
            }
            
            scene.add(cubeGroup);
            
            // Posiciona para mostrar face atual
            const current = SCAN_ORDER[currentStep];
            if (current) {
                const rot = { 
                    F: [0, 0], 
                    R: [0, -Math.PI/2], 
                    B: [0, Math.PI], 
                    L: [0, Math.PI/2], 
                    U: [-Math.PI/3, 0], 
                    D: [Math.PI/3, 0] 
                }[current.code];
                cubeGroup.rotation.x = rot[0];
                cubeGroup.rotation.y = rot[1];
            }
        }
        
        function getMaterials(x, y, z) {
            const mats = [];
            
            // Determina qual face cada material representa
            const faces = [
                x === 1 ? 'R' : null,   // Right
                x === -1 ? 'L' : null,  // Left
                y === 1 ? 'U' : null,   // Up
                y === -1 ? 'D' : null,  // Down
                z === 1 ? 'F' : null,   // Front
                z === -1 ? 'B' : null   // Back
            ];
            
            faces.forEach((face, i) => {
                let color = 0x1a1a1a; // Cor interna padr√£o
                
                if (face) {
                    const faceData = cubeState[face];
                    // Pega cor baseada na posi√ß√£o no cubo 3x3
                    const idx = getFaceIndex(x, y, z, face);
                    const colorCode = faceData[idx];
                    
                    if (colorCode && COLOR_MAP[colorCode]) {
                        color = parseInt(COLOR_MAP[colorCode].replace('#', '0x'));
                    } else {
                        // Se n√£o tem dados, mostra cor do centro esperada
                        color = parseInt(COLOR_MAP[face].replace('#', '0x'));
                    }
                }
                
                mats.push(new THREE.MeshPhongMaterial({ 
                    color: color,
                    shininess: 90,
                    specular: 0x222222
                }));
            });
            
            return mats;
        }
        
        function getFaceIndex(x, y, z, face) {
            // Mapeia coordenada 3D para √≠ndice 0-8 da face
            if (face === 'R') return (1-y)*3 + (z+1);
            if (face === 'L') return (1-y)*3 + (1-z);
            if (face === 'U') return (1-x)*3 + (z+1);
            if (face === 'D') return (x+1)*3 + (z+1);
            if (face === 'F') return (1-y)*3 + (x+1);
            if (face === 'B') return (1-y)*3 + (1-x);
            return 4;
        }
        
        function updateCube() {
            // Reconstr√≥i o cubo com novas cores
            buildCube();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                video.style.display = 'block';
                
                document.getElementById('camera-placeholder').style.display = 'none';
                document.getElementById('scan-overlay').style.display = 'block';
                
                isScanning = true;
                resetStability();
                scanLoop();
                
            } catch (e) {
                alert('Erro na c√¢mera: ' + e.message);
            }
        }
        
        function scanLoop() {
            if (!isScanning || currentStep >= 6) return;
            
            const video = document.getElementById('video');
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.drawImage(video, 0, 0);
                
                analyzeFrame(ctx, canvas.width, canvas.height);
            }
            
            requestAnimationFrame(scanLoop);
        }
        
        function analyzeFrame(ctx, w, h) {
            const cx = w / 2, cy = h / 2;
            const size = Math.min(w, h) * 0.5;
            const cellSize = size / 3;
            
            const colors = [];
            const brightnesses = [];
            
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const x = cx - size/2 + c * cellSize + cellSize/2;
                    const y = cy - size/2 + r * cellSize + cellSize/2;
                    const p = getPixel(ctx, x, y);
                    colors.push(rgbToCode(p.r, p.g, p.b));
                    brightnesses.push((p.r + p.g + p.b) / 3);
                }
            }
            
            // Valida√ß√µes
            const avgBrightness = brightnesses.reduce((a,b) => a+b) / brightnesses.length;
            if (avgBrightness < 25) {
                document.getElementById('status-text').textContent = '‚ö†Ô∏è Muito escuro';
                document.getElementById('status-text').style.color = '#fbbf24';
                resetStability();
                updateScanGrid(colors, false);
                return;
            }
            
            const uniqueColors = [...new Set(colors)].filter(c => c !== 'X').length;
            if (uniqueColors < 2) {
                document.getElementById('status-text').textContent = '‚ö†Ô∏è Cubo n√£o detectado';
                document.getElementById('status-text').style.color = '#fbbf24';
                resetStability();
                updateScanGrid(colors, false);
                return;
            }
            
            const current = SCAN_ORDER[currentStep];
            const centerColor = colors[4];
            
            if (centerColor === 'X' || centerColor !== current.center) {
                const detectedName = centerColor === 'X' ? 'desconhecida' : COLOR_NAMES[centerColor];
                document.getElementById('status-text').textContent = `Centro ${detectedName}, precisa ser ${current.name}`;
                document.getElementById('status-text').style.color = '#ef4444';
                resetStability();
                updateScanGrid(colors, false);
                return;
            }
            
            document.getElementById('status-text').textContent = 'Mantenha est√°vel...';
            document.getElementById('status-text').style.color = '#22c55e';
            
            checkStability(colors);
        }
        
        function checkStability(colors) {
            const now = Date.now();
            
            if (!window.lastColors || !colorsEqual(colors, window.lastColors)) {
                window.lastColors = [...colors];
                window.stabilityStart = now;
                updateStabilityBar(0);
                return;
            }
            
            const elapsed = now - window.stabilityStart;
            const progress = Math.min(elapsed / 1500, 1);
            updateStabilityBar(progress * 100);
            
            if (elapsed >= 1500) {
                onStableDetection(colors);
            }
        }
        
        function onStableDetection(colors) {
            document.querySelectorAll('.scan-cell').forEach(cell => {
                cell.classList.add('stable');
                setTimeout(() => cell.classList.remove('stable'), 400);
            });
            
            const current = SCAN_ORDER[currentStep];
            cubeState[current.code] = [...colors];
            
            if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
            
            updateCube(); // Atualiza cubo 3D
            
            setTimeout(() => {
                nextFace();
            }, 500);
        }
        
        function nextFace() {
            currentStep++;
            window.lastColors = null;
            window.stabilityStart = null;
            updateStabilityBar(0);
            
            if (currentStep >= 6) {
                finishCapture();
            } else {
                updateUI();
                updateCube(); // Atualiza rota√ß√£o do cubo 3D
            }
        }
        
        function skipFace() {
            const current = SCAN_ORDER[currentStep];
            cubeState[current.code] = Array(9).fill(current.center);
            nextFace();
        }
        
        function finishCapture() {
            isScanning = false;
            document.getElementById('status-text').textContent = '‚úì Completo!';
            document.getElementById('skip-btn').style.display = 'none';
            document.getElementById('solution-btn').style.display = 'block';
            localStorage.setItem('rubikState', JSON.stringify(cubeState));
        }
        
        function goToSolution() {
            window.location.href = 'solution.html';
        }
        
        function updateUI() {
            const current = SCAN_ORDER[currentStep];
            document.getElementById('header-title').textContent = `Mostre a face ${current.name.toUpperCase()}`;
            document.getElementById('face-counter').textContent = `${currentStep + 1}/6`;
            
            document.querySelectorAll('.progress-dot').forEach((dot, idx) => {
                dot.classList.remove('active', 'done');
                if (idx < currentStep) dot.classList.add('done');
                else if (idx === currentStep) dot.classList.add('active');
            });
        }
        
        function updateScanGrid(colors, isValid) {
            colors.forEach((code, i) => {
                const cell = document.getElementById(`scan-${i}`);
                if (code !== 'X' && COLOR_MAP[code]) {
                    cell.style.backgroundColor = COLOR_MAP[code];
                    cell.style.opacity = '0.8';
                } else {
                    cell.style.backgroundColor = 'transparent';
                    cell.style.opacity = '1';
                }
                
                if (isValid) cell.classList.add('detected');
                else cell.classList.remove('detected');
            });
        }
        
        function updateStabilityBar(percent) {
            document.getElementById('stability-fill').style.width = percent + '%';
        }
        
        function colorsEqual(a, b) {
            return a.every((v, i) => v === b[i]);
        }
        
        // Manual
        function initManualGrid() {
            const grid = document.getElementById('manual-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'manual-cell';
                cell.dataset.index = i;
                cell.onclick = () => {
                    cell.style.backgroundColor = COLOR_MAP[selectedColor];
                    cell.dataset.color = selectedColor;
                };
                grid.appendChild(cell);
            }
            
            document.querySelectorAll('.color-option').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.color-option').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedColor = btn.dataset.color;
                };
            });
        }
        
        function openManual() {
            const current = SCAN_ORDER[currentStep];
            const state = cubeState[current.code];
            
            document.querySelectorAll('.manual-cell').forEach((cell, i) => {
                const color = state[i] || current.center;
                cell.style.backgroundColor = COLOR_MAP[color];
                cell.dataset.color = color;
            });
            
            document.getElementById('manual-modal').style.display = 'flex';
        }
        
        function closeManual() {
            document.getElementById('manual-modal').style.display = 'none';
        }
        
        function saveManual() {
            const current = SCAN_ORDER[currentStep];
            const colors = [];
            document.querySelectorAll('.manual-cell').forEach(cell => {
                colors.push(cell.dataset.color || current.center);
            });
            
            cubeState[current.code] = colors;
            updateCube();
            closeManual();
            nextFace();
        }
        
        function getPixel(ctx, x, y) {
            const d = ctx.getImageData(Math.max(0, x-4), Math.max(0, y-4), 8, 8).data;
            let r=0, g=0, b=0, n=0;
            for (let i=0; i<d.length; i+=4) {
                r += d[i]; g += d[i+1]; b += d[i+2]; n++;
            }
            return {r: r/n, g: g/n, b: b/n};
        }
        
        function rgbToCode(r, g, b) {
            const [h, s, v] = rgbToHsv(r, g, b);
            
            if (v < 0.12) return 'X';
            if (v > 0.7 && s < 0.2) return 'U';
            if (v > 0.45 && s > 0.25) {
                if (h >= 45 && h < 85) return 'D';
                if (h >= 10 && h < 45) return 'L';
                if ((h >= 330 || h < 20) && s > 0.4) return 'R';
                if (h >= 75 && h < 165) return 'F';
                if (h >= 190 && h < 275) return 'B';
            }
            return v > 0.55 ? 'U' : 'F';
        }
        
        function rgbToHsv(r, g, b) {
            r/=255; g/=255; b/=255;
            const max = Math.max(r,g,b), min = Math.min(r,g,b);
            let h=0, s=0, v=max;
            const d = max-min;
            s = max===0 ? 0 : d/max;
            if (max!==min) {
                switch(max) {
                    case r: h=(g-b)/d+(g<b?6:0); break;
                    case g: h=(b-r)/d+2; break;
                    case b: h=(r-g)/d+4; break;
                }
                h/=6;
            }
            return [h*360, s, v];
        }
    </script>
</body>
</html>
