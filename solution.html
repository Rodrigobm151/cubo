<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rubik Solver - Solução</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cube-solver@2.4.1/dist/bundle.min.js"></script>
    
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: white;
            overflow: hidden;
            touch-action: none;
            margin: 0;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .solution-header {
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            background: rgba(0,0,0,0.5);
            flex-shrink: 0;
        }
        
        .cube-3d-container {
            flex: 1;
            min-height: 0;
            position: relative;
        }
        
        .solution-controls {
            padding: 16px;
            background: #1e293b;
            flex-shrink: 0;
        }
        
        .moves-display {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding: 8px 0;
            margin-bottom: 12px;
            scrollbar-width: none;
        }
        
        .moves-display::-webkit-scrollbar { display: none; }
        
        .move-chip {
            flex-shrink: 0;
            padding: 6px 12px;
            border-radius: 16px;
            background: #334155;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .move-chip.current { background: #3b82f6; transform: scale(1.1); }
        .move-chip.done { background: #22c55e; }
        
        .control-bar {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }
        
        .control-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            background: #475569;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .control-btn.primary {
            width: 60px;
            height: 60px;
            background: #22c55e;
            font-size: 22px;
        }
        
        .control-btn:active { transform: scale(0.95); }
        .control-btn:disabled { opacity: 0.3; }
        
        #loading {
            position: fixed;
            inset: 0;
            background: #0f172a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 300;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body style="display: flex; flex-direction: column; height: 100vh;">

    <div id="loading">
        <div class="spinner"></div>
        <p>Gerando solução...</p>
    </div>

    <div class="solution-header">
        <button class="control-btn" onclick="backToCapture()" style="width: auto; padding: 0 16px; border-radius: 20px; font-size: 14px;">
            ← Voltar
        </button>
        <div style="font-weight: 700; font-size: 18px;">Solução</div>
        <div style="width: 80px;"></div>
    </div>
    
    <div class="cube-3d-container" id="cube-3d"></div>
    
    <div class="solution-controls">
        <div class="moves-display" id="moves-display"></div>
        
        <div class="control-bar">
            <button class="control-btn" onclick="jumpPrev()">⏮</button>
            <button class="control-btn" onclick="stepBack()">◀</button>
            <button class="control-btn primary" onclick="togglePlay()" id="play-btn">▶</button>
            <button class="control-btn" onclick="stepForward()">▶</button>
            <button class="control-btn" onclick="jumpNext()">⏭</button>
        </div>
    </div>

    <script>
        const FACES = [
            { code: 'U', name: 'Branca', color: 0xFFFFFF },
            { code: 'R', name: 'Vermelha', color: 0xFF0000 },
            { code: 'F', name: 'Verde', color: 0x00FF00 },
            { code: 'D', name: 'Amarela', color: 0xFFFF00 },
            { code: 'L', name: 'Laranja', color: 0xFFA500 },
            { code: 'B', name: 'Azul', color: 0x0000FF }
        ];
        
        let cubeState = {};
        let solution = [];
        let currentMoveIdx = 0;
        let isPlaying = false;
        let scene, camera, renderer, cubeGroup;
        let isAnimating = false;
        
        window.onload = () => {
            // Recupera estado do localStorage
            const saved = localStorage.getItem('rubikState');
            if (!saved) {
                alert('Nenhum estado salvo!');
                backToCapture();
                return;
            }
            
            cubeState = JSON.parse(saved);
            generateSolution();
        };
        
        function generateSolution() {
            try {
                const stateStr = FACES.map(f => cubeState[f.code].join('')).join('');
                console.log('Estado:', stateStr);
                
                if (typeof cubeSolver !== 'undefined') {
                    solution = cubeSolver.solve(stateStr).split(' ').filter(m => m);
                } else {
                    // Demo fallback
                    solution = ["U", "R", "U'", "R'", "F", "R", "U", "R'", "U'", "F'"];
                }
                
                document.getElementById('loading').style.display = 'none';
                init3D();
                renderMoves();
                
            } catch (e) {
                alert('Erro ao gerar solução: ' + e.message);
                backToCapture();
            }
        }
        
        function renderMoves() {
            const container = document.getElementById('moves-display');
            solution.forEach((move, i) => {
                const chip = document.createElement('div');
                chip.className = 'move-chip';
                chip.textContent = move;
                chip.onclick = () => goToMove(i);
                container.appendChild(chip);
            });
            updateMoveHighlight();
        }
        
        function updateMoveHighlight() {
            document.querySelectorAll('.move-chip').forEach((c, i) => {
                c.className = 'move-chip' + (i < currentMoveIdx ? ' done' : i === currentMoveIdx ? ' current' : '');
            });
            
            const current = document.querySelectorAll('.move-chip')[currentMoveIdx];
            if (current) current.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
        }
        
        function init3D() {
            const container = document.getElementById('cube-3d');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(6, 5, 7);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            
            const dir = new THREE.DirectionalLight(0xffffff, 0.6);
            dir.position.set(5, 10, 7);
            scene.add(dir);
            
            buildCube();
            animate();
            
            // Touch controls
            let touchStart = null;
            container.addEventListener('touchstart', e => {
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }, {passive: true});
            
            container.addEventListener('touchmove', e => {
                if (!touchStart || isAnimating) return;
                const dx = e.touches[0].clientX - touchStart.x;
                const dy = e.touches[0].clientY - touchStart.y;
                cubeGroup.rotation.y += dx * 0.005;
                cubeGroup.rotation.x += dy * 0.005;
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }, {passive: true});
        }
        
        function buildCube() {
            if (cubeGroup) scene.remove(cubeGroup);
            cubeGroup = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue;
                        
                        const materials = [];
                        const faceDefs = [
                            { axis: 1, val: 1, code: 'R' },
                            { axis: 1, val: -1, code: 'L' },
                            { axis: 2, val: 1, code: 'U' },
                            { axis: 2, val: -1, code: 'D' },
                            { axis: 3, val: 1, code: 'F' },
                            { axis: 3, val: -1, code: 'B' }
                        ];
                        
                        faceDefs.forEach(face => {
                            const isSticker = (face.axis === 1 && x === face.val) ||
                                            (face.axis === 2 && y === face.val) ||
                                            (face.axis === 3 && z === face.val);
                            
                            if (isSticker) {
                                const idx = getStickerIndex(x, y, z, face.code);
                                const colorCode = cubeState[face.code][idx] || face.code;
                                const color = FACES.find(f => f.code === colorCode)?.color || 0x333333;
                                materials.push(new THREE.MeshLambertMaterial({ color }));
                            } else {
                                materials.push(new THREE.MeshLambertMaterial({ color: 0x111111 }));
                            }
                        });
                        
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(x, y, z);
                        
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                        cubie.add(line);
                        
                        cubeGroup.add(cubie);
                    }
                }
            }
            
            scene.add(cubeGroup);
        }
        
        function getStickerIndex(x, y, z, face) {
            switch(face) {
                case 'U': return (1-Math.round(y))*3 + (Math.round(x)+1);
                case 'D': return (Math.round(y)+1)*3 + (Math.round(x)+1);
                case 'R': return (1-Math.round(y))*3 + (1-Math.round(z));
                case 'L': return (1-Math.round(y))*3 + (Math.round(z)+1);
                case 'F': return (1-Math.round(y))*3 + (Math.round(x)+1);
                case 'B': return (1-Math.round(y))*3 + (1-Math.round(x));
            }
            return 4;
        }
        
        async function executeMove(move) {
            if (isAnimating) return;
            isAnimating = true;
            
            const face = move.charAt(0);
            const clockwise = !move.includes("'");
            const double = move.includes('2');
            
            let axis = new THREE.Vector3();
            let layerValue = 0;
            let angle = Math.PI / 2;
            
            if (!clockwise) angle = -angle;
            if (double) angle *= 2;
            
            switch(face) {
                case 'U': axis.set(0, 1, 0); layerValue = 1; break;
                case 'D': axis.set(0, 1, 0); layerValue = -1; angle = -angle; break;
                case 'R': axis.set(1, 0, 0); layerValue = 1; break;
                case 'L': axis.set(1, 0, 0); layerValue = -1; angle = -angle; break;
                case 'F': axis.set(0, 0, 1); layerValue = 1; break;
                case 'B': axis.set(0, 0, 1); layerValue = -1; angle = -angle; break;
            }
            
            const layerCubies = [];
            cubeGroup.children.forEach(cubie => {
                if (Math.abs(cubie.position.dot(axis) - layerValue) < 0.1) {
                    layerCubies.push(cubie);
                }
            });
            
            const pivot = new THREE.Object3D();
            scene.add(pivot);
            layerCubies.forEach(cubie => pivot.attach(cubie));
            
            const duration = double ? 500 : 350;
            const startTime = Date.now();
            
            await new Promise(resolve => {
                function animateMove() {
                    const elapsed = Date.now() - startTime;
                    const t = Math.min(elapsed / duration, 1);
                    const ease = 1 - Math.pow(1 - t, 3);
                    
                    pivot.rotation.set(0, 0, 0);
                    pivot.rotateOnAxis(axis, angle * ease);
                    
                    if (t < 1) {
                        requestAnimationFrame(animateMove);
                    } else {
                        pivot.rotation.set(0, 0, 0);
                        pivot.rotateOnAxis(axis, angle);
                        layerCubies.forEach(cubie => cubeGroup.attach(cubie));
                        updateCubeState(face, clockwise, double);
                        scene.remove(pivot);
                        isAnimating = false;
                        resolve();
                    }
                }
                animateMove();
            });
        }
        
        function updateCubeState(face, clockwise, double) {
            const rotations = double ? 2 : 1;
            for (let r = 0; r < rotations; r++) {
                const f = [...cubeState[face]];
                if (clockwise) {
                    cubeState[face] = [f[6], f[3], f[0], f[7], f[4], f[1], f[8], f[5], f[2]];
                } else {
                    cubeState[face] = [f[2], f[5], f[8], f[1], f[4], f[7], f[0], f[3], f[6]];
                }
            }
        }
        
        function togglePlay() {
            if (isPlaying) pause();
            else play();
        }
        
        function play() {
            if (currentMoveIdx >= solution.length) {
                currentMoveIdx = 0;
                buildCube();
            }
            
            isPlaying = true;
            document.getElementById('play-btn').textContent = '⏸';
            
            async function loop() {
                if (!isPlaying || currentMoveIdx >= solution.length) {
                    pause();
                    return;
                }
                await executeMove(solution[currentMoveIdx]);
                currentMoveIdx++;
                updateMoveHighlight();
                setTimeout(loop, 600);
            }
            loop();
        }
        
        function pause() {
            isPlaying = false;
            document.getElementById('play-btn').textContent = '▶';
        }
        
        async function stepForward() {
            pause();
            if (currentMoveIdx < solution.length && !isAnimating) {
                await executeMove(solution[currentMoveIdx]);
                currentMoveIdx++;
                updateMoveHighlight();
            }
        }
        
        async function stepBack() {
            pause();
            if (currentMoveIdx > 0) {
                currentMoveIdx--;
                buildCube();
                for (let i = 0; i < currentMoveIdx; i++) {
                    await executeMove(solution[i]);
                }
                updateMoveHighlight();
            }
        }
        
        async function jumpNext() {
            pause();
            const target = Math.min(currentMoveIdx + 5, solution.length);
            while (currentMoveIdx < target) await stepForward();
        }
        
        async function jumpPrev() {
            pause();
            const target = Math.max(currentMoveIdx - 5, 0);
            currentMoveIdx = target;
            buildCube();
            for (let i = 0; i < target; i++) await executeMove(solution[i]);
            updateMoveHighlight();
        }
        
        async function goToMove(idx) {
            pause();
            currentMoveIdx = idx;
            buildCube();
            for (let i = 0; i < idx; i++) await executeMove(solution[i]);
            updateMoveHighlight();
        }
        
        function backToCapture() {
            pause();
            window.location.href = 'index.html';
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                const container = document.getElementById('cube-3d');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html>
