<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rubik AI Solver - Solução</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.1/dist/cube.js"></script>
    <style>
        :root { --accent: #00ff88; --bg: #111; }
        html, body { position: fixed; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: var(--bg); font-family: sans-serif; color: white; }
        
        /* Telas */
        .screen { display: none; width: 100%; height: 100%; flex-direction: column; }
        .active { display: flex; }

        /* Scanner Styles */
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #overlay { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); width: 260px; height: 260px; display: grid; grid-template-columns: repeat(3, 1fr); z-index: 10; border: 3px solid var(--accent); border-radius: 10px; pointer-events: none; }
        .grid-cell { border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; }
        .sensor-dot { width: 10px; height: 10px; border-radius: 50%; border: 2px solid #fff; }

        /* Solution Styles */
        #canvas-container { flex: 1; width: 100%; }
        #move-display { position: absolute; top: 60px; width: 100%; text-align: center; font-size: 2.5rem; font-weight: 900; color: var(--accent); text-shadow: 0 0 10px rgba(0,255,136,0.5); z-index: 100; }
        
        .controls { position: absolute; bottom: 0; width: 100%; padding-bottom: calc(30px + env(safe-area-inset-bottom)); background: linear-gradient(transparent, rgba(0,0,0,0.9) 40%); text-align: center; z-index: 100; }
        .instruction { margin-bottom: 15px; font-size: 1.1rem; }
        .face-name { color: var(--accent); font-weight: bold; }
        
        button { padding: 18px 40px; border-radius: 15px; border: none; background: var(--accent); color: #000; font-weight: bold; font-size: 1rem; box-shadow: 0 5px 15px rgba(0,0,0,0.4); }
        button.secondary { background: #444; color: white; margin-right: 10px; }
        
        #mini-preview { position: absolute; top: 20px; right: 20px; width: 100px; height: 100px; background: rgba(0,0,0,0.6); border-radius: 12px; z-index: 50; }
    </style>
</head>
<body>

    <div id="scanner-screen" class="screen active">
        <video id="camera" autoplay playsinline></video>
        <div id="overlay">
            <div class="grid-cell"><div class="sensor-dot"></div></div><div class="grid-cell"><div class="sensor-dot"></div></div><div class="grid-cell"><div class="sensor-dot"></div></div>
            <div class="grid-cell"><div class="sensor-dot"></div></div><div class="grid-cell"><div class="sensor-dot"></div></div><div class="grid-cell"><div class="sensor-dot"></div></div>
            <div class="grid-cell"><div class="sensor-dot"></div></div><div class="grid-cell"><div class="sensor-dot"></div></div><div class="grid-cell"><div class="sensor-dot"></div></div>
        </div>
        <div id="mini-preview"></div>
        <div class="controls">
            <div class="instruction">Aponte a face: <span id="target-face-name" class="face-name">BRANCA</span></div>
            <button onclick="captureFace()">CAPTURAR FACE</button>
        </div>
    </div>

    <div id="solution-screen" class="screen">
        <div id="move-display">CALCULANDO...</div>
        <div id="canvas-container"></div>
        <div class="controls">
            <button class="secondary" onclick="stepMove(-1)">ANTERIOR</button>
            <button onclick="stepMove(1)">PRÓXIMO PASSO</button>
        </div>
    </div>

    <script>
        // Configurações do Cubo
        const faces = ['U', 'R', 'F', 'D', 'L', 'B'];
        const faceNames = ["BRANCA (Topo)", "VERMELHA (Direita)", "VERDE (Frente)", "AMARELA (Base)", "LARANJA (Esquerda)", "AZUL (Trás)"];
        let currentStep = 0;
        let scanResult = {}; // Formato: { 'U': [cor, cor...], ... }

        // Three.js Globais
        let scene, camera, renderer, cubeGroup, isAnimating = false;
        let solutionMoves = [];
        let currentMoveIndex = -1;

        // --- INICIALIZAÇÃO ---
        window.onload = () => {
            setupCamera();
            init3D();
            liveSensor();
        };

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            document.getElementById('camera').srcObject = stream;
        }

        function init3D() {
            // Reutilizando lógica de criação de cubo arredondado
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 6, 8);
            camera.lookAt(0,0,0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(5,10,5);
            scene.add(sun);

            createCubeGroup();
            animate();
        }

        function createCubeGroup() {
            cubeGroup = new THREE.Group();
            const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            for(let x=-1; x<=1; x++){
                for(let y=-1; y<=1; y++){
                    for(let z=-1; z<=1; z++){
                        const mats = Array(6).fill().map(() => new THREE.MeshStandardMaterial({color: 0x222222}));
                        const mesh = new THREE.Mesh(geom, mats);
                        mesh.position.set(x, y, z);
                        mesh.userData = { initialPos: {x,y,z} };
                        cubeGroup.add(mesh);
                    }
                }
            }
            scene.add(cubeGroup);
        }

        // --- LÓGICA DE CAPTURA ---
        function liveSensor() {
            // Atualiza os pontinhos do overlay (mesma lógica anterior)
            const video = document.getElementById('camera');
            if(video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                canvas.width = 100; canvas.height = 100; // Baixa res para performance
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, 100, 100);
                // ... amostragem simplificada aqui ...
            }
            requestAnimationFrame(liveSensor);
        }

        function captureFace() {
            // Simulando captura de cores para o exemplo funcionar
            // Em produção, usa a análise de pixel que fizemos antes
            const dummyColors = Array(9).fill(0xffffff); 
            scanResult[faces[currentStep]] = dummyColors;
            
            applyColorsToFace(faces[currentStep], dummyColors);

            currentStep++;
            if(currentStep < faces.length) {
                document.getElementById('target-face-name').innerText = faceNames[currentStep];
                // Rotaciona o cubo para a próxima face
                rotateCubeToFace(faces[currentStep]);
            } else {
                startSolver();
            }
        }

        function applyColorsToFace(face, colors) {
            // Pintar as faces dos cubinhos no Three.js
            cubeGroup.children.forEach(c => {
                const p = c.position;
                if(face === 'U' && Math.round(p.y) === 1) c.material[2].color.set(0xffffff);
                if(face === 'D' && Math.round(p.y) === -1) c.material[3].color.set(0xffff00);
                if(face === 'F' && Math.round(p.z) === 1) c.material[4].color.set(0x00ff00);
                if(face === 'B' && Math.round(p.z) === -1) c.material[5].color.set(0x0000ff);
                if(face === 'R' && Math.round(p.x) === 1) c.material[0].color.set(0xff0000);
                if(face === 'L' && Math.round(p.x) === -1) c.material[1].color.set(0xffa500);
            });
        }

        // --- ENGINE DE SOLUÇÃO ---
        function startSolver() {
            document.getElementById('scanner-screen').classList.remove('active');
            document.getElementById('solution-screen').classList.add('active');
            
            // Centraliza o cubo para a solução
            cubeGroup.rotation.set(0.3, -0.5, 0);

            // 1. Inicializa Kociemba
            Cube.initSolver();
            // 2. Cria string de estado (Exemplo estático para teste, você deve gerar a string real)
            const cube = Cube.random(); // Aqui entra o resultado do seu scan
            const solution = cube.solve();
            solutionMoves = solution.split(" ");
            
            document.getElementById('move-display').innerText = solutionMoves[0];
        }

        function stepMove(dir) {
            if(isAnimating) return;
            if(dir === 1 && currentMoveIndex < solutionMoves.length - 1) {
                currentMoveIndex++;
                animateMove(solutionMoves[currentMoveIndex]);
            }
            document.getElementById('move-display').innerText = solutionMoves[currentMoveIndex+1] || "FIM";
        }

        function animateMove(moveStr) {
            isAnimating = true;
            const face = moveStr[0]; // U, R, F...
            const modifier = moveStr[1] || ""; // ', 2 ou vazio
            
            let angle = Math.PI / 2;
            if(modifier === "'") angle = -Math.PI / 2;
            if(modifier === "2") angle = Math.PI;

            const axisMap = { 'U': 'y', 'D': 'y', 'R': 'x', 'L': 'x', 'F': 'z', 'B': 'z' };
            const layerMap = { 'U': 1, 'D': -1, 'R': 1, 'L': -1, 'F': 1, 'B': -1 };
            
            const axis = axisMap[face];
            const layerValue = layerMap[face];

            const group = new THREE.Group();
            scene.add(group);

            const toRotate = cubeGroup.children.filter(c => Math.round(c.position[axis]) === layerValue);
            toRotate.forEach(c => group.add(c));

            let currentAngle = 0;
            const speed = 0.1 * (angle > 0 ? 1 : -1);

            function rot() {
                currentAngle += speed;
                if(Math.abs(currentAngle) >= Math.abs(angle)) {
                    group.rotation[axis] = angle;
                    // Finaliza e limpa grupo
                    const tempArr = [...group.children];
                    tempArr.forEach(c => {
                        c.getWorldPosition(c.position);
                        c.getWorldQuaternion(c.quaternion);
                        c.position.x = Math.round(c.position.x);
                        c.position.y = Math.round(c.position.y);
                        c.position.z = Math.round(c.position.z);
                        cubeGroup.add(c);
                    });
                    scene.remove(group);
                    isAnimating = false;
                } else {
                    group.rotation[axis] = currentAngle;
                    requestAnimationFrame(rot);
                }
            }
            rot();
        }

        function rotateCubeToFace(face) {
            // Animação simples de rotação da câmera ou cubo para a próxima face no scan
            const rots = { 'U': [0.5,0.5], 'R': [0, -1.5], 'F': [0,0], 'D': [-1.5,0], 'L': [0,1.5], 'B': [0,3.14] };
            cubeGroup.rotation.set(rots[face][0], rots[face][1], 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
