<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeScanner Pro - Layer Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; background: #0f172a; }
        
        /* Scanner Grid */
        .scanner-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            width: 210px;
            height: 210px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: none;
        }
        
        .scanner-cell {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .scanner-cell.detected { border-color: #4ade80; background: rgba(74, 222, 128, 0.1); }
        .scanner-cell.center { border-color: #fbbf24; border-width: 3px; }
        
        .color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }
        
        .color-dot.locked {
            transform: translate(-50%, -50%) scale(1.3);
            box-shadow: 0 0 15px currentColor;
            border-color: white;
        }

        /* Detection Overlay */
        .detection-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 220px;
            height: 220px;
            border: 3px solid transparent;
            border-radius: 16px;
            z-index: 15;
            transition: all 0.3s;
        }
        
        .detection-frame.waiting { border-color: #ef4444; box-shadow: 0 0 20px rgba(239, 68, 68, 0.3); }
        .detection-frame.detected { border-color: #22c55e; box-shadow: 0 0 30px rgba(34, 197, 94, 0.5); }
        .detection-frame.stable { border-color: #3b82f6; box-shadow: 0 0 40px rgba(59, 130, 246, 0.6); }

        /* Progress Ring */
        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 240px;
            height: 240px;
            pointer-events: none;
            z-index: 25;
        }
        
        .progress-ring circle { transition: stroke-dashoffset 0.1s linear; transform: rotate(-90deg); transform-origin: 50% 50%; }

        /* Glassmorphism */
        .glass {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Move notation */
        .move-notation {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9rem;
            color: white;
            margin: 2px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        
        .move-notation.active { ring: 2px solid white; transform: scale(1.1); background: linear-gradient(135deg, #22c55e, #16a34a); }
        .move-notation.completed { opacity: 0.4; transform: scale(0.9); }

        /* Layer indicators */
        .layer-indicator {
            position: absolute;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body class="text-white min-h-screen">

    <div id="app" class="relative min-h-screen flex flex-col">
        
        <!-- Header -->
        <header class="glass fixed top-0 w-full z-50 px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-lg flex items-center justify-center text-xl font-bold">üé≤</div>
                <div>
                    <h1 class="font-bold text-lg">CubeScanner Pro</h1>
                    <p class="text-xs text-gray-400">Detec√ß√£o & Solver de Camadas</p>
                </div>
            </div>
            <div id="stage-indicator" class="px-4 py-1 rounded-full bg-gray-800 text-sm font-medium border border-gray-700">Fase: Detec√ß√£o</div>
        </header>

        <!-- SCANNER SECTION -->
        <section id="scanner-section" class="flex-1 flex flex-col items-center justify-center pt-20 pb-6 px-4">
            
            <!-- Camera Preview -->
            <div class="relative w-full max-w-md aspect-[3/4] bg-black rounded-2xl overflow-hidden shadow-2xl border border-gray-700">
                <video id="camera-feed" class="absolute inset-0 w-full h-full object-cover" autoplay playsinline muted></video>
                <canvas id="processing-canvas" class="hidden"></canvas>
                
                <!-- Fallback -->
                <div id="camera-fallback" class="absolute inset-0 bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center hidden">
                    <div class="text-center p-6">
                        <div class="text-6xl mb-4">üì∑</div>
                        <p class="text-gray-400 mb-4">Permita o acesso √† c√¢mera</p>
                        <button onclick="startSimulationMode()" class="px-4 py-2 bg-blue-600 rounded-lg text-sm">Usar Modo Simula√ß√£o</button>
                    </div>
                </div>

                <!-- Detection Visuals -->
                <div class="detection-frame waiting" id="detection-frame"></div>
                
                <div class="scanner-grid" id="scanner-grid"></div>
                
                <svg class="progress-ring">
                    <circle cx="120" cy="120" r="115" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="4"/>
                    <circle id="progress-circle" cx="120" cy="120" r="115" fill="none" stroke="#3b82f6" stroke-width="4" 
                            stroke-dasharray="722" stroke-dashoffset="722" stroke-linecap="round"/>
                </svg>

                <!-- Status -->
                <div class="absolute top-8 left-0 w-full text-center z-30">
                    <div id="current-face-badge" class="inline-block px-6 py-2 rounded-full bg-black/50 backdrop-blur-md border-2 text-lg font-bold transition-all">
                        Frente (Verde)
                    </div>
                </div>

                <div class="absolute bottom-8 left-0 w-full text-center z-30 space-y-2">
                    <div id="detection-status" class="text-sm font-bold text-red-400">‚ùå Cubo n√£o detectado</div>
                    <div id="stability-bar" class="w-48 h-1 bg-gray-700 rounded-full mx-auto overflow-hidden hidden">
                        <div id="stability-fill" class="h-full bg-blue-500 w-0 transition-all duration-100"></div>
                    </div>
                </div>
            </div>

            <!-- Preview Cube -->
            <div class="mt-6 w-full max-w-md">
                <div class="glass rounded-xl p-4 flex items-center gap-4">
                    <div id="preview-cube" class="w-24 h-24 flex-shrink-0"></div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-sm text-gray-300 mb-1">Preview 3D</h3>
                        <div id="scan-progress" class="flex gap-1 mb-2"></div>
                        <p class="text-xs text-gray-500" id="scan-hint">Posicione o cubo alinhado √† grade</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- SOLVER SECTION -->
        <section id="solver-section" class="hidden flex-1 flex-col pt-20 pb-6 px-4 bg-gray-900">
            <div class="flex-1 flex flex-col items-center justify-center max-w-5xl mx-auto w-full">
                
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                        Cubo Reconstru√≠do
                    </h2>
                    <p class="text-gray-400 text-sm">Execu√ß√£o de camadas individuais</p>
                </div>

                <!-- Main 3D Cube -->
                <div id="main-cube-container" class="w-full h-[400px] relative mb-4"></div>

                <!-- Controls -->
                <div class="w-full glass rounded-2xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="font-bold text-lg">Solu√ß√£o Passo a Passo</h3>
                            <p class="text-xs text-gray-400 mt-1">Rota√ß√µes de camadas individuais</p>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="solver.prev()" class="px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition text-sm">‚Üê</button>
                            <button onclick="solver.togglePlay()" id="play-btn" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 transition text-sm font-medium w-20">‚ñ∂ Play</button>
                            <button onclick="solver.next()" class="px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition text-sm">‚Üí</button>
                        </div>
                    </div>

                    <div class="bg-gray-800 rounded-xl p-4 mb-4 min-h-[80px] flex items-center justify-center flex-wrap gap-1" id="moves-display"></div>

                    <div class="flex items-center gap-4">
                        <span class="text-xs text-gray-500 w-16 text-right" id="move-counter">0/0</span>
                        <div class="flex-1 h-2 bg-gray-700 rounded-full overflow-hidden">
                            <div id="solution-progress" class="h-full bg-gradient-to-r from-blue-500 to-purple-500 w-0 transition-all duration-300"></div>
                        </div>
                    </div>
                </div>

                <button onclick="location.reload()" class="mt-6 px-8 py-3 rounded-full bg-gray-800 hover:bg-gray-700 border border-gray-700 transition font-medium text-sm">
                    üîÑ Novo Escaneamento
                </button>
            </div>
        </section>

    </div>

    <script>
        // Configuration
        const FACE_ORDER = [
            { name: 'Frente', color: 'green', code: 'F', axis: 'z', layer: 1, normal: [0, 0, 1] },
            { name: 'Direita', color: 'red', code: 'R', axis: 'x', layer: 1, normal: [1, 0, 0] },
            { name: 'Atr√°s', color: 'blue', code: 'B', axis: 'z', layer: -1, normal: [0, 0, -1] },
            { name: 'Esquerda', color: 'orange', code: 'L', axis: 'x', layer: -1, normal: [-1, 0, 0] },
            { name: 'Topo', color: 'white', code: 'U', axis: 'y', layer: 1, normal: [0, 1, 0] },
            { name: 'Base', color: 'yellow', code: 'D', axis: 'y', layer: -1, normal: [0, -1, 0] }
        ];

        const COLORS = {
            white: 0xFFFFFF, yellow: 0xFFD500, red: 0xFF0000,
            orange: 0xFF8C00, blue: 0x0051BA, green: 0x009E60,
            gray: 0x374151, black: 0x111827
        };

        // State
        const state = {
            currentFaceIndex: 0,
            scannedFaces: Array(6).fill(null).map(() => Array(9).fill(null)),
            isStable: false,
            stabilityTime: 0,
            lastDetectedColors: null,
            consistencyCount: 0,
            cameraActive: false,
            detectionActive: true
        };

        let previewScene, previewCamera, previewRenderer, previewCube;
        let mainScene, mainCamera, mainRenderer;
        let cubies = []; // Array of 27 meshes
        let animationId;

        // Initialize
        function init() {
            initScannerGrid();
            initPreviewCube();
            updateScanProgress();
            initCamera();
        }

        function initScannerGrid() {
            const grid = document.getElementById('scanner-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = `scanner-cell ${i === 4 ? 'center' : ''}`;
                cell.id = `cell-${i}`;
                
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.id = `dot-${i}`;
                
                cell.appendChild(dot);
                grid.appendChild(cell);
            }
        }

        // Camera with Real Detection Simulation
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: 640, height: 480 } 
                });
                const video = document.getElementById('camera-feed');
                video.srcObject = stream;
                state.cameraActive = true;
                
                video.onloadeddata = () => {
                    startDetectionLoop();
                };
            } catch (err) {
                document.getElementById('camera-fallback').classList.remove('hidden');
            }
        }

        function startSimulationMode() {
            document.getElementById('camera-fallback').classList.add('hidden');
            const video = document.getElementById('camera-feed');
            video.classList.remove('hidden');
            // Create a canvas to simulate video feed
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            // Draw simulated noise/cube
            function drawSimulatedFeed() {
                if (!state.detectionActive) return;
                
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(0, 0, 640, 480);
                
                // Draw simulated cube face
                const cx = 320, cy = 240;
                const size = 150;
                ctx.fillStyle = `rgb(${Math.random()*50}, ${100 + Math.random()*100}, ${Math.random()*50})`;
                ctx.fillRect(cx - size/2, cy - size/2, size, size);
                
                // Add noise
                for (let i = 0; i < 1000; i++) {
                    ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.1})`;
                    ctx.fillRect(Math.random()*640, Math.random()*480, 2, 2);
                }
                
                // Create video texture from canvas
                if (!video.srcObject) {
                    const stream = canvas.captureStream(30);
                    video.srcObject = stream;
                }
                
                requestAnimationFrame(drawSimulatedFeed);
            }
            drawSimulatedFeed();
            setTimeout(startDetectionLoop, 500);
        }

        // Detection Loop - Only captures when cube is stable and detected
        function startDetectionLoop() {
            const video = document.getElementById('camera-feed');
            const canvas = document.getElementById('processing-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 240;
            
            function analyzeFrame() {
                if (!state.detectionActive || state.currentFaceIndex >= 6) return;
                
                ctx.drawImage(video, 0, 0, 320, 240);
                
                // Sample 9 regions (3x3 grid center)
                const colors = [];
                const cellWidth = 320 / 3;
                const cellHeight = 240 / 3;
                const offsetX = 80; // Center offset
                const offsetY = 60;
                
                let validDetections = 0;
                
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        const px = offsetX + x * cellWidth * 0.6 + cellWidth * 0.2;
                        const py = offsetY + y * cellHeight * 0.6 + cellHeight * 0.2;
                        
                        const pixel = ctx.getImageData(px, py, 1, 1).data;
                        const detectedColor = classifyColor(pixel[0], pixel[1], pixel[2]);
                        
                        if (detectedColor) validDetections++;
                        colors.push(detectedColor || 'gray');
                    }
                }
                
                // Check if we have a valid cube detection (at least 5 valid colors)
                const isCubeDetected = validDetections >= 5;
                updateDetectionUI(isCubeDetected, colors);
                
                if (isCubeDetected) {
                    checkStability(colors);
                } else {
                    resetStability();
                }
                
                requestAnimationFrame(analyzeFrame);
            }
            
            analyzeFrame();
        }

        function classifyColor(r, g, b) {
            // Simple color classification based on RGB values
            const brightness = (r + g + b) / 3;
            
            // White (high brightness, balanced)
            if (brightness > 200 && Math.abs(r-g) < 30 && Math.abs(r-b) < 30) return 'white';
            // Yellow (high red+green, low blue)
            if (r > 150 && g > 150 && b < 100 && Math.abs(r-g) < 50) return 'yellow';
            // Red (high red, low others)
            if (r > 120 && g < 100 && b < 100) return 'red';
            // Orange (high red, medium green, low blue)
            if (r > 150 && g > 80 && g < 150 && b < 80) return 'orange';
            // Blue (low red+green, high blue)
            if (r < 100 && g < 120 && b > 120) return 'blue';
            // Green (low red, high green, low blue)
            if (r < 100 && g > 100 && b < 100) return 'green';
            
            return null;
        }

        function updateDetectionUI(detected, colors) {
            const frame = document.getElementById('detection-frame');
            const status = document.getElementById('detection-status');
            const bar = document.getElementById('stability-bar');
            
            // Update grid dots
            colors.forEach((color, i) => {
                const dot = document.getElementById(`dot-${i}`);
                const cell = document.getElementById(`cell-${i}`);
                
                if (color && COLORS[color]) {
                    const hex = COLORS[color];
                    const r = (hex >> 16) & 255;
                    const g = (hex >> 8) & 255;
                    const b = hex & 255;
                    dot.style.backgroundColor = `rgb(${r},${g},${b})`;
                    dot.style.borderColor = 'white';
                    cell.classList.add('detected');
                } else {
                    dot.style.backgroundColor = 'rgba(0,0,0,0.5)';
                    dot.style.borderColor = 'rgba(255,255,255,0.3)';
                    cell.classList.remove('detected');
                }
            });
            
            if (detected) {
                frame.className = 'detection-frame detected';
                status.textContent = '‚úì Cubo detectado - Mantenha est√°vel';
                status.className = 'text-sm font-bold text-green-400';
                bar.classList.remove('hidden');
            } else {
                frame.className = 'detection-frame waiting';
                status.textContent = '‚ùå Cubo n√£o detectado - Posicione na grade';
                status.className = 'text-sm font-bold text-red-400';
                bar.classList.add('hidden');
            }
        }

        function checkStability(currentColors) {
            // Check if colors are consistent with previous frame
            if (state.lastDetectedColors) {
                let matches = 0;
                for (let i = 0; i < 9; i++) {
                    if (currentColors[i] === state.lastDetectedColors[i]) matches++;
                }
                
                if (matches >= 7) { // 7/9 colors must match
                    state.consistencyCount++;
                } else {
                    state.consistencyCount = Math.max(0, state.consistencyCount - 1);
                }
            }
            
            state.lastDetectedColors = [...currentColors];
            
            // Need 30 consistent frames (approx 0.5s at 60fps, or 1s with delays)
            const requiredFrames = 30;
            const progress = Math.min(state.consistencyCount / requiredFrames, 1);
            
            document.getElementById('stability-fill').style.width = `${progress * 100}%`;
            document.getElementById('progress-circle').style.strokeDashoffset = 722 - (progress * 722);
            
            if (state.consistencyCount >= requiredFrames) {
                // Check if center color matches expected face
                const expectedColor = FACE_ORDER[state.currentFaceIndex].color;
                if (currentColors[4] === expectedColor || currentColors[4] === null) {
                    captureFace(currentColors);
                } else {
                    showCenterColorError(currentColors[4], expectedColor);
                }
            }
        }

        function resetStability() {
            state.consistencyCount = 0;
            state.lastDetectedColors = null;
            document.getElementById('stability-fill').style.width = '0%';
            document.getElementById('progress-circle').style.strokeDashoffset = 722;
        }

        function showCenterColorError(detected, expected) {
            const status = document.getElementById('detection-status');
            status.textContent = `‚ö†Ô∏è Centro deve ser ${expected}, detectado ${detected || 'indefinido'}`;
            status.className = 'text-sm font-bold text-yellow-400';
        }

        function captureFace(colors) {
            state.detectionActive = false;
            state.scannedFaces[state.currentFaceIndex] = colors;
            
            // Visual feedback
            const badge = document.getElementById('current-face-badge');
            badge.textContent = '‚úì Capturado!';
            badge.className = 'inline-block px-6 py-2 rounded-full bg-green-500 text-white text-lg font-bold shadow-lg';
            
            updatePreviewCube();
            updateScanProgress();
            
            setTimeout(() => {
                state.currentFaceIndex++;
                if (state.currentFaceIndex < 6) {
                    resetForNextFace();
                } else {
                    finishScanning();
                }
            }, 1000);
        }

        function resetForNextFace() {
            state.detectionActive = true;
            resetStability();
            
            const face = FACE_ORDER[state.currentFaceIndex];
            const badge = document.getElementById('current-face-badge');
            badge.textContent = `${face.name} (${face.color.charAt(0).toUpperCase() + face.color.slice(1)})`;
            badge.className = 'inline-block px-6 py-2 rounded-full bg-black/50 backdrop-blur-md border-2 text-lg font-bold transition-all';
            badge.style.borderColor = `rgb(${(COLORS[face.color] >> 16) & 255}, ${(COLORS[face.color] >> 8) & 255}, ${COLORS[face.color] & 255})`;
            
            // Clear grid
            for (let i = 0; i < 9; i++) {
                document.getElementById(`dot-${i}`).style.backgroundColor = 'rgba(0,0,0,0.5)';
                document.getElementById(`cell-${i}`).classList.remove('detected');
            }
            
            startDetectionLoop();
        }

        // Preview Cube
        function initPreviewCube() {
            const container = document.getElementById('preview-cube');
            previewScene = new THREE.Scene();
            previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            previewCamera.position.set(2.5, 2.5, 2.5);
            previewCamera.lookAt(0, 0, 0);
            
            previewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRenderer.setSize(96, 96);
            container.appendChild(previewRenderer.domElement);
            
            previewScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(5, 5, 5);
            previewScene.add(light);
            
            previewCube = new THREE.Group();
            const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            
            FACE_ORDER.forEach((face, idx) => {
                const material = new THREE.MeshPhongMaterial({ 
                    color: COLORS.gray, shininess: 100 
                });
                const mesh = new THREE.Mesh(geometry, material);
                const pos = face.normal.map(n => n * 0.5);
                mesh.position.set(...pos);
                mesh.lookAt(0, 0, 0);
                mesh.userData.faceIndex = idx;
                previewCube.add(mesh);
            });
            
            previewScene.add(previewCube);
            animatePreview();
        }

        function animatePreview() {
            requestAnimationFrame(animatePreview);
            previewCube.rotation.y += 0.01;
            previewCube.rotation.x += 0.005;
            previewRenderer.render(previewScene, previewCamera);
        }

        function updatePreviewCube() {
            previewCube.children.forEach((mesh, idx) => {
                const face = state.scannedFaces[idx];
                if (face && face[4]) {
                    mesh.material.color.setHex(COLORS[face[4]]);
                    mesh.material.emissive.setHex(COLORS[face[4]]);
                    mesh.material.emissiveIntensity = 0.3;
                }
            });
        }

        function updateScanProgress() {
            const container = document.getElementById('scan-progress');
            container.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const dot = document.createElement('div');
                dot.className = `w-2 h-2 rounded-full ${i < state.currentFaceIndex ? 'bg-green-500' : i === state.currentFaceIndex ? 'bg-blue-500 animate-pulse' : 'bg-gray-600'}`;
                container.appendChild(dot);
            }
        }

        // Main Solver with Layer Rotations
        function finishScanning() {
            document.getElementById('stage-indicator').textContent = 'Fase: Solu√ß√£o';
            document.getElementById('scanner-section').classList.add('hidden');
            document.getElementById('solver-section').classList.remove('hidden');
            
            initMainCube();
            solver.init();
        }

        function initMainCube() {
            const container = document.getElementById('main-cube-container');
            mainScene = new THREE.Scene();
            mainScene.background = new THREE.Color(0x0f172a);
            
            mainCamera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            mainCamera.position.set(4, 3, 5);
            mainCamera.lookAt(0, 0, 0);
            
            mainRenderer = new THREE.WebGLRenderer({ antialias: true });
            mainRenderer.setSize(container.clientWidth, container.clientHeight);
            mainRenderer.shadowMap.enabled = true;
            container.appendChild(mainRenderer.domElement);
            
            // Lights
            mainScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            mainScene.add(dirLight);
            
            createCubies();
            animateMain();
            
            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };
                    
                    const group = new THREE.Group();
                    cubies.forEach(c => group.add(c));
                    group.rotation.y += deltaMove.x * 0.01;
                    group.rotation.x += deltaMove.y * 0.01;
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            container.addEventListener('mouseup', () => isDragging = false);
        }

        function createCubies() {
            cubies = [];
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [];
                        
                        // Right (x=1), Left (x=-1), Top (y=1), Bottom (y=-1), Front (z=1), Back (z=-1)
                        const faceMap = [
                            x === 1 ? 1 : -1,  // Right
                            x === -1 ? 3 : -1, // Left  
                            y === 1 ? 4 : -1,  // Up
                            y === -1 ? 5 : -1, // Down
                            z === 1 ? 0 : -1,  // Front
                            z === -1 ? 2 : -1  // Back
                        ];
                        
                        faceMap.forEach(faceIdx => {
                            if (faceIdx >= 0) {
                                const face = state.scannedFaces[faceIdx];
                                // Map 3D position to 2D face index
                                const color = getCubieColor(faceIdx, x, y, z, face);
                                materials.push(new THREE.MeshPhongMaterial({ 
                                    color: COLORS[color] || COLORS.black,
                                    shininess: 100
                                }));
                            } else {
                                materials.push(new THREE.MeshPhongMaterial({ color: COLORS.black }));
                            }
                        });
                        
                        const mesh = new THREE.Mesh(geometry, materials);
                        mesh.position.set(x, y, z);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { x, y, z }; // Original position for layer identification
                        mainScene.add(mesh);
                        cubies.push(mesh);
                    }
                }
            }
        }

        function getCubieColor(faceIdx, x, y, z, faceColors) {
            if (!faceColors) return 'gray';
            
            // Map 3D coordinates to 2D grid index (0-8)
            let idx;
            switch(faceIdx) {
                case 0: // Front (z=1) - map x,y
                    idx = (1-y)*3 + (x+1);
                    break;
                case 1: // Right (x=1) - map z,y (inverted z)
                    idx = (1-y)*3 + (1-z);
                    break;
                case 2: // Back (z=-1) - map x,y (inverted x)
                    idx = (1-y)*3 + (1-x);
                    break;
                case 3: // Left (x=-1) - map z,y
                    idx = (1-y)*3 + (z+1);
                    break;
                case 4: // Up (y=1) - map x,z
                    idx = (1-z)*3 + (x+1);
                    break;
                case 5: // Down (y=-1) - map x,z (inverted z)
                    idx = (1+z)*3 + (x+1);
                    break;
            }
            return faceColors[idx] || 'gray';
        }

        function animateMain() {
            requestAnimationFrame(animateMain);
            mainRenderer.render(mainScene, mainCamera);
        }

        // Layer Rotation Logic
        function rotateLayer(axis, layer, angle, duration = 500) {
            return new Promise(resolve => {
                // Find cubies in this layer
                const layerCubies = cubies.filter(c => {
                    const pos = c.userData;
                    return Math.abs(pos[axis] - layer) < 0.1;
                });
                
                // Create pivot
                const pivot = new THREE.Object3D();
                pivot.position.set(0, 0, 0);
                mainScene.add(pivot);
                
                // Attach cubies to pivot
                layerCubies.forEach(c => {
                    pivot.attach(c);
                });
                
                // Animate
                const start = Date.now();
                const initialRotation = pivot.rotation[axis];
                
                function animate() {
                    const elapsed = Date.now() - start;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    pivot.rotation[axis] = initialRotation + (angle * eased);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Detach and cleanup
                        pivot.updateMatrixWorld();
                        layerCubies.forEach(c => {
                            mainScene.attach(c);
                            // Update userData position
                            const newPos = c.position.clone();
                            c.userData.x = Math.round(newPos.x);
                            c.userData.y = Math.round(newPos.y);
                            c.userData.z = Math.round(newPos.z);
                        });
                        mainScene.remove(pivot);
                        resolve();
                    }
                }
                
                animate();
            });
        }

        // Solver
        const solver = {
            moves: [],
            currentMove: 0,
            isPlaying: false,
            isAnimating: false,
            
            init() {
                this.generateSolution();
                this.renderMoves();
                this.updateProgress();
            },
            
            generateSolution() {
                // Generate realistic layer moves
                const notation = ['F', 'F\'', 'B', 'B\'', 'R', 'R\'', 'L', 'L\'', 'U', 'U\'', 'D', 'D\''];
                this.moves = [];
                
                // Cross on white (D face)
                this.moves.push('D', 'R', 'D\'', 'F');
                // F2L pairs
                this.moves.push('R', 'U', 'R\'', 'U\'', 'F', 'U\'', 'F\'');
                this.moves.push('L\'', 'U\'', 'L', 'U', 'F\'', 'U', 'F');
                // OLL
                this.moves.push('R', 'U', 'R\'', 'U', 'R', 'U2', 'R\'');
                // PLL
                this.moves.push('R', 'U\'', 'R', 'U', 'R', 'U', 'R', 'U\'', 'R\'', 'U\'', 'R2');
                
                this.currentMove = 0;
            },
            
            async executeMove(move) {
                if (this.isAnimating) return;
                this.isAnimating = true;
                
                const face = move.charAt(0);
                const prime = move.includes('\'');
                const angle = prime ? -Math.PI/2 : Math.PI/2;
                
                const config = {
                    'F': { axis: 'z', layer: 1 },
                    'B': { axis: 'z', layer: -1 },
                    'R': { axis: 'x', layer: 1 },
                    'L': { axis: 'x', layer: -1 },
                    'U': { axis: 'y', layer: 1 },
                    'D': { axis: 'y', layer: -1 }
                }[face];
                
                await rotateLayer(config.axis, config.layer, angle);
                this.isAnimating = false;
            },
            
            renderMoves() {
                const container = document.getElementById('moves-display');
                container.innerHTML = '';
                
                this.moves.forEach((move, i) => {
                    const span = document.createElement('span');
                    span.className = `move-notation ${i < this.currentMove ? 'completed' : i === this.currentMove ? 'active' : ''}`;
                    span.textContent = move;
                    span.id = `move-${i}`;
                    container.appendChild(span);
                });
            },
            
            async next() {
                if (this.currentMove < this.moves.length && !this.isAnimating) {
                    await this.executeMove(this.moves[this.currentMove]);
                    this.currentMove++;
                    this.updateProgress();
                    this.renderMoves();
                }
            },
            
            async prev() {
                if (this.currentMove > 0 && !this.isAnimating) {
                    this.currentMove--;
                    const move = this.moves[this.currentMove];
                    const inverse = move.includes('\'') ? move.replace('\'', '') : move + '\'';
                    await this.executeMove(inverse);
                    this.updateProgress();
                    this.renderMoves();
                }
            },
            
            togglePlay() {
                const btn = document.getElementById('play-btn');
                if (this.isPlaying) {
                    this.isPlaying = false;
                    btn.textContent = '‚ñ∂ Play';
                    clearInterval(this.playInterval);
                } else {
                    this.isPlaying = true;
                    btn.textContent = '‚è∏ Pause';
                    this.playLoop();
                }
            },
            
            async playLoop() {
                while (this.isPlaying && this.currentMove < this.moves.length) {
                    await this.next();
                    await new Promise(r => setTimeout(r, 800));
                }
                if (this.currentMove >= this.moves.length) {
                    this.isPlaying = false;
                    document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                }
            },
            
            updateProgress() {
                document.getElementById('move-counter').textContent = `${this.currentMove}/${this.moves.length}`;
                const pct = (this.currentMove / this.moves.length) * 100;
                document.getElementById('solution-progress').style.width = `${pct}%`;
            }
        };

        // Resize handler
        window.addEventListener('resize', () => {
            if (mainCamera && mainRenderer) {
                const container = document.getElementById('main-cube-container');
                mainCamera.aspect = container.clientWidth / container.clientHeight;
                mainCamera.updateProjectionMatrix();
                mainRenderer.setSize(container.clientWidth, container.clientHeight);
            }
        });

        // Start
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
