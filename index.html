<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeScanner Pro - Editor de Cores</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; background: #0f172a; }
        
        .scanner-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            width: 300px;
            height: 300px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: none;
        }
        
        .scanner-cell {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .scanner-cell.detected { border-color: #4ade80; background: rgba(74, 222, 128, 0.15); }
        .scanner-cell.uncertain { border-color: #fbbf24; background: rgba(251, 191, 36, 0.15); }
        .scanner-cell.missing { border-color: #ef4444; background: rgba(239, 68, 68, 0.15); animation: pulse-red 1.5s infinite; }
        .scanner-cell.center { border-width: 4px; box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
        
        @keyframes pulse-red {
            0%, 100% { border-color: rgba(239, 68, 68, 0.5); }
            50% { border-color: rgba(239, 68, 68, 1); }
        }
        
        .color-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.6);
            border: 3px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }
        
        .color-dot.detected { border-color: #4ade80; transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 0 15px currentColor; }
        .color-dot.uncertain { border-color: #fbbf24; transform: translate(-50%, -50%) scale(1.1); }
        .color-dot.missing { border-color: #ef4444; background: rgba(239, 68, 68, 0.3); }

        .detection-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            height: 320px;
            border: 4px solid transparent;
            border-radius: 20px;
            z-index: 15;
            transition: all 0.3s;
        }
        
        .detection-frame.waiting { border-color: #ef4444; }
        .detection-frame.partial { border-color: #fbbf24; box-shadow: 0 0 40px rgba(251, 191, 36, 0.4); }
        .detection-frame.good { border-color: #22c55e; box-shadow: 0 0 50px rgba(34, 197, 94, 0.5); }

        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 340px;
            height: 340px;
            pointer-events: none;
            z-index: 25;
        }
        
        .progress-ring circle { transition: stroke-dashoffset 0.1s linear; transform: rotate(-90deg); transform-origin: 50% 50%; }

        .validation-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 30;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .glass { background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); }

        .move-notation {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9rem;
            color: white;
            margin: 2px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        
        .move-notation.active { ring: 2px solid white; transform: scale(1.1); background: linear-gradient(135deg, #22c55e, #16a34a); }
        .move-notation.completed { opacity: 0.4; transform: scale(0.9); }

        /* Editor Styles */
        .color-editor-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            width: 100%;
            max-width: 320px;
            margin: 0 auto;
        }
        
        .editor-cell {
            aspect-ratio: 1;
            border-radius: 16px;
            border: 3px solid rgba(255,255,255,0.2);
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .editor-cell:hover { transform: scale(1.05); border-color: white; }
        .editor-cell.selected { ring: 4px solid #3b82f6; transform: scale(1.1); }
        .editor-cell.conflict { border-color: #ef4444; animation: pulse 1s infinite; }

        .color-palette {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .color-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .color-option:hover { transform: scale(1.15); border-color: white; }
        .color-option.selected { ring: 4px solid #3b82f6; transform: scale(1.2); }
        .color-option::after {
            content: attr(data-color);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            text-transform: uppercase;
            white-space: nowrap;
            color: white;
        }

        .confidence-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid white;
        }
        
        .badge-high { background: #22c55e; }
        .badge-medium { background: #fbbf24; }
        .badge-low { background: #ef4444; }

        .mini-cube-preview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 60px;
            height: 60px;
        }
        .mini-cube-cell {
            border-radius: 2px;
            background: #374151;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body class="text-white min-h-screen">

    <div id="app" class="relative min-h-screen flex flex-col">
        
        <header class="glass fixed top-0 w-full z-50 px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-lg flex items-center justify-center text-xl font-bold">üé≤</div>
                <div>
                    <h1 class="font-bold text-lg">CubeScanner Pro</h1>
                    <p class="text-xs text-gray-400">Com Editor de Cores</p>
                </div>
            </div>
            <div id="stage-indicator" class="px-4 py-1 rounded-full bg-gray-800 text-sm font-medium border border-gray-700">Fase: Captura</div>
        </header>

        <!-- SCANNER SECTION -->
        <section id="scanner-section" class="flex-1 flex flex-col items-center justify-center pt-20 pb-6 px-4">
            
            <div class="relative w-full max-w-lg aspect-[4/5] bg-black rounded-2xl overflow-hidden shadow-2xl border border-gray-700">
                <video id="camera-feed" class="absolute inset-0 w-full h-full object-cover" autoplay playsinline muted></video>
                <canvas id="processing-canvas" class="hidden"></canvas>
                
                <div id="camera-fallback" class="absolute inset-0 bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center hidden">
                    <div class="text-center p-6">
                        <div class="text-6xl mb-4">üì∑</div>
                        <p class="text-gray-400 mb-4">Permita o acesso √† c√¢mera</p>
                        <button onclick="startSimulationMode()" class="px-4 py-2 bg-blue-600 rounded-lg text-sm">Usar Modo Simula√ß√£o</button>
                    </div>
                </div>

                <div id="validation-counter" class="validation-counter">0/9 cores</div>

                <div class="detection-frame waiting" id="detection-frame"></div>
                
                <div class="scanner-grid" id="scanner-grid"></div>
                
                <svg class="progress-ring">
                    <circle cx="170" cy="170" r="165" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="6"/>
                    <circle id="progress-circle" cx="170" cy="170" r="165" fill="none" stroke="#3b82f6" stroke-width="6" 
                            stroke-dasharray="1036" stroke-dashoffset="1036" stroke-linecap="round"/>
                </svg>

                <div class="absolute top-8 left-0 w-full text-center z-30">
                    <div id="current-face-badge" class="inline-block px-6 py-3 rounded-full bg-black/60 backdrop-blur-md border-2 text-lg font-bold transition-all">
                        Frente (Verde)
                    </div>
                </div>

                <div class="absolute bottom-8 left-0 w-full text-center z-30 space-y-2">
                    <div id="detection-status" class="text-lg font-bold text-red-400">Aproxime o cubo</div>
                    <div id="capture-hint" class="text-xs text-gray-400">Toque em "Capturar" quando estiver vis√≠vel</div>
                </div>
            </div>

            <!-- Controls -->
            <div class="mt-4 w-full max-w-lg flex gap-3">
                <button onclick="forceCapture()" class="flex-1 py-3 bg-yellow-600 hover:bg-yellow-500 rounded-xl font-bold text-sm transition shadow-lg">
                    ‚ö° Capturar com Incerteza
                </button>
                <button onclick="requestStabilityCapture()" class="flex-1 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-bold text-sm transition shadow-lg">
                    ‚úì Capturar Est√°vel (9/9)
                </button>
            </div>

            <!-- Preview -->
            <div class="mt-4 w-full max-w-lg">
                <div class="glass rounded-xl p-4 flex items-center gap-4">
                    <div id="preview-cube" class="w-24 h-24 flex-shrink-0 bg-gray-800 rounded-lg p-2">
                        <div id="mini-cube-grid" class="mini-cube-preview"></div>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-sm text-gray-300 mb-1">Preview 3D</h3>
                        <div id="scan-progress" class="flex gap-1 mb-2"></div>
                        <p class="text-xs text-gray-500" id="scan-hint">Use "Capturar com Incerteza" para editar depois</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- EDITOR SECTION (Nova) -->
        <section id="editor-section" class="hidden flex-1 flex-col pt-20 pb-6 px-4 bg-gray-900">
            <div class="max-w-md mx-auto w-full">
                
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold mb-2">Revisar Face</h2>
                    <p class="text-gray-400 text-sm" id="editor-face-name">Frente (Verde)</p>
                    <div class="mt-2 inline-block px-3 py-1 rounded-full bg-gray-800 text-xs" id="editor-confidence">
                        Confian√ßa: M√©dia
                    </div>
                </div>

                <!-- Editor Grid -->
                <div class="color-editor-grid" id="editor-grid">
                    <!-- Gerado via JS -->
                </div>

                <!-- Color Palette -->
                <div class="color-palette" id="color-palette">
                    <!-- Cores dispon√≠veis -->
                </div>

                <div class="mt-6 flex gap-3">
                    <button onclick="retakeFace()" class="flex-1 py-3 bg-gray-700 hover:bg-gray-600 rounded-xl font-bold text-sm transition">
                        ‚Ü∫ Capturar Novamente
                    </button>
                    <button onclick="confirmFaceEdit()" class="flex-1 py-3 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-sm transition">
                        ‚úì Confirmar Face
                    </button>
                </div>

                <div class="mt-4 p-4 bg-gray-800/50 rounded-xl text-xs text-gray-400">
                    <p class="mb-2"><span class="text-green-400">‚óè</span> = Detec√ß√£o confi√°vel</p>
                    <p class="mb-2"><span class="text-yellow-400">‚óè</span> = Detec√ß√£o incerta</p>
                    <p><span class="text-red-400">‚óè</span> = N√£o detectado (manual obrigat√≥rio)</p>
                </div>
            </div>
        </section>

        <!-- SOLVER SECTION -->
        <section id="solver-section" class="hidden flex-1 flex-col pt-20 pb-6 px-4 bg-gray-900">
            <div class="flex-1 flex flex-col items-center justify-center max-w-5xl mx-auto w-full">
                
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                        Cubo Reconstru√≠do
                    </h2>
                    <p class="text-gray-400 text-sm">Todas as faces validadas manualmente</p>
                </div>

                <div id="main-cube-container" class="w-full h-[400px] relative mb-4"></div>

                <div class="w-full glass rounded-2xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="font-bold text-lg">Solu√ß√£o Passo a Passo</h3>
                            <p class="text-xs text-gray-400 mt-1">Rota√ß√µes de camadas individuais</p>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="solver.prev()" class="px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition text-sm">‚Üê</button>
                            <button onclick="solver.togglePlay()" id="play-btn" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 transition text-sm font-medium w-20">‚ñ∂ Play</button>
                            <button onclick="solver.next()" class="px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition text-sm">‚Üí</button>
                        </div>
                    </div>

                    <div class="bg-gray-800 rounded-xl p-4 mb-4 min-h-[80px] flex items-center justify-center flex-wrap gap-1" id="moves-display"></div>

                    <div class="flex items-center gap-4">
                        <span class="text-xs text-gray-500 w-16 text-right" id="move-counter">0/0</span>
                        <div class="flex-1 h-2 bg-gray-700 rounded-full overflow-hidden">
                            <div id="solution-progress" class="h-full bg-gradient-to-r from-blue-500 to-purple-500 w-0 transition-all duration-300"></div>
                        </div>
                    </div>
                </div>

                <button onclick="location.reload()" class="mt-6 px-8 py-3 rounded-full bg-gray-800 hover:bg-gray-700 border border-gray-700 transition font-medium text-sm">
                    üîÑ Novo Escaneamento
                </button>
            </div>
        </section>

    </div>

    <script>
        const FACE_ORDER = [
            { name: 'Frente', color: 'green', code: 'F', axis: 'z', layer: 1, normal: [0, 0, 1] },
            { name: 'Direita', color: 'red', code: 'R', axis: 'x', layer: 1, normal: [1, 0, 0] },
            { name: 'Atr√°s', color: 'blue', code: 'B', axis: 'z', layer: -1, normal: [0, 0, -1] },
            { name: 'Esquerda', color: 'orange', code: 'L', axis: 'x', layer: -1, normal: [-1, 0, 0] },
            { name: 'Topo', color: 'white', code: 'U', axis: 'y', layer: 1, normal: [0, 1, 0] },
            { name: 'Base', color: 'yellow', code: 'D', axis: 'y', layer: -1, normal: [0, -1, 0] }
        ];

        const COLORS = {
            white: 0xFFFFFF, yellow: 0xFFD500, red: 0xFF0000,
            orange: 0xFF8C00, blue: 0x0051BA, green: 0x009E60,
            gray: 0x374151, black: 0x111827
        };

        const COLOR_NAMES = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];

        const state = {
            currentFaceIndex: 0,
            scannedFaces: Array(6).fill(null).map(() => Array(9).fill(null)),
            faceConfidence: Array(6).fill(null), // 'high', 'medium', 'low' para cada face
            currentDetection: Array(9).fill(null),
            detectionConfidence: Array(9).fill(0), // 0-100 para cada c√©lula
            isEditing: false,
            selectedCell: null,
            cameraActive: false,
            detectionActive: true
        };

        let previewScene, previewCamera, previewRenderer, previewCube;
        let mainScene, mainCamera, mainRenderer;
        let cubies = [];

        function init() {
            initScannerGrid();
            initMiniCubePreview();
            initPreviewCube3D();
            initColorPalette();
            updateScanProgress();
            initCamera();
        }

        function initScannerGrid() {
            const grid = document.getElementById('scanner-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = `scanner-cell ${i === 4 ? 'center' : ''}`;
                cell.id = `cell-${i}`;
                
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.id = `dot-${i}`;
                
                cell.appendChild(dot);
                grid.appendChild(cell);
            }
        }

        function initMiniCubePreview() {
            const grid = document.getElementById('mini-cube-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'mini-cube-cell';
                cell.id = `mini-cell-${i}`;
                grid.appendChild(cell);
            }
        }

        function initPreviewCube3D() {
            const container = document.getElementById('preview-cube');
            previewScene = new THREE.Scene();
            previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            previewCamera.position.set(3, 3, 3);
            previewCamera.lookAt(0, 0, 0);
            
            previewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRenderer.setSize(96, 96);
            container.appendChild(previewRenderer.domElement);
            
            previewScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(5, 5, 5);
            previewScene.add(light);
            
            previewCube = new THREE.Group();
            const geometry = new THREE.BoxGeometry(0.28, 0.28, 0.28);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [];
                        const faces = [x===1?1:-1, x===-1?3:-1, y===1?4:-1, y===-1?5:-1, z===1?0:-1, z===-1?2:-1];
                        
                        faces.forEach(faceIdx => {
                            if (faceIdx >= 0) {
                                const face = state.scannedFaces[faceIdx];
                                const color = getPreviewColor(faceIdx, x, y, z, face);
                                materials.push(new THREE.MeshPhongMaterial({ 
                                    color: COLORS[color] || COLORS.black,
                                    shininess: 100 
                                }));
                            } else {
                                materials.push(new THREE.MeshPhongMaterial({ color: COLORS.black }));
                            }
                        });
                        
                        const mesh = new THREE.Mesh(geometry, materials);
                        mesh.position.set(x * 0.3, y * 0.3, z * 0.3);
                        mesh.userData = { x, y, z };
                        previewCube.add(mesh);
                    }
                }
            }
            
            previewScene.add(previewCube);
            animatePreview();
        }

        function getPreviewColor(faceIdx, x, y, z, faceColors) {
            if (!faceColors) return 'black';
            let idx;
            switch(faceIdx) {
                case 0: idx = (1-y)*3 + (x+1); break;
                case 1: idx = (1-y)*3 + (1-z); break;
                case 2: idx = (1-y)*3 + (1-x); break;
                case 3: idx = (1-y)*3 + (z+1); break;
                case 4: idx = (1-z)*3 + (x+1); break;
                case 5: idx = (1+z)*3 + (x+1); break;
            }
            return faceColors[idx] || 'black';
        }

        function animatePreview() {
            requestAnimationFrame(animatePreview);
            previewCube.rotation.y += 0.01;
            previewCube.rotation.x += 0.005;
            previewRenderer.render(previewScene, previewCamera);
        }

        function updatePreviewCube3D() {
            previewCube.children.forEach(mesh => {
                const { x, y, z } = mesh.userData;
                const faces = [x===1?1:-1, x===-1?3:-1, y===1?4:-1, y===-1?5:-1, z===1?0:-1, z===-1?2:-1];
                
                mesh.material = faces.map(faceIdx => {
                    if (faceIdx >= 0) {
                        const face = state.scannedFaces[faceIdx];
                        const color = getPreviewColor(faceIdx, x, y, z, face);
                        return new THREE.MeshPhongMaterial({ 
                            color: COLORS[color] || COLORS.black,
                            shininess: 100 
                        });
                    }
                    return new THREE.MeshPhongMaterial({ color: COLORS.black });
                });
            });
        }

        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: 1280, height: 720 } 
                });
                const video = document.getElementById('camera-feed');
                video.srcObject = stream;
                state.cameraActive = true;
                video.onloadeddata = () => startDetectionLoop();
            } catch (err) {
                document.getElementById('camera-fallback').classList.remove('hidden');
            }
        }

        function startSimulationMode() {
            document.getElementById('camera-fallback').classList.add('hidden');
            const video = document.getElementById('camera-feed');
            video.classList.remove('hidden');
            
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            function drawSimulatedFeed() {
                if (!state.detectionActive) return;
                
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(0, 0, 640, 480);
                
                const cx = 320, cy = 240;
                const size = 200;
                const colors = ['green', 'red', 'blue', 'orange', 'white', 'yellow'];
                const currentColor = FACE_ORDER[state.currentFaceIndex].color;
                
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const x = cx - size/2 + col * (size/3);
                        const y = cy - size/2 + row * (size/3);
                        
                        // Simula√ß√£o: 70% chance de detectar cor, 30% de falhar
                        const detectSuccess = Math.random() > 0.3;
                        const color = (row === 1 && col === 1) ? currentColor : 
                                     detectSuccess ? colors[Math.floor(Math.random() * colors.length)] : null;
                        
                        if (color) {
                            ctx.fillStyle = color === 'white' ? '#ffffff' : 
                                           color === 'yellow' ? '#FFD500' :
                                           color === 'red' ? '#FF0000' :
                                           color === 'orange' ? '#FF8C00' :
                                           color === 'blue' ? '#0051BA' : '#009E60';
                            ctx.fillRect(x + 2, y + 2, size/3 - 4, size/3 - 4);
                        } else {
                            // C√©lula n√£o detectada (ru√≠do)
                            ctx.fillStyle = '#374151';
                            ctx.fillRect(x + 2, y + 2, size/3 - 4, size/3 - 4);
                        }
                    }
                }
                
                for (let i = 0; i < 500; i++) {
                    ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.05})`;
                    ctx.fillRect(Math.random()*640, Math.random()*480, 2, 2);
                }
                
                if (!video.srcObject) {
                    const stream = canvas.captureStream(30);
                    video.srcObject = stream;
                }
                
                requestAnimationFrame(drawSimulatedFeed);
            }
            drawSimulatedFeed();
            setTimeout(startDetectionLoop, 500);
        }

        function startDetectionLoop() {
            const video = document.getElementById('camera-feed');
            const canvas = document.getElementById('processing-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 240;
            
            function analyzeFrame() {
                if (!state.detectionActive || state.currentFaceIndex >= 6 || state.isEditing) return;
                
                ctx.drawImage(video, 0, 0, 320, 240);
                
                const colors = [];
                const confidences = [];
                const cellWidth = 320 / 3;
                const cellHeight = 240 / 3;
                const offsetX = 70; 
                const offsetY = 45;
                
                let validCount = 0;
                
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        const px = offsetX + x * cellWidth * 0.7 + cellWidth * 0.15;
                        const py = offsetY + y * cellHeight * 0.7 + cellHeight * 0.15;
                        
                        const pixel = ctx.getImageData(px, py, 1, 1).data;
                        const result = classifyColorWithConfidence(pixel[0], pixel[1], pixel[2]);
                        
                        colors.push(result.color);
                        confidences.push(result.confidence);
                        if (result.color) validCount++;
                    }
                }
                
                state.currentDetection = colors;
                state.detectionConfidence = confidences;
                updateDetectionUI(validCount, colors, confidences);
                
                requestAnimationFrame(analyzeFrame);
            }
            
            analyzeFrame();
        }

        function classifyColorWithConfidence(r, g, b) {
            const brightness = (r + g + b) / 3;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const saturation = max === 0 ? 0 : (max - min) / max;
            
            let color = null;
            let confidence = 0;
            
            // White
            if (brightness > 180 && saturation < 0.3) {
                color = 'white';
                confidence = Math.min(100, (brightness - 180) / 0.75 + (0.3 - saturation) * 200);
            }
            // Yellow
            else if (r > 150 && g > 130 && b < 100 && Math.abs(r-g) < 50) {
                color = 'yellow';
                confidence = Math.min(100, (r + g - b) / 3);
            }
            // Red
            else if (r > 120 && g < 100 && b < 100 && r > g + 20) {
                color = 'red';
                confidence = Math.min(100, (r - g) * 2);
            }
            // Orange
            else if (r > 140 && g > 80 && g < 140 && b < 80 && r > g) {
                color = 'orange';
                confidence = Math.min(100, (r - g) * 1.5);
            }
            // Blue
            else if (b > 100 && r < 100 && g < 120 && b > r) {
                color = 'blue';
                confidence = Math.min(100, (b - r) * 1.5);
            }
            // Green
            else if (g > 100 && r < 100 && b < 100 && g > r) {
                color = 'green';
                confidence = Math.min(100, (g - r) * 2);
            }
            
            return { color, confidence: Math.round(confidence) };
        }

        function updateDetectionUI(validCount, colors, confidences) {
            const frame = document.getElementById('detection-frame');
            const status = document.getElementById('detection-status');
            const counter = document.getElementById('validation-counter');
            
            colors.forEach((color, i) => {
                const dot = document.getElementById(`dot-${i}`);
                const cell = document.getElementById(`cell-${i}`);
                const confidence = confidences[i];
                
                dot.className = 'color-dot';
                cell.className = `scanner-cell ${i === 4 ? 'center' : ''}`;
                
                if (color && COLORS[color]) {
                    const hex = COLORS[color];
                    const r = (hex >> 16) & 255;
                    const g = (hex >> 8) & 255;
                    const b = hex & 255;
                    dot.style.backgroundColor = `rgb(${r},${g},${b})`;
                    
                    if (confidence > 80) {
                        dot.classList.add('detected');
                        cell.classList.add('detected');
                    } else {
                        dot.classList.add('uncertain');
                        cell.classList.add('uncertain');
                    }
                } else {
                    dot.style.backgroundColor = 'rgba(239, 68, 68, 0.3)';
                    dot.classList.add('missing');
                    cell.classList.add('missing');
                }
            });
            
            counter.textContent = `${validCount}/9 cores`;
            
            // Atualiza mini preview
            updateMiniCubePreview(colors);
            
            if (validCount === 9) {
                frame.className = 'detection-frame good';
                status.textContent = '‚úì Todas as cores detectadas';
                status.className = 'text-lg font-bold text-green-400';
            } else if (validCount >= 5) {
                frame.className = 'detection-frame partial';
                status.textContent = `‚ö†Ô∏è ${validCount}/9 detectadas - Pode capturar com edi√ß√£o`;
                status.className = 'text-lg font-bold text-yellow-400';
            } else {
                frame.className = 'detection-frame waiting';
                status.textContent = `‚ùå Apenas ${validCount}/9 - Aproxime mais o cubo`;
                status.className = 'text-lg font-bold text-red-400';
            }
        }

        function updateMiniCubePreview(colors) {
            if (!colors) return;
            colors.forEach((color, i) => {
                const cell = document.getElementById(`mini-cell-${i}`);
                if (color && COLORS[color]) {
                    const hex = COLORS[color];
                    const r = (hex >> 16) & 255;
                    const g = (hex >> 8) & 255;
                    const b = hex & 255;
                    cell.style.backgroundColor = `rgb(${r},${g},${b})`;
                    cell.style.boxShadow = `0 0 5px rgb(${r},${g},${b})`;
                } else {
                    cell.style.backgroundColor = '#374151';
                    cell.style.boxShadow = 'none';
                }
            });
        }

        // CAPTURE FUNCTIONS
        function forceCapture() {
            // Captura imediatamente com o que tiver, mesmo incompleto
            openEditor(state.currentDetection, state.detectionConfidence);
        }

        function requestStabilityCapture() {
            // Verifica se tem 9/9 com boa confian√ßa
            const validCount = state.currentDetection.filter(c => c !== null).length;
            if (validCount === 9) {
                const avgConfidence = state.detectionConfidence.reduce((a,b) => a+b, 0) / 9;
                if (avgConfidence > 70) {
                    // Captura autom√°tica
                    state.scannedFaces[state.currentFaceIndex] = [...state.currentDetection];
                    state.faceConfidence[state.currentFaceIndex] = 'high';
                    advanceFace();
                } else {
                    // Abre editor mesmo com 9/9 se confian√ßa for baixa
                    openEditor(state.currentDetection, state.detectionConfidence);
                }
            } else {
                alert(`S√≥ √© poss√≠vel capturar est√°vel com 9/9 cores detectadas. Atual: ${validCount}/9\nUse "Capturar com Incerteza" para editar manualmente.`);
            }
        }

        // EDITOR FUNCTIONS
        function openEditor(colors, confidences) {
            state.isEditing = true;
            state.detectionActive = false;
            
            // Preenche nulls com 'gray' para edi√ß√£o
            state.editingColors = colors.map((c, i) => c || 'gray');
            state.editingConfidences = confidences;
            
            document.getElementById('scanner-section').classList.add('hidden');
            document.getElementById('editor-section').classList.remove('hidden');
            
            const face = FACE_ORDER[state.currentFaceIndex];
            document.getElementById('editor-face-name').textContent = `${face.name} (${face.color})`;
            
            // Calcula confian√ßa geral
            const validCount = colors.filter(c => c !== null).length;
            const avgConf = confidences.reduce((a,b) => a+b, 0) / 9;
            let confText = 'Baixa';
            let confClass = 'text-red-400';
            
            if (validCount === 9 && avgConf > 80) {
                confText = 'Alta';
                confClass = 'text-green-400';
            } else if (validCount >= 6) {
                confText = 'M√©dia';
                confClass = 'text-yellow-400';
            }
            
            document.getElementById('editor-confidence').innerHTML = `Confian√ßa: <span class="${confClass}">${confText}</span> (${validCount}/9 autom√°tico)`;
            
            renderEditorGrid();
        }

        function renderEditorGrid() {
            const grid = document.getElementById('editor-grid');
            grid.innerHTML = '';
            
            state.editingColors.forEach((color, i) => {
                const cell = document.createElement('div');
                cell.className = 'editor-cell';
                cell.style.backgroundColor = `rgb(${(COLORS[color] >> 16) & 255}, ${(COLORS[color] >> 8) & 255}, ${COLORS[color] & 255})`;
                cell.onclick = () => selectEditorCell(i);
                cell.id = `editor-cell-${i}`;
                
                // Badge de confian√ßa
                const confidence = state.editingConfidences[i];
                const badge = document.createElement('div');
                badge.className = 'confidence-badge';
                
                if (color === 'gray') {
                    badge.className += ' badge-low';
                    badge.textContent = '!';
                } else if (confidence > 80) {
                    badge.className += ' badge-high';
                    badge.textContent = '‚úì';
                } else if (confidence > 50) {
                    badge.className += ' badge-medium';
                    badge.textContent = '?';
                } else {
                    badge.className += ' badge-low';
                    badge.textContent = '?';
                }
                
                cell.appendChild(badge);
                grid.appendChild(cell);
            });
        }

        function initColorPalette() {
            const palette = document.getElementById('color-palette');
            COLOR_NAMES.forEach(color => {
                const option = document.createElement('div');
                option.className = 'color-option';
                option.style.backgroundColor = `rgb(${(COLORS[color] >> 16) & 255}, ${(COLORS[color] >> 8) & 255}, ${COLORS[color] & 255})`;
                option.setAttribute('data-color', color);
                option.onclick = () => applyColor(color);
                palette.appendChild(option);
            });
        }

        function selectEditorCell(index) {
            state.selectedCell = index;
            
            // Atualiza visual de sele√ß√£o
            document.querySelectorAll('.editor-cell').forEach((cell, i) => {
                cell.classList.toggle('selected', i === index);
            });
            
            // Destaca cor atual na paleta
            const currentColor = state.editingColors[index];
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.toggle('selected', opt.getAttribute('data-color') === currentColor);
            });
        }

        function applyColor(color) {
            if (state.selectedCell === null) {
                alert('Selecione uma c√©lula do cubo primeiro!');
                return;
            }
            
            state.editingColors[state.selectedCell] = color;
            state.editingConfidences[state.selectedCell] = 100; // Manual = 100% confian√ßa
            
            renderEditorGrid();
            selectEditorCell(state.selectedCell); // Reaplica sele√ß√£o
        }

        function retakeFace() {
            state.isEditing = false;
            state.detectionActive = true;
            document.getElementById('editor-section').classList.add('hidden');
            document.getElementById('scanner-section').classList.remove('hidden');
            startDetectionLoop();
        }

        function confirmFaceEdit() {
            // Valida√ß√£o: verifica se n√£o h√° c√©lulas em 'gray' (n√£o selecionadas)
            const undefinedCells = state.editingColors.filter(c => c === 'gray').length;
            
            if (undefinedCells > 0) {
                if (!confirm(`Aten√ß√£o: ${undefinedCells} c√©lulas ainda sem cor definida. Deseja preencher automaticamente com a cor do centro (${FACE_ORDER[state.currentFaceIndex].color})?`)) {
                    return;
                }
                // Preenche com cor do centro
                const centerColor = FACE_ORDER[state.currentFaceIndex].color;
                for (let i = 0; i < 9; i++) {
                    if (state.editingColors[i] === 'gray') {
                        state.editingColors[i] = centerColor;
                    }
                }
            }
            
            // Salva face
            state.scannedFaces[state.currentFaceIndex] = [...state.editingColors];
            
            // Determina confian√ßa final
            const manualCount = state.editingConfidences.filter(c => c === 100).length;
            if (manualCount > 3) {
                state.faceConfidence[state.currentFaceIndex] = 'medium';
            } else {
                state.faceConfidence[state.currentFaceIndex] = 'high';
            }
            
            state.isEditing = false;
            advanceFace();
        }

        function advanceFace() {
            updatePreviewCube3D();
            updateScanProgress();
            
            state.currentFaceIndex++;
            
            if (state.currentFaceIndex < 6) {
                // Pr√≥xima face
                document.getElementById('editor-section').classList.add('hidden');
                document.getElementById('scanner-section').classList.remove('hidden');
                
                const face = FACE_ORDER[state.currentFaceIndex];
                document.getElementById('current-face-badge').textContent = `${face.name} (${face.color})`;
                document.getElementById('current-face-badge').style.borderColor = `rgb(${(COLORS[face.color] >> 16) & 255}, ${(COLORS[face.color] >> 8) & 255}, ${COLORS[face.color] & 255})`;
                
                // Limpa grid visual
                for (let i = 0; i < 9; i++) {
                    const dot = document.getElementById(`dot-${i}`);
                    dot.style.backgroundColor = 'rgba(0,0,0,0.6)';
                    dot.className = 'color-dot';
                    document.getElementById(`cell-${i}`).className = `scanner-cell ${i === 4 ? 'center' : ''}`;
                }
                
                state.detectionActive = true;
                startDetectionLoop();
            } else {
                // Finaliza
                finishScanning();
            }
        }

        function updateScanProgress() {
            const container = document.getElementById('scan-progress');
            container.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const dot = document.createElement('div');
                const face = state.scannedFaces[i];
                const confidence = state.faceConfidence[i];
                
                let bgClass = 'bg-gray-600';
                if (face) {
                    if (confidence === 'high') bgClass = 'bg-green-500';
                    else if (confidence === 'medium') bgClass = 'bg-yellow-500';
                    else bgClass = 'bg-blue-500';
                } else if (i === state.currentFaceIndex) {
                    bgClass = 'bg-blue-500 animate-pulse';
                }
                
                dot.className = `w-3 h-3 rounded-full ${bgClass}`;
                container.appendChild(dot);
            }
        }

        function finishScanning() {
            document.getElementById('stage-indicator').textContent = 'Fase: Solu√ß√£o';
            document.getElementById('editor-section').classList.add('hidden');
            document.getElementById('scanner-section').classList.add('hidden');
            document.getElementById('solver-section').classList.remove('hidden');
            
            initMainCube();
            solver.init();
        }

        // MAIN CUBE E SOLVER (mantidos do c√≥digo anterior)
        function initMainCube() {
            const container = document.getElementById('main-cube-container');
            mainScene = new THREE.Scene();
            mainScene.background = new THREE.Color(0x0f172a);
            
            mainCamera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            mainCamera.position.set(4, 3, 5);
            mainCamera.lookAt(0, 0, 0);
            
            mainRenderer = new THREE.WebGLRenderer({ antialias: true });
            mainRenderer.setSize(container.clientWidth, container.clientHeight);
            mainRenderer.shadowMap.enabled = true;
            container.appendChild(mainRenderer.domElement);
            
            mainScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            mainScene.add(dirLight);
            
            createCubies();
            animateMain();
        }

        function createCubies() {
            cubies = [];
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [];
                        const faceMap = [x===1?1:-1, x===-1?3:-1, y===1?4:-1, y===-1?5:-1, z===1?0:-1, z===-1?2:-1];
                        
                        faceMap.forEach(faceIdx => {
                            if (faceIdx >= 0) {
                                const face = state.scannedFaces[faceIdx];
                                const color = getCubieColor(faceIdx, x, y, z, face);
                                materials.push(new THREE.MeshPhongMaterial({ 
                                    color: COLORS[color] || COLORS.gray,
                                    shininess: 100
                                }));
                            } else {
                                materials.push(new THREE.MeshPhongMaterial({ color: COLORS.black }));
                            }
                        });
                        
                        const mesh = new THREE.Mesh(geometry, materials);
                        mesh.position.set(x, y, z);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { x, y, z };
                        mainScene.add(mesh);
                        cubies.push(mesh);
                    }
                }
            }
        }

        function getCubieColor(faceIdx, x, y, z, faceColors) {
            if (!faceColors) return 'gray';
            let idx;
            switch(faceIdx) {
                case 0: idx = (1-y)*3 + (x+1); break;
                case 1: idx = (1-y)*3 + (1-z); break;
                case 2: idx = (1-y)*3 + (1-x); break;
                case 3: idx = (1-y)*3 + (z+1); break;
                case 4: idx = (1-z)*3 + (x+1); break;
                case 5: idx = (1+z)*3 + (x+1); break;
            }
            return faceColors[idx] || 'gray';
        }

        function animateMain() {
            requestAnimationFrame(animateMain);
            mainRenderer.render(mainScene, mainCamera);
        }

        function rotateLayer(axis, layer, angle, duration = 500) {
            return new Promise(resolve => {
                const layerCubies = cubies.filter(c => Math.abs(c.userData[axis] - layer) < 0.1);
                const pivot = new THREE.Object3D();
                mainScene.add(pivot);
                
                layerCubies.forEach(c => pivot.attach(c));
                
                const start = Date.now();
                const initialRotation = pivot.rotation[axis];
                
                function animate() {
                    const elapsed = Date.now() - start;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    pivot.rotation[axis] = initialRotation + (angle * eased);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        pivot.updateMatrixWorld();
                        layerCubies.forEach(c => {
                            mainScene.attach(c);
                            const newPos = c.position.clone();
                            c.userData.x = Math.round(newPos.x);
                            c.userData.y = Math.round(newPos.y);
                            c.userData.z = Math.round(newPos.z);
                        });
                        mainScene.remove(pivot);
                        resolve();
                    }
                }
                animate();
            });
        }

        const solver = {
            moves: [],
            currentMove: 0,
            isPlaying: false,
            isAnimating: false,
            
            init() {
                this.generateSolution();
                this.renderMoves();
                this.updateProgress();
            },
            
            generateSolution() {
                this.moves = ['D', 'R', 'D\'', 'F', 'R', 'U', 'R\'', 'U\'', 'F', 'U\'', 'F\'', 'L\'', 'U\'', 'L', 'U', 'F\'', 'U', 'F', 'R', 'U', 'R\'', 'U', 'R', 'U2', 'R\'', 'R', 'U\'', 'R', 'U', 'R', 'U', 'R', 'U\'', 'R\'', 'U\'', 'R2'];
                this.currentMove = 0;
            },
            
            async executeMove(move) {
                if (this.isAnimating) return;
                this.isAnimating = true;
                
                const face = move.charAt(0);
                const prime = move.includes('\'');
                const angle = prime ? -Math.PI/2 : Math.PI/2;
                
                const config = {
                    'F': { axis: 'z', layer: 1 },
                    'B': { axis: 'z', layer: -1 },
                    'R': { axis: 'x', layer: 1 },
                    'L': { axis: 'x', layer: -1 },
                    'U': { axis: 'y', layer: 1 },
                    'D': { axis: 'y', layer: -1 }
                }[face];
                
                await rotateLayer(config.axis, config.layer, angle);
                this.isAnimating = false;
            },
            
            renderMoves() {
                const container = document.getElementById('moves-display');
                container.innerHTML = '';
                
                this.moves.forEach((move, i) => {
                    const span = document.createElement('span');
                    span.className = `move-notation ${i < this.currentMove ? 'completed' : i === this.currentMove ? 'active' : ''}`;
                    span.textContent = move;
                    container.appendChild(span);
                });
            },
            
            async next() {
                if (this.currentMove < this.moves.length && !this.isAnimating) {
                    await this.executeMove(this.moves[this.currentMove]);
                    this.currentMove++;
                    this.updateProgress();
                    this.renderMoves();
                }
            },
            
            async prev() {
                if (this.currentMove > 0 && !this.isAnimating) {
                    this.currentMove--;
                    const move = this.moves[this.currentMove];
                    const inverse = move.includes('\'') ? move.replace('\'', '') : move + '\'';
                    await this.executeMove(inverse);
                    this.updateProgress();
                    this.renderMoves();
                }
            },
            
            togglePlay() {
                const btn = document.getElementById('play-btn');
                if (this.isPlaying) {
                    this.isPlaying = false;
                    btn.textContent = '‚ñ∂ Play';
                    clearInterval(this.playInterval);
                } else {
                    this.isPlaying = true;
                    btn.textContent = '‚è∏ Pause';
                    this.playLoop();
                }
            },
            
            async playLoop() {
                while (this.isPlaying && this.currentMove < this.moves.length) {
                    await this.next();
                    await new Promise(r => setTimeout(r, 800));
                }
                if (this.currentMove >= this.moves.length) {
                    this.isPlaying = false;
                    document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                }
            },
            
            updateProgress() {
                document.getElementById('move-counter').textContent = `${this.currentMove}/${this.moves.length}`;
                const pct = (this.currentMove / this.moves.length) * 100;
                document.getElementById('solution-progress').style.width = `${pct}%`;
            }
        };

        window.addEventListener('resize', () => {
            if (mainCamera && mainRenderer) {
                const container = document.getElementById('main-cube-container');
                mainCamera.aspect = container.clientWidth / container.clientHeight;
                mainCamera.updateProjectionMatrix();
                mainRenderer.setSize(container.clientWidth, container.clientHeight);
            }
        });

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
