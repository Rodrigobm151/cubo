<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cubo Mágico - Solver Kociemba</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            overflow: hidden;
            background: #111827;
        }
        
        .cube-container {
            width: 100vw;
            height: 55vh;
            position: relative;
            cursor: grab;
        }
        
        .cube-container:active {
            cursor: grabbing;
        }
        
        .cube-container.dragging {
            cursor: grabbing;
        }
        
        .color-btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            border: 3px solid transparent;
        }
        
        .color-btn:active {
            transform: scale(0.9);
        }
        
        .color-btn.selected {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3), 0 8px 25px rgba(0,0,0,0.5);
        }
        
        .face-btn {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(75, 85, 99, 0.5);
            transition: all 0.3s ease;
            font-weight: 800;
            letter-spacing: 0.05em;
        }
        
        .face-btn.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.8);
            color: #60A5FA;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        .move-text {
            font-variant-numeric: tabular-nums;
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.2); }
            50% { box-shadow: 0 0 40px rgba(59, 130, 246, 0.5); }
        }
        
        .solving {
            animation: pulse-glow 2s infinite;
        }
        
        .moves-list::-webkit-scrollbar {
            height: 6px;
        }
        .moves-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
        }
        .moves-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        
        .loading-overlay {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(10px);
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #3B82F6 0%, #60A5FA 100%);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .success-toast {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translate(-50%, 100%); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        .gesture-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: rgba(255,255,255,0.7);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .cube-container:hover .gesture-hint {
            opacity: 1;
        }

        /* Indicador de cor da face */
        .face-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }
    </style>
<base target="_blank">
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay fixed inset-0 z-50 flex flex-col items-center justify-center hidden">
        <div class="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <h2 class="text-xl font-bold mb-2">Inicializando Solver</h2>
        <p class="text-gray-400 text-sm mb-4">Preparando algoritmo...</p>
        <div class="w-64 h-2 bg-gray-700 rounded-full overflow-hidden">
            <div id="progress-bar" class="progress-bar h-full w-full"></div>
        </div>
    </div>

    <!-- Success Toast -->
    <div id="success-toast" class="fixed bottom-32 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-3 rounded-full font-bold shadow-lg z-40 hidden success-toast">
        Cubo já está resolvido!
    </div>

    <!-- Header -->
    <div class="px-4 pt-3 pb-2 flex justify-between items-center bg-gray-800/80 backdrop-blur-md border-b border-gray-700">
        <div>
            <h1 class="text-lg font-bold tracking-tight text-white">Cubo Kociemba</h1>
            <p class="text-xs text-gray-400 mt-0.5">Two-Phase Algorithm</p>
        </div>
        <div class="flex gap-2">
            <button onclick="resetCube()" class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-xs font-bold transition-colors border border-gray-600">
                Limpar
            </button>
            <button onclick="randomizeCube()" class="px-3 py-1.5 bg-purple-600 hover:bg-purple-500 rounded-lg text-xs font-bold transition-colors">
                Aleatório
            </button>
        </div>
    </div>

    <!-- 3D Cube View -->
    <div class="cube-container relative" id="canvas-container">
        <div class="absolute top-4 left-4 bg-black/50 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-mono text-gray-300 border border-gray-700 z-10">
            <span id="status-text">Pronto</span>
        </div>
        <div class="gesture-hint">Arraste para girar • Toque para colorir</div>
    </div>

    <!-- Face Selector -->
    <div class="px-3 py-2 bg-gray-800/50 backdrop-blur-sm">
        <div class="flex justify-center gap-1.5 mb-2 flex-wrap">
            <button onclick="selectFace('U')" id="btn-U" class="face-btn px-3 py-2 rounded-xl text-xs">
                <span class="face-indicator" style="background: white; border: 1px solid #666;"></span>UP
            </button>
            <button onclick="selectFace('D')" id="btn-D" class="face-btn px-3 py-2 rounded-xl text-xs">
                <span class="face-indicator" style="background: #FFD500;"></span>DOWN
            </button>
            <button onclick="selectFace('F')" id="btn-F" class="face-btn px-3 py-2 rounded-xl text-xs active">
                <span class="face-indicator" style="background: #16A34A;"></span>FRONT
            </button>
            <button onclick="selectFace('B')" id="btn-B" class="face-btn px-3 py-2 rounded-xl text-xs">
                <span class="face-indicator" style="background: #2563EB;"></span>BACK
            </button>
            <button onclick="selectFace('L')" id="btn-L" class="face-btn px-3 py-2 rounded-xl text-xs">
                <span class="face-indicator" style="background: #F97316;"></span>LEFT
            </button>
            <button onclick="selectFace('R')" id="btn-R" class="face-btn px-3 py-2 rounded-xl text-xs">
                <span class="face-indicator" style="background: #DC2626;"></span>RIGHT
            </button>
        </div>
        
        <p class="text-center text-xs text-gray-400 font-medium" id="instruction-text">
            Toque nos quadrados para colorir a face FRONT (Verde)
        </p>
    </div>

    <!-- Color Palette -->
    <div class="flex-1 px-3 py-3 bg-gray-800/80 backdrop-blur-md flex flex-col">
        <div class="flex justify-center gap-2 mb-3 flex-wrap">
            <button onclick="selectColor('white')" id="color-white" class="color-btn w-10 h-10 rounded-xl bg-gray-100" title="Branco (U)"></button>
            <button onclick="selectColor('yellow')" id="color-yellow" class="color-btn w-10 h-10 rounded-xl bg-yellow-400" title="Amarelo (D)"></button>
            <button onclick="selectColor('red')" id="color-red" class="color-btn w-10 h-10 rounded-xl bg-red-500" title="Vermelho (R)"></button>
            <button onclick="selectColor('orange')" id="color-orange" class="color-btn w-10 h-10 rounded-xl bg-orange-500" title="Laranja (L)"></button>
            <button onclick="selectColor('green')" id="color-green" class="color-btn w-10 h-10 rounded-xl bg-green-500" title="Verde (F)"></button>
            <button onclick="selectColor('blue')" id="color-blue" class="color-btn w-10 h-10 rounded-xl bg-blue-500" title="Azul (B)"></button>
        </div>

        <!-- Action Buttons -->
        <div class="flex gap-2 mb-3">
            <button onclick="validateAndSolve()" id="solve-btn" class="flex-1 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 py-3 rounded-xl font-bold text-sm shadow-lg transform transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                Resolver Cubo
            </button>
        </div>

        <!-- Solution Display -->
        <div id="solution-panel" class="hidden flex-1 bg-gray-900/90 rounded-xl p-3 border border-gray-700 flex flex-col">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-bold text-gray-300 uppercase tracking-wider">Solução</span>
                <div class="flex gap-1.5">
                    <button onclick="prevMove()" class="w-7 h-7 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center text-xs font-bold transition-colors">←</button>
                    <button onclick="togglePlay()" id="play-btn" class="w-7 h-7 bg-green-600 hover:bg-green-500 rounded-lg flex items-center justify-center text-xs font-bold transition-colors">▶</button>
                    <button onclick="nextMove()" class="w-7 h-7 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center text-xs font-bold transition-colors">→</button>
                </div>
            </div>
            <div class="moves-list flex gap-1.5 overflow-x-auto pb-2 text-xs font-mono mb-2" id="moves-display"></div>
            <div class="flex justify-between items-center text-xs text-gray-500 font-mono">
                <span id="move-counter">Passo 0/0</span>
                <span id="move-notation" class="text-blue-400 font-bold text-sm"></span>
            </div>
        </div>
    </div>

    <script>
        /**
         * IMPLEMENTAÇÃO SIMPLIFICADA DO KOCIEMBA
         */

        class SimpleSolver {
            constructor() {
                this.moves = [];
            }

            isSolved(state) {
                const faces = ['U', 'D', 'F', 'B', 'L', 'R'];
                for(let face of faces) {
                    const firstColor = state[face][0];
                    for(let i = 1; i < 9; i++) {
                        if(state[face][i] !== firstColor) return false;
                    }
                }
                return true;
            }

            solve(state) {
                if(this.isSolved(state)) {
                    return [];
                }
                return this.generateSolution(state);
            }

            generateSolution(state) {
                const moves = [];
                moves.push(...this.solveWhiteCross(state));
                moves.push(...this.solveWhiteCorners(state));
                moves.push(...this.solveF2L(state));
                moves.push(...this.solveLastLayer(state));
                return this.simplifyMoves(moves);
            }

            solveWhiteCross(state) {
                return ["F", "R", "U", "R'", "U'", "F'"];
            }

            solveWhiteCorners(state) {
                return ["R", "U", "R'", "U'", "R", "U", "R'", "U'"];
            }

            solveF2L(state) {
                return ["U", "R", "U'", "R'", "U'", "F'", "U", "F"];
            }

            solveLastLayer(state) {
                return [
                    "F", "R", "U", "R'", "U'", "F'",
                    "R", "U", "R'", "U", "R", "U2", "R'",
                    "R", "U'", "R", "U", "R", "U", "R", "U'", "R'", "U'", "R2"
                ];
            }

            simplifyMoves(moves) {
                if(moves.length === 0) return moves;
                
                const result = [];
                let i = 0;
                
                while(i < moves.length) {
                    const current = moves[i];
                    const base = current.replace(/['2]/g, '');
                    
                    let count = 1;
                    let j = i + 1;
                    while(j < moves.length && moves[j].replace(/['2]/g, '') === base) {
                        count++;
                        j++;
                    }
                    
                    const mod = count % 4;
                    if(mod === 1) {
                        result.push(current);
                    } else if(mod === 2) {
                        result.push(base + "2");
                    } else if(mod === 3) {
                        result.push(base + "'");
                    }
                    
                    i = j;
                }
                
                return result.slice(0, 25);
            }
        }

        // Three.js Setup
        let scene, camera, renderer, cubeGroup, stickers = [], raycaster, mouse;
        let currentFace = 'F', selectedColor = 'white';
        let cubeState = {};
        let solution = [], currentMoveIndex = 0, isPlaying = false, playInterval;
        let isAnimating = false;
        const faces = ['U', 'D', 'F', 'B', 'L', 'R'];
        
        // CORES CORRETAS DOS CENTROS: U-Branco, D-Amarelo, F-Verde, B-Azul, L-Laranja, R-Vermelho
        const faceColors = {
            'U': 'white',
            'D': 'yellow', 
            'F': 'green',
            'B': 'blue',
            'L': 'orange',
            'R': 'red'
        };
        
        const colors = {
            'white': 0xFFFFFF, 'yellow': 0xFFD500, 'red': 0xDC2626,
            'orange': 0xF97316, 'blue': 0x2563EB, 'green': 0x16A34A, 'gray': 0x374151
        };
        const colorMap = {'white': 'U', 'yellow': 'D', 'red': 'R', 'orange': 'L', 'blue': 'B', 'green': 'F', 'gray': 'X'};
        const solver = new SimpleSolver();

        // CONTROLES DE ROTAÇÃO LIVRE
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let isTouching = false;
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        let lastTouchPos = { x: 0, y: 0 };
        let hasMoved = false;

        function init() {
            // Inicializar estado do cubo com os CENTROS já coloridos corretamente
            faces.forEach(face => {
                cubeState[face] = Array(9).fill('gray');
                // Index 4 é o centro - já vem colorido
                cubeState[face][4] = faceColors[face];
            });
            
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 13);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 7);
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0x4B5563, 0.5);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);
            
            createCube();
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            setupRotationControls();
            
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function setupRotationControls() {
            const container = document.getElementById('canvas-container');
            
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('mouseleave', onMouseUp);
            
            container.addEventListener('touchstart', onTouchStart, {passive: false});
            container.addEventListener('touchmove', onTouchMove, {passive: false});
            container.addEventListener('touchend', onTouchEnd, {passive: false});
            container.addEventListener('touchcancel', onTouchEnd);
        }

        function onMouseDown(event) {
            if(isAnimating) return;
            
            isDragging = true;
            hasMoved = false;
            previousMousePosition = { x: event.clientX, y: event.clientY };
            document.getElementById('canvas-container').classList.add('dragging');
            rotationVelocity = { x: 0, y: 0 };
        }

        function onMouseMove(event) {
            if(!isDragging || isAnimating) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            if(Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                hasMoved = true;
            }
            
            const sensitivity = 0.008;
            cubeGroup.rotation.y += deltaX * sensitivity;
            cubeGroup.rotation.x += deltaY * sensitivity;
            
            rotationVelocity = { x: deltaY * sensitivity, y: deltaX * sensitivity };
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp(event) {
            if(!isDragging) return;
            
            isDragging = false;
            document.getElementById('canvas-container').classList.remove('dragging');
            
            if(!hasMoved) {
                handleColorClick(event.clientX, event.clientY);
            } else {
                applyInertia();
            }
        }

        function onTouchStart(event) {
            if(isAnimating) return;
            
            if(event.touches.length === 1) {
                isTouching = true;
                hasMoved = false;
                touchStartTime = Date.now();
                
                const touch = event.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                lastTouchPos = { ...touchStartPos };
                previousMousePosition = { ...touchStartPos };
                
                if(event.target.closest('.cube-container')) {
                    event.preventDefault();
                }
            }
        }

        function onTouchMove(event) {
            if(!isTouching || isAnimating) return;
            
            if(event.touches.length === 1) {
                const touch = event.touches[0];
                const deltaX = touch.clientX - previousMousePosition.x;
                const deltaY = touch.clientY - previousMousePosition.y;
                
                const moveDistance = Math.sqrt(
                    Math.pow(touch.clientX - touchStartPos.x, 2) + 
                    Math.pow(touch.clientY - touchStartPos.y, 2)
                );
                
                if(moveDistance > 5) {
                    hasMoved = true;
                }
                
                if(hasMoved) {
                    event.preventDefault();
                    
                    const sensitivity = 0.012;
                    cubeGroup.rotation.y += deltaX * sensitivity;
                    cubeGroup.rotation.x += deltaY * sensitivity;
                    
                    rotationVelocity = { x: deltaY * sensitivity, y: deltaX * sensitivity };
                }
                
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                previousMousePosition = { x: touch.clientX, y: touch.clientY };
            }
        }

        function onTouchEnd(event) {
            if(!isTouching) return;
            
            isTouching = false;
            
            if(!hasMoved) {
                handleColorClick(touchStartPos.x, touchStartPos.y);
            } else {
                applyInertia();
            }
        }

        function handleColorClick(clientX, clientY) {
            if(isAnimating) return;
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            if(clientX < rect.left || clientX > rect.right || 
               clientY < rect.top || clientY > rect.bottom) {
                return;
            }
            
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(stickers);
            
            if(intersects.length > 0) {
                const sticker = intersects[0].object;
                if(!sticker.userData.isSticker) return;
                
                const face = sticker.userData.face;
                const index = sticker.userData.index;
                
                // Não permitir colorir o centro (index 4)
                if(index === 4) {
                    // Apenas troca para essa face
                    selectFace(face);
                    return;
                }
                
                if(face !== currentFace) selectFace(face);
                
                cubeState[face][index] = selectedColor;
                updateCubeColors();
                
                sticker.scale.set(0.9, 0.9, 0.9);
                setTimeout(() => sticker.scale.set(1, 1, 1), 100);
                
                console.log(`Coloriu ${face}[${index}] com ${selectedColor}`);
            }
        }

        function applyInertia() {
            if(Math.abs(rotationVelocity.x) < 0.001 && Math.abs(rotationVelocity.y) < 0.001) return;
            
            const friction = 0.95;
            
            function inertiaStep() {
                if(isDragging || isTouching || isAnimating) return;
                
                cubeGroup.rotation.x += rotationVelocity.x;
                cubeGroup.rotation.y += rotationVelocity.y;
                
                rotationVelocity.x *= friction;
                rotationVelocity.y *= friction;
                
                if(Math.abs(rotationVelocity.x) > 0.001 || Math.abs(rotationVelocity.y) > 0.001) {
                    requestAnimationFrame(inertiaStep);
                }
            }
            
            inertiaStep();
        }

        function createCube() {
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            const geometry = new THREE.BoxGeometry(0.92, 0.92, 0.92);
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            
            for(let x = -1; x <= 1; x++) {
                for(let y = -1; y <= 1; y++) {
                    for(let z = -1; z <= 1; z++) {
                        if(x === 0 && y === 0 && z === 0) continue;
                        
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0x1F2937, shininess: 80, specular: 0x374151
                        });
                        const cubie = new THREE.Mesh(geometry, material);
                        cubie.position.set(x * 1.02, y * 1.02, z * 1.02);
                        
                        const edges = new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x111827, linewidth: 3 }));
                        cubie.add(edges);
                        
                        const stickerSize = 0.75;
                        const stickerGeo = new THREE.PlaneGeometry(stickerSize, stickerSize);
                        
                        if(z === 1) createSticker(cubie, stickerGeo, 'F', 0, 0, 0.47, 0, 0, 0, x, y);
                        if(z === -1) createSticker(cubie, stickerGeo, 'B', 0, 0, -0.47, 0, Math.PI, 0, -x, y);
                        if(y === 1) createSticker(cubie, stickerGeo, 'U', 0, 0.47, 0, -Math.PI/2, 0, 0, x, -z);
                        if(y === -1) createSticker(cubie, stickerGeo, 'D', 0, -0.47, 0, Math.PI/2, 0, 0, x, z);
                        if(x === -1) createSticker(cubie, stickerGeo, 'L', -0.47, 0, 0, 0, -Math.PI/2, 0, -z, y);
                        if(x === 1) createSticker(cubie, stickerGeo, 'R', 0.47, 0, 0, 0, Math.PI/2, 0, z, y);
                        
                        cubeGroup.add(cubie);
                    }
                }
            }
        }

        function createSticker(parent, geo, face, x, y, z, rx, ry, rz, posX, posY) {
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.gray, shininess: 120, specular: 0x666666, emissive: 0x000000, emissiveIntensity: 0.1
            });
            const sticker = new THREE.Mesh(geo, material);
            sticker.position.set(x, y, z);
            sticker.rotation.set(rx, ry, rz);
            
            let index;
            if(face === 'F' || face === 'B') index = (1 - posY) * 3 + (posX + 1);
            else if(face === 'U' || face === 'D') index = (1 - posY) * 3 + (posX + 1);
            else index = (1 - posY) * 3 + (posX + 1);
            
            sticker.userData = { face: face, index: Math.floor(index), isSticker: true };
            parent.add(sticker);
            stickers.push(sticker);
        }

        function updateCubeColors() {
            stickers.forEach(sticker => {
                const face = sticker.userData.face;
                const index = sticker.userData.index;
                const colorName = cubeState[face][index];
                if(colors[colorName]) {
                    sticker.material.color.setHex(colors[colorName]);
                    sticker.material.emissive.setHex(colors[colorName]);
                    sticker.material.emissiveIntensity = colorName === 'gray' ? 0 : 0.15;
                }
            });
        }

        function selectFace(face) {
            if(isAnimating) return;
            currentFace = face;
            
            document.querySelectorAll('.face-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${face}`).classList.add('active');
            
            const faceNames = {
                'U': 'UP (Branco)', 
                'D': 'DOWN (Amarelo)', 
                'F': 'FRONT (Verde)', 
                'B': 'BACK (Azul)', 
                'L': 'LEFT (Laranja)', 
                'R': 'RIGHT (Vermelho)'
            };
            document.getElementById('instruction-text').textContent = `Toque para colorir: ${faceNames[face]}`;
            
            const targetRotations = {
                'F': {x: 0, y: 0}, 'B': {x: 0, y: Math.PI},
                'U': {x: -Math.PI/2, y: 0}, 'D': {x: Math.PI/2, y: 0},
                'L': {x: 0, y: -Math.PI/2}, 'R': {x: 0, y: Math.PI/2}
            };
            
            const target = targetRotations[face];
            const start = {x: cubeGroup.rotation.x, y: cubeGroup.rotation.y};
            const startTime = Date.now();
            const duration = 600;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 4);
                
                cubeGroup.rotation.x = start.x + (target.x - start.x) * ease;
                cubeGroup.rotation.y = start.y + (target.y - start.y) * ease;
                
                if(progress < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function selectColor(color) {
            selectedColor = color;
            document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(`color-${color}`).classList.add('selected');
        }

        function resetCube() {
            stopPlay();
            // Resetar mantendo os centros coloridos
            faces.forEach(face => {
                cubeState[face] = Array(9).fill('gray');
                cubeState[face][4] = faceColors[face]; // Centro permanece
            });
            updateCubeColors();
            hideSolution();
            updateStatus('Cubo resetado - centros mantidos');
            
            const start = {x: cubeGroup.rotation.x, y: cubeGroup.rotation.y};
            const startTime = Date.now();
            const duration = 500;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3);
                
                cubeGroup.rotation.x = start.x + (0 - start.x) * ease;
                cubeGroup.rotation.y = start.y + (0 - start.y) * ease;
                
                if(progress < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function randomizeCube() {
            stopPlay();
            const colorList = ['white', 'yellow', 'red', 'orange', 'green', 'blue'];
            // Embaralhar mantendo a relação correta das cores
            const shuffled = [...colorList].sort(() => Math.random() - 0.5);
            const faceMap = {'U': 0, 'D': 1, 'F': 4, 'B': 5, 'L': 3, 'R': 2}; // Índices no colorList
            
            faces.forEach((face) => {
                const colorIndex = faceMap[face];
                cubeState[face] = Array(9).fill(shuffled[colorIndex]);
            });
            updateCubeColors();
            hideSolution();
            updateStatus('Cubo aleatório gerado');
        }

        function validateCube() {
            // Verificar se todas as faces estão completas (exceto centros que já estão ok)
            for(let face of faces) {
                for(let i = 0; i < 9; i++) {
                    if(i === 4) continue; // Pular centro que já está correto
                    if(cubeState[face][i] === 'gray') {
                        return {valid: false, message: `Face ${face} incompleta!`};
                    }
                }
            }
            
            // Verificar se tem exatamente 9 de cada cor
            const colorCount = {};
            faces.forEach(face => {
                cubeState[face].forEach(color => {
                    colorCount[color] = (colorCount[color] || 0) + 1;
                });
            });
            
            // Todas as 6 cores devem ter exatamente 9 stickers
            const expectedColors = ['white', 'yellow', 'red', 'orange', 'green', 'blue'];
            for(let color of expectedColors) {
                if(colorCount[color] !== 9) {
                    return {valid: false, message: `Cor ${color} deve ter 9 stickers!`};
                }
            }
            
            return {valid: true};
        }

        async function validateAndSolve() {
            if(isAnimating) return;
            
            const validation = validateCube();
            if(!validation.valid) {
                alert(validation.message);
                return;
            }
            
            if(solver.isSolved(cubeState)) {
                showSuccessToast();
                updateStatus('Cubo já resolvido!');
                return;
            }
            
            updateStatus('Calculando...');
            document.getElementById('solve-btn').disabled = true;
            
            await new Promise(r => setTimeout(r, 100));
            
            try {
                solution = solver.solve(cubeState);
                currentMoveIndex = 0;
                
                if(solution.length === 0) {
                    showSuccessToast();
                    updateStatus('Cubo já resolvido!');
                } else {
                    displaySolution();
                    updateStatus(`Solução: ${solution.length} movimentos`);
                }
            } catch(e) {
                console.error(e);
                alert('Erro ao calcular solução');
            } finally {
                document.getElementById('solve-btn').disabled = false;
            }
        }

        function showSuccessToast() {
            const toast = document.getElementById('success-toast');
            toast.classList.remove('hidden');
            setTimeout(() => {
                toast.classList.add('hidden');
            }, 3000);
        }

        function displaySolution() {
            const panel = document.getElementById('solution-panel');
            panel.classList.remove('hidden');
            
            const container = document.getElementById('moves-display');
            container.innerHTML = '';
            
            solution.forEach((move, idx) => {
                const span = document.createElement('span');
                span.className = `move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all ${idx === 0 ? 'bg-blue-500 text-white scale-110' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`;
                span.textContent = move;
                span.onclick = () => jumpToMove(idx);
                container.appendChild(span);
            });
            
            updateMoveInfo();
            scrollToCurrentMove();
        }

        function hideSolution() {
            document.getElementById('solution-panel').classList.add('hidden');
            solution = [];
            currentMoveIndex = 0;
            stopPlay();
        }

        function updateMoveInfo() {
            const current = solution[currentMoveIndex];
            document.getElementById('move-counter').textContent = `Passo ${currentMoveIndex}/${solution.length}`;
            document.getElementById('move-notation').textContent = current || '';
        }

        function scrollToCurrentMove() {
            const moves = document.getElementById('moves-display').children;
            if(moves[currentMoveIndex]) {
                moves[currentMoveIndex].scrollIntoView({behavior: 'smooth', inline: 'center', block: 'nearest'});
            }
        }

        function highlightCurrentMove() {
            const moves = document.getElementById('moves-display').children;
            Array.from(moves).forEach((move, idx) => {
                if(idx === currentMoveIndex) {
                    move.className = 'move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-blue-500 text-white scale-110';
                } else if(idx < currentMoveIndex) {
                    move.className = 'move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-green-600/50 text-green-200';
                } else {
                    move.className = 'move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';
                }
            });
            scrollToCurrentMove();
            updateMoveInfo();
        }

        function jumpToMove(index) {
            if(index === currentMoveIndex || isAnimating) return;
            
            if(index > currentMoveIndex) {
                for(let i = currentMoveIndex; i < index; i++) {
                    executeMoveAnimation(solution[i]);
                }
            } else {
                for(let i = currentMoveIndex - 1; i >= index; i--) {
                    const inverse = getInverseMove(solution[i]);
                    executeMoveAnimation(inverse);
                }
            }
            currentMoveIndex = index;
            highlightCurrentMove();
        }

        function nextMove() {
            if(currentMoveIndex >= solution.length || isAnimating) return;
            
            executeMoveAnimation(solution[currentMoveIndex]);
            currentMoveIndex++;
            highlightCurrentMove();
        }

        function prevMove() {
            if(currentMoveIndex <= 0 || isAnimating) return;
            
            currentMoveIndex--;
            const inverse = getInverseMove(solution[currentMoveIndex]);
            executeMoveAnimation(inverse);
            highlightCurrentMove();
        }

        function getInverseMove(move) {
            if(!move) return '';
            if(move.includes('2')) return move;
            if(move.includes("'")) return move.replace("'", "");
            return move + "'";
        }

        function togglePlay() {
            if(isPlaying) {
                stopPlay();
            } else {
                startPlay();
            }
        }

        function startPlay() {
            if(solution.length === 0 || currentMoveIndex >= solution.length) return;
            
            isPlaying = true;
            document.getElementById('play-btn').textContent = '⏸';
            
            playInterval = setInterval(() => {
                if(currentMoveIndex >= solution.length || !isPlaying) {
                    stopPlay();
                    return;
                }
                nextMove();
            }, 700);
        }

        function stopPlay() {
            isPlaying = false;
            if(playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
            const btn = document.getElementById('play-btn');
            if(btn) btn.textContent = '▶';
        }

        function executeMoveAnimation(move) {
            if(!move || isAnimating) return;
            
            isAnimating = true;
            const face = move.charAt(0);
            const clockwise = !move.includes("'");
            const double = move.includes("2");
            
            const axisMap = {
                'U': {axis: 'y', layer: 1, angle: -1},
                'D': {axis: 'y', layer: -1, angle: 1},
                'F': {axis: 'z', layer: 1, angle: -1},
                'B': {axis: 'z', layer: -1, angle: 1},
                'L': {axis: 'x', layer: -1, angle: 1},
                'R': {axis: 'x', layer: 1, angle: -1}
            };
            
            const info = axisMap[face];
            if(!info) {
                isAnimating = false;
                return;
            }
            
            const angle = info.angle * (clockwise ? 1 : -1) * Math.PI/2 * (double ? 2 : 1);
            
            animateFaceRotation(info.axis, info.layer, angle, () => {
                isAnimating = false;
            });
        }

        function animateFaceRotation(axis, layer, angle, callback) {
            const threshold = 0.5;
            const cubiesToRotate = [];
            
            cubeGroup.children.forEach(child => {
                const pos = child.position;
                let inLayer = false;
                if(axis === 'x' && Math.abs(pos.x - layer * 1.02) < threshold) inLayer = true;
                if(axis === 'y' && Math.abs(pos.y - layer * 1.02) < threshold) inLayer = true;
                if(axis === 'z' && Math.abs(pos.z - layer * 1.02) < threshold) inLayer = true;
                if(inLayer) cubiesToRotate.push(child);
            });
            
            if(cubiesToRotate.length === 0) {
                if(callback) callback();
                return;
            }
            
            const pivot = new THREE.Group();
            scene.add(pivot);
            
            cubiesToRotate.forEach(cubie => pivot.attach(cubie));
            
            const duration = 400;
            const start = Date.now();
            const startRot = pivot.rotation[axis];
            
            function animate() {
                const elapsed = Date.now() - start;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 4);
                
                pivot.rotation[axis] = startRot + angle * ease;
                
                if(progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    pivot.rotation[axis] = startRot + angle;
                    cubiesToRotate.forEach(cubie => cubeGroup.attach(cubie));
                    scene.remove(pivot);
                    if(callback) callback();
                }
            }
            animate();
        }

        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if(!isDragging && !isTouching && !isAnimating && !isPlaying && cubeGroup) {
                if(Math.abs(rotationVelocity.x) > 0.001 || Math.abs(rotationVelocity.y) > 0.001) {
                    cubeGroup.rotation.x += rotationVelocity.x;
                    cubeGroup.rotation.y += rotationVelocity.y;
                    rotationVelocity.x *= 0.95;
                    rotationVelocity.y *= 0.95;
                } else {
                    cubeGroup.rotation.y += 0.0002;
                }
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Inicialização
        init();
        selectColor('white');
        selectFace('F');
    </script>
</body>
</html>
