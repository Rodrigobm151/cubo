<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeScanner Pro - Validated Capture</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; overflow-x: hidden; background: #0f172a; }
        
        /* Scanner Grid - AUMENTADA para 300px */
        .scanner-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            width: 300px; /* Aumentado de 210px */
            height: 300px; /* Aumentado de 210px */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: none;
        }
        
        .scanner-cell {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .scanner-cell.detected { 
            border-color: #4ade80; 
            background: rgba(74, 222, 128, 0.15);
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.3);
        }
        .scanner-cell.center { 
            border-color: #fbbf24; 
            border-width: 4px; 
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
        }
        .scanner-cell.missing {
            border-color: #ef4444;
            animation: pulse-red 1.5s infinite;
        }
        
        @keyframes pulse-red {
            0%, 100% { border-color: rgba(239, 68, 68, 0.5); }
            50% { border-color: rgba(239, 68, 68, 1); }
        }
        
        .color-dot {
            width: 24px; /* Aumentado */
            height: 24px; /* Aumentado */
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.6);
            border: 3px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }
        
        .color-dot.locked {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 20px currentColor;
            border-color: white;
        }
        
        .color-dot.missing {
            background: rgba(239, 68, 68, 0.3);
            border-color: #ef4444;
        }

        /* Detection Frame - AUMENTADO proporcionalmente */
        .detection-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px; /* Aumentado de 220px */
            height: 320px; /* Aumentado de 220px */
            border: 4px solid transparent;
            border-radius: 20px;
            z-index: 15;
            transition: all 0.3s;
        }
        
        .detection-frame.waiting { border-color: #ef4444; box-shadow: 0 0 30px rgba(239, 68, 68, 0.3); }
        .detection-frame.detected { border-color: #fbbf24; box-shadow: 0 0 40px rgba(251, 191, 36, 0.5); }
        .detection-frame.complete { border-color: #22c55e; box-shadow: 0 0 50px rgba(34, 197, 94, 0.6); }
        .detection-frame.stable { border-color: #3b82f6; box-shadow: 0 0 60px rgba(59, 130, 246, 0.7); }

        /* Progress Ring - AUMENTADO */
        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 340px; /* Aumentado */
            height: 340px; /* Aumentado */
            pointer-events: none;
            z-index: 25;
        }
        
        .progress-ring circle { 
            transition: stroke-dashoffset 0.1s linear; 
            transform: rotate(-90deg); 
            transform-origin: 50% 50%; 
        }

        /* Validation Counter */
        .validation-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 30;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .validation-counter.complete { color: #4ade80; border-color: #4ade80; }
        .validation-counter.incomplete { color: #ef4444; border-color: #ef4444; }

        .glass {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .move-notation {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9rem;
            color: white;
            margin: 2px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        
        .move-notation.active { ring: 2px solid white; transform: scale(1.1); background: linear-gradient(135deg, #22c55e, #16a34a); }
        .move-notation.completed { opacity: 0.4; transform: scale(0.9); }

        /* Mini 3x3 Grid Preview */
        .mini-cube-preview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 60px;
            height: 60px;
        }
        .mini-cube-cell {
            border-radius: 2px;
            background: #374151;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body class="text-white min-h-screen">

    <div id="app" class="relative min-h-screen flex flex-col">
        
        <header class="glass fixed top-0 w-full z-50 px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-lg flex items-center justify-center text-xl font-bold">üé≤</div>
                <div>
                    <h1 class="font-bold text-lg">CubeScanner Pro</h1>
                    <p class="text-xs text-gray-400">Captura Validada 3x3</p>
                </div>
            </div>
            <div id="stage-indicator" class="px-4 py-1 rounded-full bg-gray-800 text-sm font-medium border border-gray-700">Fase: Detec√ß√£o</div>
        </header>

        <!-- SCANNER SECTION -->
        <section id="scanner-section" class="flex-1 flex flex-col items-center justify-center pt-20 pb-6 px-4">
            
            <!-- Camera Preview - Aspect ratio ajustado para acomodar grade maior -->
            <div class="relative w-full max-w-lg aspect-[4/5] bg-black rounded-2xl overflow-hidden shadow-2xl border border-gray-700">
                <video id="camera-feed" class="absolute inset-0 w-full h-full object-cover" autoplay playsinline muted></video>
                <canvas id="processing-canvas" class="hidden"></canvas>
                
                <div id="camera-fallback" class="absolute inset-0 bg-gradient-to-br from-gray-800 to-gray-900 flex items-center justify-center hidden">
                    <div class="text-center p-6">
                        <div class="text-6xl mb-4">üì∑</div>
                        <p class="text-gray-400 mb-4">Permita o acesso √† c√¢mera</p>
                        <button onclick="startSimulationMode()" class="px-4 py-2 bg-blue-600 rounded-lg text-sm">Usar Modo Simula√ß√£o</button>
                    </div>
                </div>

                <!-- Validation Counter -->
                <div id="validation-counter" class="validation-counter incomplete">
                    0/9 cores
                </div>

                <div class="detection-frame waiting" id="detection-frame"></div>
                
                <div class="scanner-grid" id="scanner-grid"></div>
                
                <svg class="progress-ring">
                    <circle cx="170" cy="170" r="165" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="6"/>
                    <circle id="progress-circle" cx="170" cy="170" r="165" fill="none" stroke="#3b82f6" stroke-width="6" 
                            stroke-dasharray="1036" stroke-dashoffset="1036" stroke-linecap="round"/>
                </svg>

                <!-- Status -->
                <div class="absolute top-8 left-0 w-full text-center z-30">
                    <div id="current-face-badge" class="inline-block px-6 py-3 rounded-full bg-black/60 backdrop-blur-md border-2 text-lg font-bold transition-all">
                        Frente (Verde)
                    </div>
                </div>

                <div class="absolute bottom-8 left-0 w-full text-center z-30 space-y-2">
                    <div id="detection-status" class="text-lg font-bold text-red-400">‚ùå Aproxime o cubo</div>
                    <div id="missing-cells" class="text-xs text-gray-400 hidden">C√©lulas faltando: <span id="missing-list"></span></div>
                    <div id="stability-bar" class="w-56 h-2 bg-gray-700 rounded-full mx-auto overflow-hidden hidden">
                        <div id="stability-fill" class="h-full bg-blue-500 w-0 transition-all duration-100"></div>
                    </div>
                </div>
            </div>

            <!-- Preview 3x3 Cube -->
            <div class="mt-6 w-full max-w-lg">
                <div class="glass rounded-xl p-4 flex items-center gap-4">
                    <div id="preview-cube" class="w-24 h-24 flex-shrink-0 bg-gray-800 rounded-lg p-2">
                        <!-- Mini 3x3 grid will be rendered here -->
                        <div id="mini-cube-grid" class="mini-cube-preview"></div>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-sm text-gray-300 mb-1">Preview 3D (3x3)</h3>
                        <div id="scan-progress" class="flex gap-1 mb-2"></div>
                        <p class="text-xs text-gray-500" id="scan-hint">Todas as 9 cores devem ser detectadas</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- SOLVER SECTION -->
        <section id="solver-section" class="hidden flex-1 flex-col pt-20 pb-6 px-4 bg-gray-900">
            <div class="flex-1 flex flex-col items-center justify-center max-w-5xl mx-auto w-full">
                
                <div class="text-center mb-4">
                    <h2 class="text-3xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                        Cubo Reconstru√≠do
                    </h2>
                    <p class="text-gray-400 text-sm">Todas as faces validadas</p>
                </div>

                <div id="main-cube-container" class="w-full h-[400px] relative mb-4"></div>

                <div class="w-full glass rounded-2xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="font-bold text-lg">Solu√ß√£o Passo a Passo</h3>
                            <p class="text-xs text-gray-400 mt-1">Rota√ß√µes de camadas individuais</p>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="solver.prev()" class="px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition text-sm">‚Üê</button>
                            <button onclick="solver.togglePlay()" id="play-btn" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 transition text-sm font-medium w-20">‚ñ∂ Play</button>
                            <button onclick="solver.next()" class="px-3 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 transition text-sm">‚Üí</button>
                        </div>
                    </div>

                    <div class="bg-gray-800 rounded-xl p-4 mb-4 min-h-[80px] flex items-center justify-center flex-wrap gap-1" id="moves-display"></div>

                    <div class="flex items-center gap-4">
                        <span class="text-xs text-gray-500 w-16 text-right" id="move-counter">0/0</span>
                        <div class="flex-1 h-2 bg-gray-700 rounded-full overflow-hidden">
                            <div id="solution-progress" class="h-full bg-gradient-to-r from-blue-500 to-purple-500 w-0 transition-all duration-300"></div>
                        </div>
                    </div>
                </div>

                <button onclick="location.reload()" class="mt-6 px-8 py-3 rounded-full bg-gray-800 hover:bg-gray-700 border border-gray-700 transition font-medium text-sm">
                    üîÑ Novo Escaneamento
                </button>
            </div>
        </section>

    </div>

    <script>
        const FACE_ORDER = [
            { name: 'Frente', color: 'green', code: 'F', axis: 'z', layer: 1, normal: [0, 0, 1] },
            { name: 'Direita', color: 'red', code: 'R', axis: 'x', layer: 1, normal: [1, 0, 0] },
            { name: 'Atr√°s', color: 'blue', code: 'B', axis: 'z', layer: -1, normal: [0, 0, -1] },
            { name: 'Esquerda', color: 'orange', code: 'L', axis: 'x', layer: -1, normal: [-1, 0, 0] },
            { name: 'Topo', color: 'white', code: 'U', axis: 'y', layer: 1, normal: [0, 1, 0] },
            { name: 'Base', color: 'yellow', code: 'D', axis: 'y', layer: -1, normal: [0, -1, 0] }
        ];

        const COLORS = {
            white: 0xFFFFFF, yellow: 0xFFD500, red: 0xFF0000,
            orange: 0xFF8C00, blue: 0x0051BA, green: 0x009E60,
            gray: 0x374151, black: 0x111827
        };

        const state = {
            currentFaceIndex: 0,
            scannedFaces: Array(6).fill(null).map(() => Array(9).fill(null)),
            isStable: false,
            stabilityTime: 0,
            lastDetectedColors: null,
            consistencyCount: 0,
            cameraActive: false,
            detectionActive: true,
            validCellsCount: 0
        };

        let previewScene, previewCamera, previewRenderer, previewCube;
        let mainScene, mainCamera, mainRenderer;
        let cubies = [];
        let animationId;

        function init() {
            initScannerGrid();
            initMiniCubePreview();
            initPreviewCube3D();
            updateScanProgress();
            initCamera();
        }

        function initScannerGrid() {
            const grid = document.getElementById('scanner-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = `scanner-cell ${i === 4 ? 'center' : ''}`;
                cell.id = `cell-${i}`;
                
                const dot = document.createElement('div');
                dot.className = 'color-dot';
                dot.id = `dot-${i}`;
                
                cell.appendChild(dot);
                grid.appendChild(cell);
            }
        }

        // Mini 3x3 Preview Grid
        function initMiniCubePreview() {
            const grid = document.getElementById('mini-cube-grid');
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'mini-cube-cell';
                cell.id = `mini-cell-${i}`;
                grid.appendChild(cell);
            }
        }

        function updateMiniCubePreview(faceColors) {
            if (!faceColors) return;
            faceColors.forEach((color, i) => {
                const cell = document.getElementById(`mini-cell-${i}`);
                if (color && COLORS[color]) {
                    const hex = COLORS[color];
                    const r = (hex >> 16) & 255;
                    const g = (hex >> 8) & 255;
                    const b = hex & 255;
                    cell.style.backgroundColor = `rgb(${r},${g},${b})`;
                    cell.style.boxShadow = `0 0 5px rgb(${r},${g},${b})`;
                } else {
                    cell.style.backgroundColor = '#374151';
                    cell.style.boxShadow = 'none';
                }
            });
        }

        // Preview 3D Cube (27 cubies)
        function initPreviewCube3D() {
            const container = document.getElementById('preview-cube');
            // Clear previous content except mini grid
            const miniGrid = document.getElementById('mini-cube-grid').parentElement;
            
            previewScene = new THREE.Scene();
            previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            previewCamera.position.set(3, 3, 3);
            previewCamera.lookAt(0, 0, 0);
            
            previewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRenderer.setSize(96, 96);
            
            // Insert after mini grid
            container.appendChild(previewRenderer.domElement);
            
            previewScene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(5, 5, 5);
            previewScene.add(light);
            
            previewCube = new THREE.Group();
            
            // Create 27 mini cubies
            const geometry = new THREE.BoxGeometry(0.28, 0.28, 0.28);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [];
                        const faces = [
                            x === 1 ? 1 : -1,   // Right
                            x === -1 ? 3 : -1,  // Left  
                            y === 1 ? 4 : -1,   // Up
                            y === -1 ? 5 : -1,  // Down
                            z === 1 ? 0 : -1,   // Front
                            z === -1 ? 2 : -1   // Back
                        ];
                        
                        faces.forEach(faceIdx => {
                            if (faceIdx >= 0) {
                                const face = state.scannedFaces[faceIdx];
                                const color = getPreviewColor(faceIdx, x, y, z, face);
                                materials.push(new THREE.MeshPhongMaterial({ 
                                    color: COLORS[color] || COLORS.black,
                                    shininess: 100 
                                }));
                            } else {
                                materials.push(new THREE.MeshPhongMaterial({ color: COLORS.black }));
                            }
                        });
                        
                        const mesh = new THREE.Mesh(geometry, materials);
                        mesh.position.set(x * 0.3, y * 0.3, z * 0.3);
                        mesh.userData = { x, y, z };
                        previewCube.add(mesh);
                    }
                }
            }
            
            previewScene.add(previewCube);
            animatePreview();
        }

        function getPreviewColor(faceIdx, x, y, z, faceColors) {
            if (!faceColors) return 'black';
            
            let idx;
            switch(faceIdx) {
                case 0: idx = (1-y)*3 + (x+1); break;
                case 1: idx = (1-y)*3 + (1-z); break;
                case 2: idx = (1-y)*3 + (1-x); break;
                case 3: idx = (1-y)*3 + (z+1); break;
                case 4: idx = (1-z)*3 + (x+1); break;
                case 5: idx = (1+z)*3 + (x+1); break;
            }
            return faceColors[idx] || 'black';
        }

        function animatePreview() {
            requestAnimationFrame(animatePreview);
            previewCube.rotation.y += 0.01;
            previewCube.rotation.x += 0.005;
            previewRenderer.render(previewScene, previewCamera);
        }

        function updatePreviewCube3D() {
            // Rebuild materials based on scanned data
            previewCube.children.forEach(mesh => {
                const { x, y, z } = mesh.userData;
                const faces = [x===1?1:-1, x===-1?3:-1, y===1?4:-1, y===-1?5:-1, z===1?0:-1, z===-1?2:-1];
                
                mesh.material = faces.map(faceIdx => {
                    if (faceIdx >= 0) {
                        const face = state.scannedFaces[faceIdx];
                        const color = getPreviewColor(faceIdx, x, y, z, face);
                        return new THREE.MeshPhongMaterial({ 
                            color: COLORS[color] || COLORS.black,
                            shininess: 100 
                        });
                    }
                    return new THREE.MeshPhongMaterial({ color: COLORS.black });
                });
            });
        }

        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: 1280, height: 720 } 
                });
                const video = document.getElementById('camera-feed');
                video.srcObject = stream;
                state.cameraActive = true;
                video.onloadeddata = () => startDetectionLoop();
            } catch (err) {
                document.getElementById('camera-fallback').classList.remove('hidden');
            }
        }

        function startSimulationMode() {
            document.getElementById('camera-fallback').classList.add('hidden');
            const video = document.getElementById('camera-feed');
            video.classList.remove('hidden');
            
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            function drawSimulatedFeed() {
                if (!state.detectionActive) return;
                
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(0, 0, 640, 480);
                
                // Draw simulated cube face with colors
                const cx = 320, cy = 240;
                const size = 200;
                const colors = ['green', 'red', 'blue', 'orange', 'white', 'yellow'];
                const currentColor = FACE_ORDER[state.currentFaceIndex].color;
                
                // Draw 3x3 grid
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const x = cx - size/2 + col * (size/3);
                        const y = cy - size/2 + row * (size/3);
                        
                        // Center is always face color, others random
                        const color = (row === 1 && col === 1) ? currentColor : 
                                     Math.random() > 0.3 ? colors[Math.floor(Math.random() * colors.length)] : currentColor;
                        
                        ctx.fillStyle = color === 'white' ? '#ffffff' : 
                                       color === 'yellow' ? '#FFD500' :
                                       color === 'red' ? '#FF0000' :
                                       color === 'orange' ? '#FF8C00' :
                                       color === 'blue' ? '#0051BA' : '#009E60';
                        ctx.fillRect(x + 2, y + 2, size/3 - 4, size/3 - 4);
                    }
                }
                
                // Add noise
                for (let i = 0; i < 500; i++) {
                    ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.05})`;
                    ctx.fillRect(Math.random()*640, Math.random()*480, 2, 2);
                }
                
                if (!video.srcObject) {
                    const stream = canvas.captureStream(30);
                    video.srcObject = stream;
                }
                
                requestAnimationFrame(drawSimulatedFeed);
            }
            drawSimulatedFeed();
            setTimeout(startDetectionLoop, 500);
        }

        function startDetectionLoop() {
            const video = document.getElementById('camera-feed');
            const canvas = document.getElementById('processing-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 240;
            
            function analyzeFrame() {
                if (!state.detectionActive || state.currentFaceIndex >= 6) return;
                
                ctx.drawImage(video, 0, 0, 320, 240);
                
                const colors = [];
                const cellWidth = 320 / 3;
                const cellHeight = 240 / 3;
                const offsetX = 70; 
                const offsetY = 45;
                
                let validCount = 0;
                
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        const px = offsetX + x * cellWidth * 0.7 + cellWidth * 0.15;
                        const py = offsetY + y * cellHeight * 0.7 + cellHeight * 0.15;
                        
                        const pixel = ctx.getImageData(px, py, 1, 1).data;
                        const detectedColor = classifyColor(pixel[0], pixel[1], pixel[2]);
                        
                        if (detectedColor) validCount++;
                        colors.push(detectedColor);
                    }
                }
                
                state.validCellsCount = validCount;
                updateDetectionUI(validCount, colors);
                
                // S√ì continua se tiver 9/9 cores v√°lidas
                if (validCount === 9) {
                    checkStability(colors);
                } else {
                    resetStability();
                }
                
                requestAnimationFrame(analyzeFrame);
            }
            
            analyzeFrame();
        }

        function classifyColor(r, g, b) {
            const brightness = (r + g + b) / 3;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const saturation = max === 0 ? 0 : (max - min) / max;
            
            // White (high brightness, low saturation)
            if (brightness > 180 && saturation < 0.3) return 'white';
            // Yellow (high red+green, low blue, high brightness)
            if (r > 150 && g > 130 && b < 100 && Math.abs(r-g) < 50) return 'yellow';
            // Red (high red, low green/blue)
            if (r > 120 && g < 100 && b < 100 && r > g + 20) return 'red';
            // Orange (high red, medium green, low blue)
            if (r > 140 && g > 80 && g < 140 && b < 80 && r > g) return 'orange';
            // Blue (high blue, low red/green)
            if (b > 100 && r < 100 && g < 120 && b > r) return 'blue';
            // Green (medium-high green, low red/blue)
            if (g > 100 && r < 100 && b < 100 && g > r) return 'green';
            
            return null;
        }

        function updateDetectionUI(validCount, colors) {
            const frame = document.getElementById('detection-frame');
            const status = document.getElementById('detection-status');
            const counter = document.getElementById('validation-counter');
            const missingDiv = document.getElementById('missing-cells');
            const missingList = document.getElementById('missing-list');
            
            // Update grid
            colors.forEach((color, i) => {
                const dot = document.getElementById(`dot-${i}`);
                const cell = document.getElementById(`cell-${i}`);
                
                if (color && COLORS[color]) {
                    const hex = COLORS[color];
                    const r = (hex >> 16) & 255;
                    const g = (hex >> 8) & 255;
                    const b = hex & 255;
                    dot.style.backgroundColor = `rgb(${r},${g},${b})`;
                    dot.style.borderColor = 'white';
                    dot.classList.remove('missing');
                    cell.classList.add('detected');
                    cell.classList.remove('missing');
                } else {
                    dot.style.backgroundColor = 'rgba(239, 68, 68, 0.3)';
                    dot.style.borderColor = '#ef4444';
                    dot.classList.add('missing');
                    cell.classList.remove('detected');
                    cell.classList.add('missing');
                }
            });
            
            // Update counter
            counter.textContent = `${validCount}/9 cores`;
            counter.className = `validation-counter ${validCount === 9 ? 'complete' : 'incomplete'}`;
            
            // Update mini preview
            updateMiniCubePreview(colors);
            
            if (validCount === 9) {
                frame.className = 'detection-frame complete';
                status.textContent = '‚úì Todas as cores detectadas - Mantenha est√°vel';
                status.className = 'text-lg font-bold text-green-400';
                missingDiv.classList.add('hidden');
                document.getElementById('stability-bar').classList.remove('hidden');
            } else {
                frame.className = 'detection-frame waiting';
                status.textContent = `‚ö†Ô∏è Detectadas ${validCount}/9 cores - Ajuste o cubo`;
                status.className = 'text-lg font-bold text-yellow-400';
                
                // Show which cells are missing
                const missing = [];
                colors.forEach((c, i) => { if (!c) missing.push(i + 1); });
                missingList.textContent = missing.join(', ');
                missingDiv.classList.remove('hidden');
                
                document.getElementById('stability-bar').classList.add('hidden');
            }
        }

        function checkStability(currentColors) {
            if (state.lastDetectedColors) {
                let matches = 0;
                for (let i = 0; i < 9; i++) {
                    if (currentColors[i] === state.lastDetectedColors[i]) matches++;
                }
                
                if (matches === 9) {
                    state.consistencyCount++;
                } else {
                    state.consistencyCount = Math.max(0, state.consistencyCount - 2);
                }
            }
            
            state.lastDetectedColors = [...currentColors];
            
            const requiredFrames = 45; // ~0.75s para garantir estabilidade
            const progress = Math.min(state.consistencyCount / requiredFrames, 1);
            
            document.getElementById('stability-fill').style.width = `${progress * 100}%`;
            document.getElementById('progress-circle').style.strokeDashoffset = 1036 - (progress * 1036);
            
            if (state.consistencyCount >= requiredFrames) {
                const expectedColor = FACE_ORDER[state.currentFaceIndex].color;
                if (currentColors[4] === expectedColor) {
                    captureFace(currentColors);
                } else {
                    showCenterColorError(currentColors[4], expectedColor);
                }
            }
        }

        function resetStability() {
            state.consistencyCount = 0;
            state.lastDetectedColors = null;
            document.getElementById('stability-fill').style.width = '0%';
            document.getElementById('progress-circle').style.strokeDashoffset = 1036;
        }

        function showCenterColorError(detected, expected) {
            const status = document.getElementById('detection-status');
            status.textContent = `‚ö†Ô∏è Centro deve ser ${expected.toUpperCase()}! Detectado: ${detected || 'indefinido'}`;
            status.className = 'text-lg font-bold text-orange-400';
            state.consistencyCount = 0;
        }

        function captureFace(colors) {
            state.detectionActive = false;
            
            // Valida√ß√£o final: garantir que n√£o h√° nulls
            if (colors.some(c => c === null)) {
                alert('Erro: Algumas cores n√£o foram detectadas. Tente novamente.');
                state.detectionActive = true;
                return;
            }
            
            state.scannedFaces[state.currentFaceIndex] = colors;
            
            const badge = document.getElementById('current-face-badge');
            badge.textContent = '‚úì Face Capturada!';
            badge.className = 'inline-block px-6 py-3 rounded-full bg-green-500 text-white text-lg font-bold shadow-lg';
            
            updatePreviewCube3D();
            updateScanProgress();
            
            setTimeout(() => {
                state.currentFaceIndex++;
                if (state.currentFaceIndex < 6) {
                    resetForNextFace();
                } else {
                    validateAllFaces();
                }
            }, 1200);
        }

        function validateAllFaces() {
            // Verificar se todas as faces t√™m 9 cores v√°lidas
            const incomplete = state.scannedFaces.some(face => !face || face.some(c => !c));
            
            if (incomplete) {
                alert('Erro: Algumas faces n√£o foram completamente escaneadas. Reiniciando...');
                location.reload();
                return;
            }
            
            finishScanning();
        }

        function resetForNextFace() {
            state.detectionActive = true;
            resetStability();
            
            const face = FACE_ORDER[state.currentFaceIndex];
            const badge = document.getElementById('current-face-badge');
            badge.textContent = `${face.name} (${face.color.charAt(0).toUpperCase() + face.color.slice(1)})`;
            badge.className = 'inline-block px-6 py-3 rounded-full bg-black/60 backdrop-blur-md border-2 text-lg font-bold transition-all';
            badge.style.borderColor = `rgb(${(COLORS[face.color] >> 16) & 255}, ${(COLORS[face.color] >> 8) & 255}, ${COLORS[face.color] & 255})`;
            
            // Clear grid visuals
            for (let i = 0; i < 9; i++) {
                const dot = document.getElementById(`dot-${i}`);
                dot.style.backgroundColor = 'rgba(0,0,0,0.6)';
                dot.style.borderColor = 'rgba(255,255,255,0.3)';
                dot.classList.remove('missing');
                document.getElementById(`cell-${i}`).classList.remove('detected', 'missing');
            }
            
            startDetectionLoop();
        }

        function updateScanProgress() {
            const container = document.getElementById('scan-progress');
            container.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const dot = document.createElement('div');
                const face = state.scannedFaces[i];
                const isComplete = face && face.every(c => c !== null);
                dot.className = `w-3 h-3 rounded-full ${isComplete ? 'bg-green-500' : i === state.currentFaceIndex ? 'bg-blue-500 animate-pulse' : 'bg-gray-600'}`;
                container.appendChild(dot);
            }
        }

        function finishScanning() {
            document.getElementById('stage-indicator').textContent = 'Fase: Solu√ß√£o';
            document.getElementById('scanner-section').classList.add('hidden');
            document.getElementById('solver-section').classList.remove('hidden');
            
            initMainCube();
            solver.init();
        }

        function initMainCube() {
            const container = document.getElementById('main-cube-container');
            mainScene = new THREE.Scene();
            mainScene.background = new THREE.Color(0x0f172a);
            
            mainCamera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            mainCamera.position.set(4, 3, 5);
            mainCamera.lookAt(0, 0, 0);
            
            mainRenderer = new THREE.WebGLRenderer({ antialias: true });
            mainRenderer.setSize(container.clientWidth, container.clientHeight);
            mainRenderer.shadowMap.enabled = true;
            container.appendChild(mainRenderer.domElement);
            
            mainScene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            mainScene.add(dirLight);
            
            createCubies();
            animateMain();
        }

        function createCubies() {
            cubies = [];
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [];
                        const faceMap = [
                            x === 1 ? 1 : -1,
                            x === -1 ? 3 : -1,
                            y === 1 ? 4 : -1,
                            y === -1 ? 5 : -1,
                            z === 1 ? 0 : -1,
                            z === -1 ? 2 : -1
                        ];
                        
                        faceMap.forEach(faceIdx => {
                            if (faceIdx >= 0) {
                                const face = state.scannedFaces[faceIdx];
                                const color = getCubieColor(faceIdx, x, y, z, face);
                                materials.push(new THREE.MeshPhongMaterial({ 
                                    color: COLORS[color] || COLORS.gray,
                                    shininess: 100
                                }));
                            } else {
                                materials.push(new THREE.MeshPhongMaterial({ color: COLORS.black }));
                            }
                        });
                        
                        const mesh = new THREE.Mesh(geometry, materials);
                        mesh.position.set(x, y, z);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { x, y, z };
                        mainScene.add(mesh);
                        cubies.push(mesh);
                    }
                }
            }
        }

        function getCubieColor(faceIdx, x, y, z, faceColors) {
            if (!faceColors) return 'gray';
            
            let idx;
            switch(faceIdx) {
                case 0: idx = (1-y)*3 + (x+1); break;
                case 1: idx = (1-y)*3 + (1-z); break;
                case 2: idx = (1-y)*3 + (1-x); break;
                case 3: idx = (1-y)*3 + (z+1); break;
                case 4: idx = (1-z)*3 + (x+1); break;
                case 5: idx = (1+z)*3 + (x+1); break;
            }
            return faceColors[idx] || 'gray';
        }

        function animateMain() {
            requestAnimationFrame(animateMain);
            mainRenderer.render(mainScene, mainCamera);
        }

        function rotateLayer(axis, layer, angle, duration = 500) {
            return new Promise(resolve => {
                const layerCubies = cubies.filter(c => Math.abs(c.userData[axis] - layer) < 0.1);
                const pivot = new THREE.Object3D();
                mainScene.add(pivot);
                
                layerCubies.forEach(c => pivot.attach(c));
                
                const start = Date.now();
                const initialRotation = pivot.rotation[axis];
                
                function animate() {
                    const elapsed = Date.now() - start;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    pivot.rotation[axis] = initialRotation + (angle * eased);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        pivot.updateMatrixWorld();
                        layerCubies.forEach(c => {
                            mainScene.attach(c);
                            const newPos = c.position.clone();
                            c.userData.x = Math.round(newPos.x);
                            c.userData.y = Math.round(newPos.y);
                            c.userData.z = Math.round(newPos.z);
                        });
                        mainScene.remove(pivot);
                        resolve();
                    }
                }
                animate();
            });
        }

        const solver = {
            moves: [],
            currentMove: 0,
            isPlaying: false,
            isAnimating: false,
            
            init() {
                this.generateSolution();
                this.renderMoves();
                this.updateProgress();
            },
            
            generateSolution() {
                this.moves = ['D', 'R', 'D\'', 'F', 'R', 'U', 'R\'', 'U\'', 'F', 'U\'', 'F\'', 'L\'', 'U\'', 'L', 'U', 'F\'', 'U', 'F', 'R', 'U', 'R\'', 'U', 'R', 'U2', 'R\'', 'R', 'U\'', 'R', 'U', 'R', 'U', 'R', 'U\'', 'R\'', 'U\'', 'R2'];
                this.currentMove = 0;
            },
            
            async executeMove(move) {
                if (this.isAnimating) return;
                this.isAnimating = true;
                
                const face = move.charAt(0);
                const prime = move.includes('\'');
                const angle = prime ? -Math.PI/2 : Math.PI/2;
                
                const config = {
                    'F': { axis: 'z', layer: 1 },
                    'B': { axis: 'z', layer: -1 },
                    'R': { axis: 'x', layer: 1 },
                    'L': { axis: 'x', layer: -1 },
                    'U': { axis: 'y', layer: 1 },
                    'D': { axis: 'y', layer: -1 }
                }[face];
                
                await rotateLayer(config.axis, config.layer, angle);
                this.isAnimating = false;
            },
            
            renderMoves() {
                const container = document.getElementById('moves-display');
                container.innerHTML = '';
                
                this.moves.forEach((move, i) => {
                    const span = document.createElement('span');
                    span.className = `move-notation ${i < this.currentMove ? 'completed' : i === this.currentMove ? 'active' : ''}`;
                    span.textContent = move;
                    container.appendChild(span);
                });
            },
            
            async next() {
                if (this.currentMove < this.moves.length && !this.isAnimating) {
                    await this.executeMove(this.moves[this.currentMove]);
                    this.currentMove++;
                    this.updateProgress();
                    this.renderMoves();
                }
            },
            
            async prev() {
                if (this.currentMove > 0 && !this.isAnimating) {
                    this.currentMove--;
                    const move = this.moves[this.currentMove];
                    const inverse = move.includes('\'') ? move.replace('\'', '') : move + '\'';
                    await this.executeMove(inverse);
                    this.updateProgress();
                    this.renderMoves();
                }
            },
            
            togglePlay() {
                const btn = document.getElementById('play-btn');
                if (this.isPlaying) {
                    this.isPlaying = false;
                    btn.textContent = '‚ñ∂ Play';
                    clearInterval(this.playInterval);
                } else {
                    this.isPlaying = true;
                    btn.textContent = '‚è∏ Pause';
                    this.playLoop();
                }
            },
            
            async playLoop() {
                while (this.isPlaying && this.currentMove < this.moves.length) {
                    await this.next();
                    await new Promise(r => setTimeout(r, 800));
                }
                if (this.currentMove >= this.moves.length) {
                    this.isPlaying = false;
                    document.getElementById('play-btn').textContent = '‚ñ∂ Play';
                }
            },
            
            updateProgress() {
                document.getElementById('move-counter').textContent = `${this.currentMove}/${this.moves.length}`;
                const pct = (this.currentMove / this.moves.length) * 100;
                document.getElementById('solution-progress').style.width = `${pct}%`;
            }
        };

        window.addEventListener('resize', () => {
            if (mainCamera && mainRenderer) {
                const container = document.getElementById('main-cube-container');
                mainCamera.aspect = container.clientWidth / container.clientHeight;
                mainCamera.updateProjectionMatrix();
                mainRenderer.setSize(container.clientWidth, container.clientHeight);
            }
        });

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
