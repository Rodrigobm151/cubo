<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rubik Solver - Captura</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            touch-action: none;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .app-header {
            position: fixed;
            top: env(safe-area-inset-top);
            left: 0; right: 0;
            height: 50px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .header-title {
            font-size: 18px;
            font-weight: 700;
            text-align: center;
        }
        
        .header-subtitle {
            position: absolute;
            right: 16px;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
        }
        
        .restart-btn {
            position: absolute;
            left: 16px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 18px;
            cursor: pointer;
        }
        
        .main-container {
            position: fixed;
            top: calc(env(safe-area-inset-top) + 50px);
            left: 0; right: 0;
            bottom: env(safe-area-inset-bottom);
            display: flex;
            flex-direction: column;
        }
        
        .camera-area {
            position: relative;
            flex: 1;
            background: #0a0a0a;
            overflow: hidden;
        }
        
        #video {
            position: absolute;
            inset: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            display: none;
        }
        
        .camera-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
            z-index: 5;
        }
        
        .start-btn {
            width: 80px; height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border: 4px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 32px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(34,197,94,0.5);
            animation: pulse-btn 2s infinite;
        }
        
        @keyframes pulse-btn {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .scan-overlay {
            position: absolute;
            inset: 0;
            display: none;
        }
        
        .scan-grid {
            position: absolute;
            top: 42%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(260px, 65vw);
            height: min(260px, 65vw);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            padding: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 16px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .scan-cell {
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.4);
            background: rgba(255,255,255,0.05);
            transition: all 0.2s;
            position: relative;
        }
        
        .scan-cell.detected {
            border-color: #22c55e;
            box-shadow: 0 0 15px rgba(34,197,94,0.3);
        }
        
        .scan-cell.center {
            border-width: 3px;
            border-color: #ef4444;
        }
        
        .scan-cell.center.valid {
            border-color: #22c55e;
        }
        
        /* Cubo 3D preview */
        .cube-preview-container {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 140px;
            height: 140px;
            background: rgba(0,0,0,0.7);
            border-radius: 16px;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 20;
            overflow: hidden;
        }
        
        .cube-label {
            position: absolute;
            top: 8px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: rgba(255,255,255,0.8);
            z-index: 25;
        }
        
        #cube-3d-mini {
            width: 100%;
            height: 100%;
        }
        
        .progress-sidebar {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }
        
        .progress-item {
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0.3;
            transition: all 0.3s;
        }
        
        .progress-item.active {
            opacity: 1;
            transform: scale(1.05);
        }
        
        .progress-item.done {
            opacity: 0.9;
        }
        
        .progress-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
        }
        
        .progress-item.active .progress-dot {
            box-shadow: 0 0 12px currentColor;
            border-color: white;
        }
        
        .progress-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-bar {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 20;
            width: 90%;
            max-width: 400px;
        }
        
        .status-text {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.9);
            min-height: 24px;
        }
        
        .stability-container {
            background: rgba(0,0,0,0.6);
            padding: 10px 16px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        .stability-timer {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .stability-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .action-buttons {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 12px;
            z-index: 20;
        }
        
        .action-btn {
            height: 50px;
            border-radius: 25px;
            border: none;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 0 20px;
        }
        
        .action-btn.primary {
            background: #22c55e;
            display: none;
        }
        
        .action-btn:disabled {
            opacity: 0.3;
        }
        
        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <div class="app-header">
        <button class="restart-btn" onclick="restartAll()" title="Reiniciar">â†»</button>
        <div class="header-title" id="header-title">Mostre a face VERDE</div>
        <div class="header-subtitle" id="face-counter">1/6</div>
    </div>

    <div class="main-container">
        <div class="camera-area">
            <video id="video" autoplay playsinline muted></video>
            
            <div class="camera-placeholder" id="camera-placeholder">
                <button class="start-btn" onclick="startCamera()">ðŸ“·</button>
                <p style="color: rgba(255,255,255,0.7); font-size: 14px;">Toque para iniciar a cÃ¢mera</p>
            </div>
            
            <div class="scan-overlay" id="scan-overlay">
                <!-- Progresso lateral -->
                <div class="progress-sidebar" id="progress-sidebar">
                    <div class="progress-item active" data-face="F" style="color: #00FF00;">
                        <div class="progress-dot" style="background: #00FF00;"></div>
                        <span class="progress-label">Frente</span>
                    </div>
                    <div class="progress-item" data-face="R" style="color: #FF0000;">
                        <div class="progress-dot" style="background: #FF0000;"></div>
                        <span class="progress-label">Direita</span>
                    </div>
                    <div class="progress-item" data-face="B" style="color: #4444ff;">
                        <div class="progress-dot" style="background: #0000FF;"></div>
                        <span class="progress-label">TrÃ¡s</span>
                    </div>
                    <div class="progress-item" data-face="L" style="color: #FFA500;">
                        <div class="progress-dot" style="background: #FFA500;"></div>
                        <span class="progress-label">Esquerda</span>
                    </div>
                    <div class="progress-item" data-face="U" style="color: #FFFFFF;">
                        <div class="progress-dot" style="background: #FFFFFF;"></div>
                        <span class="progress-label">Topo</span>
                    </div>
                    <div class="progress-item" data-face="D" style="color: #FFFF00;">
                        <div class="progress-dot" style="background: #FFFF00;"></div>
                        <span class="progress-label">Base</span>
                    </div>
                </div>
                
                <!-- Status -->
                <div class="status-bar">
                    <div class="status-text" id="status-text">Centralize o cubo na grade</div>
                    <div class="stability-container">
                        <div class="stability-timer">
                            <div class="stability-fill" id="stability-fill"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Grade de scan -->
                <div class="scan-grid" id="scan-grid">
                    <div class="scan-cell" id="scan-0"></div>
                    <div class="scan-cell" id="scan-1"></div>
                    <div class="scan-cell" id="scan-2"></div>
                    <div class="scan-cell" id="scan-3"></div>
                    <div class="scan-cell center" id="scan-4"></div>
                    <div class="scan-cell" id="scan-5"></div>
                    <div class="scan-cell" id="scan-6"></div>
                    <div class="scan-cell" id="scan-7"></div>
                    <div class="scan-cell" id="scan-8"></div>
                </div>
                
                <!-- Cubo 3D preview com label -->
                <div class="cube-preview-container">
                    <div class="cube-label" id="cube-label">Frente</div>
                    <div id="cube-3d-mini"></div>
                </div>
                
                <!-- BotÃµes -->
                <div class="action-buttons">
                    <button class="action-btn" onclick="skipFace()" id="skip-btn">Pular â†’</button>
                    <button class="action-btn primary" onclick="goToSolution()" id="solution-btn">Ver SoluÃ§Ã£o ðŸŽ¯</button>
                </div>
            </div>
            
            <input type="file" id="file-input" accept="image/*" capture="environment">
        </div>
    </div>

    <script>
        // Ordem: Frente(F) â†’ Direita(R) â†’ TrÃ¡s(B) â†’ Esquerda(L) â†’ Topo(U) â†’ Base(D)
        const SCAN_ORDER = [
            { code: 'F', name: 'VERDE', label: 'Frente', center: 'F', color: '#00FF00', rot: [0, 0] },
            { code: 'R', name: 'VERMELHA', label: 'Direita', center: 'R', color: '#FF0000', rot: [0, -Math.PI/2] },
            { code: 'B', name: 'AZUL', label: 'TrÃ¡s', center: 'B', color: '#0000FF', rot: [0, Math.PI] },
            { code: 'L', name: 'LARANJA', label: 'Esquerda', center: 'L', color: '#FFA500', rot: [0, Math.PI/2] },
            { code: 'U', name: 'BRANCA', label: 'Topo', center: 'U', color: '#FFFFFF', rot: [-Math.PI/2, 0] },
            { code: 'D', name: 'AMARELA', label: 'Base', center: 'D', color: '#FFFF00', rot: [Math.PI/2, 0] }
        ];
        
        const COLOR_MAP = {
            'U': 0xFFFFFF, 'R': 0xFF0000, 'F': 0x00FF00,
            'D': 0xFFFF00, 'L': 0xFFA500, 'B': 0x0000FF'
        };
        
        let currentStep = 0;
        let isScanning = false;
        let cubeState = {
            U: Array(9).fill(null), R: Array(9).fill(null), F: Array(9).fill(null),
            D: Array(9).fill(null), L: Array(9).fill(null), B: Array(9).fill(null)
        };
        
        // Sistema de estabilidade
        let lastColors = null;
        let stabilityStart = null;
        const STABILITY_TIME = 2000;
        let isStable = false;
        
        // Three.js
        let miniScene, miniCamera, miniRenderer, miniCube;
        let targetRotation = { x: 0, y: 0 };
        
        window.onload = () => {
            initMiniCube();
            updateUI();
        };
        
        function initMiniCube() {
            const container = document.getElementById('cube-3d-mini');
            
            miniScene = new THREE.Scene();
            miniScene.background = new THREE.Color(0x111111);
            
            miniCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            miniCamera.position.set(2.5, 2.5, 3.5);
            miniCamera.lookAt(0, 0, 0);
            
            miniRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            miniRenderer.setSize(140, 140);
            miniRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(miniRenderer.domElement);
            
            miniScene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const dir = new THREE.DirectionalLight(0xffffff, 0.7);
            dir.position.set(2, 3, 2);
            miniScene.add(dir);
            
            buildMiniCube();
            animateMini();
        }
        
        function buildMiniCube() {
            if (miniCube) miniScene.remove(miniCube);
            miniCube = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            // Cria 27 cubies (3x3x3)
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue;
                        
                        const materials = [];
                        
                        // Determina cor de cada face do cubie
                        // Direita (x=1) = R
                        materials.push(createMaterial(x === 1, 'R', x, y, z));
                        // Esquerda (x=-1) = L  
                        materials.push(createMaterial(x === -1, 'L', x, y, z));
                        // Topo (y=1) = U
                        materials.push(createMaterial(y === 1, 'U', x, y, z));
                        // Base (y=-1) = D
                        materials.push(createMaterial(y === -1, 'D', x, y, z));
                        // Frente (z=1) = F
                        materials.push(createMaterial(z === 1, 'F', x, y, z));
                        // TrÃ¡s (z=-1) = B
                        materials.push(createMaterial(z === -1, 'B', x, y, z));
                        
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(x, y, z);
                        
                        // Borda preta
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
                        cubie.add(line);
                        
                        miniCube.add(cubie);
                    }
                }
            }
            
            miniScene.add(miniCube);
            
            // Aplica rotaÃ§Ã£o alvo
            const current = SCAN_ORDER[currentStep];
            if (current) {
                targetRotation = { x: current.rot[0], y: current.rot[1] };
                miniCube.rotation.x = targetRotation.x;
                miniCube.rotation.y = targetRotation.y;
            }
        }
        
        function createMaterial(isSticker, faceCode, x, y, z) {
            if (!isSticker) {
                return new THREE.MeshLambertMaterial({ color: 0x111111 });
            }
            
            // Calcula Ã­ndice na face (0-8)
            let idx = 4; // centro por padrÃ£o
            
            switch(faceCode) {
                case 'U': idx = (1-y)*3 + (x+1); break;
                case 'D': idx = (y+1)*3 + (x+1); break;
                case 'R': idx = (1-y)*3 + (1-z); break;
                case 'L': idx = (1-y)*3 + (z+1); break;
                case 'F': idx = (1-y)*3 + (x+1); break;
                case 'B': idx = (1-y)*3 + (1-x); break;
            }
            
            idx = Math.max(0, Math.min(8, idx));
            
            // Se jÃ¡ temos dados para esta face, usa a cor detectada
            if (cubeState[faceCode] && cubeState[faceCode][idx]) {
                const detectedCode = cubeState[faceCode][idx];
                return new THREE.MeshLambertMaterial({ color: COLOR_MAP[detectedCode] || 0x333333 });
            }
            
            // SenÃ£o, usa cinza escuro (nÃ£o capturado ainda)
            return new THREE.MeshLambertMaterial({ color: 0x333333 });
        }
        
        function animateMini() {
            requestAnimationFrame(animateMini);
            miniRenderer.render(miniScene, miniCamera);
        }
        
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                video.style.display = 'block';
                
                document.getElementById('camera-placeholder').style.display = 'none';
                document.getElementById('scan-overlay').style.display = 'block';
                
                isScanning = true;
                resetStability();
                scanLoop();
                
            } catch (e) {
                alert('CÃ¢mera indisponÃ­vel');
            }
        }
        
        function scanLoop() {
            if (!isScanning || currentStep >= 6) return;
            
            const video = document.getElementById('video');
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                analyzeFrame(ctx, canvas.width, canvas.height);
            }
            
            requestAnimationFrame(scanLoop);
        }
        
        function analyzeFrame(ctx, w, h) {
            const cx = w / 2, cy = h / 2;
            const size = Math.min(w, h) * 0.5;
            const cellSize = size / 3;
            
            const colors = [];
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const x = cx - size/2 + c * cellSize + cellSize/2;
                    const y = cy - size/2 + r * cellSize + cellSize/2;
                    const p = getPixel(ctx, x, y);
                    colors.push(rgbToCode(p.r, p.g, p.b));
                }
            }
            
            const current = SCAN_ORDER[currentStep];
            const centerColor = colors[4];
            const isCorrectCenter = (centerColor === current.center);
            
            // Atualiza visual da grade
            updateScanGrid(colors, isCorrectCenter);
            
            if (!isCorrectCenter) {
                document.getElementById('status-text').textContent = `Ops! Centro Ã© ${colorName(centerColor)}, precisa ser ${current.name}`;
                document.getElementById('status-text').style.color = '#ef4444';
                resetStability();
                return;
            }
            
            document.getElementById('status-text').textContent = `${current.name} detectada! Mantenha estÃ¡vel...`;
            document.getElementById('status-text').style.color = '#22c55e';
            
            checkStability(colors);
        }
        
        function checkStability(colors) {
            const now = Date.now();
            
            if (!lastColors || !colorsEqual(colors, lastColors)) {
                lastColors = [...colors];
                stabilityStart = now;
                isStable = false;
                updateStabilityBar(0);
                return;
            }
            
            const elapsed = now - stabilityStart;
            const progress = Math.min(elapsed / STABILITY_TIME, 1);
            updateStabilityBar(progress * 100);
            
            if (elapsed >= STABILITY_TIME && !isStable) {
                isStable = true;
                onStableDetection(colors);
            }
        }
        
        function onStableDetection(colors) {
            const current = SCAN_ORDER[currentStep];
            
            // Salva as 9 cores detectadas
            cubeState[current.code] = [...colors];
            
            // Feedback
            navigator.vibrate?.([50, 100, 50]);
            
            // Atualiza cubo 3D imediatamente com as cores reais
            buildMiniCube();
            
            // Flash visual na grade
            document.querySelectorAll('.scan-cell').forEach(cell => {
                cell.style.transform = 'scale(0.95)';
                setTimeout(() => cell.style.transform = 'scale(1)', 150);
            });
            
            // PrÃ³xima face
            setTimeout(() => {
                nextFace();
            }, 500);
        }
        
        function nextFace() {
            currentStep++;
            resetStability();
            lastColors = null;
            
            if (currentStep >= 6) {
                finishCapture();
            } else {
                updateUI();
                buildMiniCube(); // ReconstrÃ³i com nova rotaÃ§Ã£o
            }
        }
        
        function skipFace() {
            const current = SCAN_ORDER[currentStep];
            cubeState[current.code] = Array(9).fill(current.center);
            nextFace();
        }
        
        function finishCapture() {
            isScanning = false;
            document.getElementById('status-text').textContent = 'âœ“ Todas as faces capturadas!';
            document.getElementById('stability-fill').style.width = '100%';
            document.getElementById('skip-btn').style.display = 'none';
            document.getElementById('solution-btn').style.display = 'block';
            
            localStorage.setItem('rubikState', JSON.stringify(cubeState));
        }
        
        function goToSolution() {
            window.location.href = 'solution.html';
        }
        
        function restartAll() {
            if (confirm('Reiniciar tudo? As faces capturadas serÃ£o perdidas.')) {
                currentStep = 0;
                cubeState = {
                    U: Array(9).fill(null), R: Array(9).fill(null), F: Array(9).fill(null),
                    D: Array(9).fill(null), L: Array(9).fill(null), B: Array(9).fill(null)
                };
                resetStability();
                lastColors = null;
                
                // Para cÃ¢mera se estiver rodando
                const video = document.getElementById('video');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(t => t.stop());
                    video.srcObject = null;
                }
                video.style.display = 'none';
                
                document.getElementById('scan-overlay').style.display = 'none';
                document.getElementById('camera-placeholder').style.display = 'flex';
                document.getElementById('skip-btn').style.display = 'block';
                document.getElementById('solution-btn').style.display = 'none';
                
                updateUI();
                buildMiniCube();
            }
        }
        
        function updateUI() {
            const current = SCAN_ORDER[currentStep];
            document.getElementById('header-title').textContent = `Mostre a face ${current.name}`;
            document.getElementById('face-counter').textContent = `${currentStep + 1}/6`;
            document.getElementById('cube-label').textContent = current.label;
            
            // Atualiza sidebar
            document.querySelectorAll('.progress-item').forEach((item, idx) => {
                item.classList.remove('active', 'done');
                if (idx < currentStep) item.classList.add('done');
                else if (idx === currentStep) item.classList.add('active');
            });
        }
        
        function updateScanGrid(colors, isValid) {
            colors.forEach((code, i) => {
                const cell = document.getElementById(`scan-${i}`);
                const colorHex = COLOR_MAP[code] ? '#' + COLOR_MAP[code].toString(16).padStart(6, '0') : '#334155';
                cell.style.backgroundColor = colorHex;
                cell.style.opacity = '0.9';
                
                if (isValid) {
                    cell.classList.add('detected');
                } else {
                    cell.classList.remove('detected');
                }
                
                // Centro especial
                if (i === 4) {
                    cell.classList.toggle('valid', isValid);
                }
            });
        }
        
        function updateStabilityBar(percent) {
            document.getElementById('stability-fill').style.width = percent + '%';
        }
        
        function resetStability() {
            stabilityStart = null;
            isStable = false;
            updateStabilityBar(0);
        }
        
        function colorsEqual(a, b) {
            return a.every((v, i) => v === b[i]);
        }
        
        function colorName(code) {
            const names = { U: 'BRANCO', R: 'VERMELHO', F: 'VERDE', D: 'AMARELO', L: 'LARANJA', B: 'AZUL' };
            return names[code] || code;
        }
        
        function getPixel(ctx, x, y) {
            const d = ctx.getImageData(Math.max(0,x-10), Math.max(0,y-10), 20, 20).data;
            let r=0,g=0,b=0,n=0;
            for (let i=0; i<d.length; i+=4) { r+=d[i]; g+=d[i+1]; b+=d[i+2]; n++; }
            return {r:r/n, g:g/n, b:b/n};
        }
        
        function rgbToCode(r,g,b) {
            const [h,s,v] = rgbToHsv(r,g,b);
            if (v > 0.75 && s < 0.3) return 'U';
            if (h > 50 && h < 80 && s > 0.4) return 'D';
            if (h > 15 && h < 45 && s > 0.5) return 'L';
            if ((h < 20 || h > 340) && s > 0.4) return 'R';
            if (h > 85 && h < 160 && s > 0.3) return 'F';
            if (h > 200 && h < 270 && s > 0.4) return 'B';
            return v > 0.6 ? 'U' : 'F';
        }
        
        function rgbToHsv(r,g,b) {
            r/=255; g/=255; b/=255;
            const max=Math.max(r,g,b), min=Math.min(r,g,b);
            let h=0,s=0,v=max;
            const d=max-min;
            s=max===0?0:d/max;
            if(max!==min) {
                switch(max) {
                    case r: h=(g-b)/d+(g<b?6:0); break;
                    case g: h=(b-r)/d+2; break;
                    case b: h=(r-g)/d+4; break;
                }
                h/=6;
            }
            return [h*360,s,v];
        }
    </script>
</body>
</html>
