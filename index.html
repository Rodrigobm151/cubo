<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Smart Rubik Capture</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --error: #ff3b30; --success: #4cd964; --accent: #007aff; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: sans-serif; }
        
        #scanner-view { position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; }
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 1; }

        /* Grade que muda de cor */
        #overlay { 
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            width: 260px; height: 260px; display: grid; grid-template-columns: repeat(3, 1fr);
            border: 5px solid var(--error); border-radius: 15px; z-index: 10;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        #overlay.valid { border-color: var(--success); box-shadow: 0 0 20px var(--success); }

        .grid-cell { border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,0.5); }
        .center-dot { width: 15px; height: 15px; border: 2px solid #fff; opacity: 1; }

        /* Status e Instruções */
        #status-bar { 
            position: absolute; top: 0; width: 100%; padding: 40px 0 20px;
            background: linear-gradient(rgba(0,0,0,0.8), transparent); color: white;
            text-align: center; z-index: 20;
        }
        .timer-bar { position: absolute; bottom: 0; left: 0; height: 4px; background: var(--success); width: 0%; transition: width 0.1s linear; }

        #preview-pane { position: absolute; top: 20px; right: 20px; width: 100px; height: 100px; background: rgba(0,0,0,0.5); border-radius: 10px; z-index: 30; border: 1px solid #444; }

        .btn-panel { position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 40; }
        .confirm-btn { padding: 15px 40px; border-radius: 30px; border: none; background: white; color: black; font-weight: bold; display: none; }
    </style>
</head>
<body>

    <div id="scanner-view">
        <video id="webcam" autoplay playsinline></video>
        
        <div id="status-bar">
            <div id="instruction">Alinhe a Face <b id="face-target">FRENTE (Verde)</b></div>
            <div id="progress-text">Face 1 de 6</div>
            <div class="timer-bar" id="timer"></div>
        </div>

        <div id="overlay">
            <div class="grid-cell"><div class="dot"></div></div><div class="grid-cell"><div class="dot"></div></div><div class="grid-cell"><div class="dot"></div></div>
            <div class="grid-cell"><div class="dot"></div></div><div class="grid-cell"><div class="dot center-dot" id="center-sensor"></div></div><div class="grid-cell"><div class="dot"></div></div>
            <div class="grid-cell"><div class="dot"></div></div><div class="grid-cell"><div class="dot"></div></div><div class="grid-cell"><div class="dot"></div></div>
        </div>

        <div id="preview-pane"></div>

        <div class="btn-panel">
            <button id="confirm-btn" class="confirm-btn" onclick="nextFace()">CONFIRMAR E CONTINUAR</button>
        </div>
    </div>

    <script>
        // Ordem: Frente (F), Direita (R), Trás (B), Esquerda (L), Topo (U), Base (D)
        const sequence = [
            { id: 'F', name: 'FRENTE (Verde)', color: [0, 155, 72], hex: 0x009b48 },
            { id: 'R', name: 'DIREITA (Vermelho)', color: [183, 18, 52], hex: 0xb71234 },
            { id: 'B', name: 'TRÁS (Azul)', color: [0, 70, 173], hex: 0x0046ad },
            { id: 'L', name: 'ESQUERDA (Laranja)', color: [255, 88, 0], hex: 0xff5800 },
            { id: 'U', name: 'TOPO (Branco)', color: [255, 255, 255], hex: 0xffffff },
            { id: 'D', name: 'BASE (Amarelo)', color: [255, 215, 0], hex: 0xffd700 }
        ];

        let currentIdx = 0;
        let isValidating = false;
        let captureTimer = null;
        let lastCapturedColors = [];

        // Three.js Preview
        let scene, camera, renderer, miniCube;

        async function init() {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            document.getElementById('webcam').srcObject = stream;
            
            init3D();
            requestAnimationFrame(processFrame);
        }

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, 1, 0.1, 10);
            camera.position.set(2, 2, 2);
            camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(100, 100);
            document.getElementById('preview-pane').appendChild(renderer.domElement);
            
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            miniCube = new THREE.Mesh(geo, mat);
            scene.add(miniCube);
            scene.add(new THREE.AmbientLight(0xffffff, 1));
            animate3D();
        }

        function processFrame() {
            const video = document.getElementById('webcam');
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);

                // Analisa apenas o centro para validar
                const overlay = document.getElementById('overlay').getBoundingClientRect();
                const videoBox = video.getBoundingClientRect();
                
                const centerX = (overlay.left + overlay.width/2 - videoBox.left) * (canvas.width / videoBox.width);
                const centerY = (overlay.top + overlay.height/2 - videoBox.top) * (canvas.height / videoBox.height);
                
                const pixel = ctx.getImageData(centerX, centerY, 1, 1).data;
                const detectedColor = [pixel[0], pixel[1], pixel[2]];
                
                checkMatch(detectedColor, canvas, ctx);
            }
            requestAnimationFrame(processFrame);
        }

        function checkMatch(rgb, canvas, ctx) {
            const target = sequence[currentIdx].color;
            // Distância Euclidiana de cor simplificada
            const dist = Math.sqrt(
                Math.pow(rgb[0] - target[0], 2) + 
                Math.pow(rgb[1] - target[1], 2) + 
                Math.pow(rgb[2] - target[2], 2)
            );

            const overlay = document.getElementById('overlay');
            const timerBar = document.getElementById('timer');

            if (dist < 80) { // Limiar de tolerância
                if (!isValidating) {
                    isValidating = true;
                    overlay.classList.add('valid');
                    startAutoCapture(canvas, ctx);
                }
            } else {
                isValidating = false;
                overlay.classList.remove('valid');
                clearTimeout(captureTimer);
                timerBar.style.width = '0%';
            }
        }

        function startAutoCapture(canvas, ctx) {
            let start = Date.now();
            const duration = 1000;
            
            const updateBar = () => {
                if (!isValidating) return;
                let elapsed = Date.now() - start;
                document.getElementById('timer').style.width = (elapsed / duration * 100) + '%';
                
                if (elapsed < duration) {
                    requestAnimationFrame(updateBar);
                } else {
                    performCapture();
                }
            };
            updateBar();
        }

        function performCapture() {
            // Vibração de feedback (se suportado)
            if (navigator.vibrate) navigator.vibrate(50);
            
            // Aqui as cores seriam extraídas de todos os 9 pontos
            // Para visualização, vamos pintar o miniCube com a cor da face detectada
            miniCube.material.color.setHex(sequence[currentIdx].hex);
            
            document.getElementById('confirm-btn').style.display = 'inline-block';
            document.getElementById('overlay').style.borderColor = 'gold';
            isValidating = false; 
        }

        function nextFace() {
            currentIdx++;
            if (currentIdx < sequence.length) {
                document.getElementById('face-target').innerText = sequence[currentIdx].name;
                document.getElementById('progress-text').innerText = `Face ${currentIdx + 1} de 6`;
                document.getElementById('confirm-btn').style.display = 'none';
                document.getElementById('timer').style.width = '0%';
                miniCube.material.color.setHex(0x333333); // Reseta preview
            } else {
                alert("Todas as faces capturadas com sucesso!");
            }
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            miniCube.rotation.y += 0.01;
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
