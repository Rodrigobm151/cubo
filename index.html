<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cubo Mágico - Solver Kociemba</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Kociemba Solver -->
    <script src="https://cdn.jsdelivr.net/npm/cube-solver@2.4.1/dist/bundle.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            overflow: hidden;
            background: #111827;
        }
        
        .cube-container {
            width: 100vw;
            height: 55vh;
            position: relative;
        }
        
        .color-btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            border: 3px solid transparent;
        }
        
        .color-btn:active {
            transform: scale(0.9);
        }
        
        .color-btn.selected {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3), 0 8px 25px rgba(0,0,0,0.5);
        }
        
        .face-btn {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(75, 85, 99, 0.5);
            transition: all 0.3s ease;
            font-weight: 800;
            letter-spacing: 0.05em;
        }
        
        .face-btn.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.8);
            color: #60A5FA;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        .move-text {
            font-variant-numeric: tabular-nums;
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.2); }
            50% { box-shadow: 0 0 40px rgba(59, 130, 246, 0.5); }
        }
        
        .solving {
            animation: pulse-glow 2s infinite;
        }
        
        .moves-list::-webkit-scrollbar {
            height: 6px;
        }
        .moves-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
        }
        .moves-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        
        .sticker {
            cursor: pointer;
            transition: filter 0.2s;
        }
        .sticker:hover {
            filter: brightness(1.2);
        }
        
        .loading-overlay {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
        }
        
        .progress-bar {
            background: linear-gradient(90deg, #3B82F6 0%, #60A5FA 100%);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay fixed inset-0 z-50 flex flex-col items-center justify-center">
        <div class="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <h2 class="text-xl font-bold mb-2">Inicializando Solver Kociemba</h2>
        <p class="text-gray-400 text-sm">Gerando tabelas de pruning (pode levar 2-5 segundos)...</p>
        <div class="w-64 h-2 bg-gray-700 rounded-full mt-4 overflow-hidden">
            <div id="progress-bar" class="progress-bar h-full w-0 transition-all duration-300"></div>
        </div>
    </div>

    <!-- Header -->
    <div class="px-4 pt-3 pb-2 flex justify-between items-center bg-gray-800/80 backdrop-blur-md border-b border-gray-700">
        <div>
            <h1 class="text-lg font-bold tracking-tight text-white">Cubo Kociemba</h1>
            <p class="text-xs text-gray-400 mt-0.5">Two-Phase Algorithm</p>
        </div>
        <div class="flex gap-2">
            <button onclick="resetCube()" class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-xs font-bold transition-colors border border-gray-600">
                Limpar
            </button>
            <button onclick="randomizeCube()" class="px-3 py-1.5 bg-purple-600 hover:bg-purple-500 rounded-lg text-xs font-bold transition-colors">
                Aleatório
            </button>
        </div>
    </div>

    <!-- 3D Cube View -->
    <div class="cube-container relative" id="canvas-container">
        <div class="absolute top-4 left-4 bg-black/50 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-mono text-gray-300 border border-gray-700">
            <span id="status-text">Pronto para colorir</span>
        </div>
    </div>

    <!-- Face Selector -->
    <div class="px-3 py-2 bg-gray-800/50 backdrop-blur-sm">
        <div class="flex justify-center gap-1.5 mb-2 flex-wrap">
            <button onclick="selectFace('U')" id="btn-U" class="face-btn px-3 py-2 rounded-xl text-xs">UP</button>
            <button onclick="selectFace('D')" id="btn-D" class="face-btn px-3 py-2 rounded-xl text-xs">DOWN</button>
            <button onclick="selectFace('F')" id="btn-F" class="face-btn px-3 py-2 rounded-xl text-xs active">FRONT</button>
            <button onclick="selectFace('B')" id="btn-B" class="face-btn px-3 py-2 rounded-xl text-xs">BACK</button>
            <button onclick="selectFace('L')" id="btn-L" class="face-btn px-3 py-2 rounded-xl text-xs">LEFT</button>
            <button onclick="selectFace('R')" id="btn-R" class="face-btn px-3 py-2 rounded-xl text-xs">RIGHT</button>
        </div>
        
        <p class="text-center text-xs text-gray-400 font-medium" id="instruction-text">
            Toque nos quadrados para colorir a face FRONT
        </p>
    </div>

    <!-- Color Palette -->
    <div class="flex-1 px-3 py-3 bg-gray-800/80 backdrop-blur-md flex flex-col">
        <div class="flex justify-center gap-2 mb-3 flex-wrap">
            <button onclick="selectColor('white')" id="color-white" class="color-btn w-10 h-10 rounded-xl bg-gray-100" title="Branco"></button>
            <button onclick="selectColor('yellow')" id="color-yellow" class="color-btn w-10 h-10 rounded-xl bg-yellow-400" title="Amarelo"></button>
            <button onclick="selectColor('red')" id="color-red" class="color-btn w-10 h-10 rounded-xl bg-red-500" title="Vermelho"></button>
            <button onclick="selectColor('orange')" id="color-orange" class="color-btn w-10 h-10 rounded-xl bg-orange-500" title="Laranja"></button>
            <button onclick="selectColor('blue')" id="color-blue" class="color-btn w-10 h-10 rounded-xl bg-blue-500" title="Azul"></button>
            <button onclick="selectColor('green')" id="color-green" class="color-btn w-10 h-10 rounded-xl bg-green-500" title="Verde"></button>
        </div>

        <!-- Action Buttons -->
        <div class="flex gap-2 mb-3">
            <button onclick="validateAndSolve()" id="solve-btn" class="flex-1 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 py-3 rounded-xl font-bold text-sm shadow-lg transform transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                Resolver com Kociemba
            </button>
        </div>

        <!-- Solution Display -->
        <div id="solution-panel" class="hidden flex-1 bg-gray-900/90 rounded-xl p-3 border border-gray-700 flex flex-col">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-bold text-gray-300 uppercase tracking-wider">Solução Ótima</span>
                <div class="flex gap-1.5">
                    <button onclick="prevMove()" class="w-7 h-7 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center text-xs font-bold transition-colors">←</button>
                    <button onclick="togglePlay()" id="play-btn" class="w-7 h-7 bg-green-600 hover:bg-green-500 rounded-lg flex items-center justify-center text-xs font-bold transition-colors">▶</button>
                    <button onclick="nextMove()" class="w-7 h-7 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center text-xs font-bold transition-colors">→</button>
                </div>
            </div>
            <div class="moves-list flex gap-1.5 overflow-x-auto pb-2 text-xs font-mono mb-2" id="moves-display">
                <!-- Moves will be inserted here -->
            </div>
            <div class="flex justify-between items-center text-xs text-gray-500 font-mono">
                <span id="move-counter">Passo 0/0</span>
                <span id="move-notation" class="text-blue-400 font-bold text-sm"></span>
            </div>
        </div>
    </div>

    <script>
        // Three.js Setup
        let scene, camera, renderer;
        let cubeGroup;
        let stickers = [];
        let raycaster, mouse;
        
        // Cube State - Mapeamento de cores para o solver
        const faceOrder = ['U', 'R', 'F', 'D', 'L', 'B']; // Ordem do Kociemba
        const colorMap = {
            'white': 'U', 'yellow': 'D', 'red': 'R', 
            'orange': 'L', 'blue': 'F', 'green': 'B',
            'gray': 'X'
        };
        
        const colors = {
            'white': 0xFFFFFF, 'yellow': 0xFFD500, 'red': 0xDC2626,
            'orange': 0xF97316, 'blue': 0x2563EB, 'green': 0x16A34A,
            'gray': 0x374151
        };
        
        let currentFace = 'F';
        let selectedColor = 'white';
        let cubeState = {};
        let solution = [];
        let currentMoveIndex = 0;
        let isPlaying = false;
        let isSolverReady = false;
        let playInterval = null;

        // Inicializar estado do cubo
        faces.forEach(face => {
            cubeState[face] = Array(9).fill('gray');
        });

        // Inicializar solver
        async function initSolver() {
            try {
                updateProgress(30);
                // O cube-solver expõe uma API global
                if (typeof cubeSolver !== 'undefined') {
                    await cubeSolver.initialize('kociemba');
                    updateProgress(100);
                    setTimeout(() => {
                        document.getElementById('loading-overlay').style.display = 'none';
                        isSolverReady = true;
                    }, 500);
                } else {
                    throw new Error('Solver não carregado');
                }
            } catch (e) {
                console.error('Erro ao inicializar solver:', e);
                document.querySelector('#loading-overlay h2').textContent = 'Erro ao carregar solver';
                document.querySelector('#loading-overlay p').textContent = 'Recarregue a página ou verifique sua conexão.';
            }
        }

        function updateProgress(percent) {
            document.getElementById('progress-bar').style.width = percent + '%';
        }

        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 13);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            // Iluminação dramática
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 7);
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0x4B5563, 0.5);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0x60A5FA, 0.3);
            rimLight.position.set(0, -5, 5);
            scene.add(rimLight);
            
            createCube();
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Eventos de interação
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('touchstart', onTouchStart, {passive: false});
            
            // Controles de rotação manual
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };
                    
                    cubeGroup.rotation.y += deltaMove.x * 0.01;
                    cubeGroup.rotation.x += deltaMove.y * 0.01;
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => isDragging = false);
            
            animate();
            window.addEventListener('resize', onWindowResize);
            
            // Iniciar solver
            initSolver();
        }

        function createCube() {
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            // Criar cubies 3x3x3
            const geometry = new THREE.BoxGeometry(0.92, 0.92, 0.92);
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            
            for(let x = -1; x <= 1; x++) {
                for(let y = -1; y <= 1; y++) {
                    for(let z = -1; z <= 1; z++) {
                        if(x === 0 && y === 0 && z === 0) continue;
                        
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0x1F2937,
                            shininess: 80,
                            specular: 0x374151
                        });
                        
                        const cubie = new THREE.Mesh(geometry, material);
                        cubie.position.set(x * 1.02, y * 1.02, z * 1.02);
                        cubie.castShadow = true;
                        cubie.receiveShadow = true;
                        
                        // Bordas estilizadas
                        const edges = new THREE.LineSegments(
                            edgesGeometry, 
                            new THREE.LineBasicMaterial({ color: 0x111827, linewidth: 3 })
                        );
                        cubie.add(edges);
                        
                        // Adicionar stickers nas faces externas
                        const stickerSize = 0.75;
                        const stickerGeo = new THREE.PlaneGeometry(stickerSize, stickerSize);
                        
                        // Mapeamento de faces
                        if(z === 1) createSticker(cubie, stickerGeo, 'F', 0, 0, 0.47, 0, 0, 0, x, y);
                        if(z === -1) createSticker(cubie, stickerGeo, 'B', 0, 0, -0.47, 0, Math.PI, 0, -x, y);
                        if(y === 1) createSticker(cubie, stickerGeo, 'U', 0, 0.47, 0, -Math.PI/2, 0, 0, x, -z);
                        if(y === -1) createSticker(cubie, stickerGeo, 'D', 0, -0.47, 0, Math.PI/2, 0, 0, x, z);
                        if(x === -1) createSticker(cubie, stickerGeo, 'L', -0.47, 0, 0, 0, -Math.PI/2, 0, -z, y);
                        if(x === 1) createSticker(cubie, stickerGeo, 'R', 0.47, 0, 0, 0, Math.PI/2, 0, z, y);
                        
                        cubeGroup.add(cubie);
                    }
                }
            }
        }

        function createSticker(parent, geo, face, x, y, z, rx, ry, rz, posX, posY) {
            const material = new THREE.MeshPhongMaterial({ 
                color: colors.gray,
                shininess: 120,
                specular: 0x666666,
                emissive: 0x000000,
                emissiveIntensity: 0.1
            });
            
            const sticker = new THREE.Mesh(geo, material);
            sticker.position.set(x, y, z);
            sticker.rotation.set(rx, ry, rz);
            
            // Calcular índice na face (0-8)
            let index;
            if(face === 'F' || face === 'B') {
                index = (1 - posY) * 3 + (posX + 1);
            } else if(face === 'U' || face === 'D') {
                index = (1 - posY) * 3 + (posX + 1);
            } else {
                index = (1 - posY) * 3 + (posX + 1);
            }
            
            sticker.userData = { face: face, index: Math.floor(index), isSticker: true };
            parent.add(sticker);
            stickers.push(sticker);
        }

        function updateCubeColors() {
            stickers.forEach(sticker => {
                const face = sticker.userData.face;
                const index = sticker.userData.index;
                const colorName = cubeState[face][index];
                
                if(colors[colorName]) {
                    sticker.material.color.setHex(colors[colorName]);
                    sticker.material.emissive.setHex(colors[colorName]);
                    sticker.material.emissiveIntensity = colorName === 'gray' ? 0 : 0.15;
                }
            });
        }

        function onPointerDown(event) {
            event.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            handleInteraction();
        }

        function onTouchStart(event) {
            event.preventDefault();
            if(event.touches.length > 0) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
                handleInteraction();
            }
        }

        function handleInteraction() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(stickers);
            
            if(intersects.length > 0) {
                const sticker = intersects[0].object;
                if(!sticker.userData.isSticker) return;
                
                const face = sticker.userData.face;
                const index = sticker.userData.index;
                
                // Se clicou em outra face, muda para ela
                if(face !== currentFace) {
                    selectFace(face);
                }
                
                // Aplica cor
                cubeState[face][index] = selectedColor;
                updateCubeColors();
                
                // Feedback visual
                sticker.scale.set(0.9, 0.9, 0.9);
                setTimeout(() => {
                    sticker.scale.set(1, 1, 1);
                }, 100);
            }
        }

        function selectFace(face) {
            currentFace = face;
            
            // Atualizar UI
            document.querySelectorAll('.face-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`btn-${face}`).classList.add('active');
            
            const faceNames = {U: 'UP (Branco)', D: 'DOWN (Amarelo)', F: 'FRONT (Azul)', 
                             B: 'BACK (Verde)', L: 'LEFT (Laranja)', R: 'RIGHT (Vermelho)'};
            document.getElementById('instruction-text').textContent = 
                `Toque para colorir: ${faceNames[face]}`;
            
            // Rotação suave para mostrar a face
            const targetRotations = {
                'F': {x: 0, y: 0},
                'B': {x: 0, y: Math.PI},
                'U': {x: -Math.PI/2, y: 0},
                'D': {x: Math.PI/2, y: 0},
                'L': {x: 0, y: -Math.PI/2},
                'R': {x: 0, y: Math.PI/2}
            };
            
            const target = targetRotations[face];
            const start = {x: cubeGroup.rotation.x, y: cubeGroup.rotation.y};
            const startTime = Date.now();
            const duration = 600;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 4);
                
                cubeGroup.rotation.x = start.x + (target.x - start.x) * ease;
                cubeGroup.rotation.y = start.y + (target.y - start.y) * ease;
                
                if(progress < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function selectColor(color) {
            selectedColor = color;
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.getElementById(`color-${color}`).classList.add('selected');
        }

        function resetCube() {
            faces.forEach(face => {
                cubeState[face] = Array(9).fill('gray');
            });
            updateCubeColors();
            hideSolution();
            updateStatus('Cubo resetado. Comece a colorir!');
        }

        function randomizeCube() {
            const colorList = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];
            faces.forEach(face => {
                // Garantir que cada face tenha 9 stickers da mesma cor (cubo válido)
                const faceColor = colorList[Math.floor(Math.random() * colorList.length)];
                cubeState[face] = Array(9).fill(faceColor);
            });
            updateCubeColors();
            updateStatus('Cubo aleatório gerado!');
        }

        function getFaceletString() {
            // Converter estado do cubo para string de facelets (ordem Kociemba: URFDLB)
            let faceletStr = '';
            
            // Mapeamento correto de posições
            const faceMapping = {
                'U': cubeState['U'],
                'R': cubeState['R'],
                'F': cubeState['F'],
                'D': cubeState['D'],
                'L': cubeState['L'],
                'B': cubeState['B']
            };
            
            // Ordem das faces: U R F D L B
            const order = ['U', 'R', 'F', 'D', 'L', 'B'];
            
            order.forEach(face => {
                faceMapping[face].forEach(color => {
                    faceletStr += colorMap[color] || 'X';
                });
            });
            
            return faceletStr;
        }

        function validateCube() {
            // Verificar se todas as faces estão completamente coloridas
            for(let face of faces) {
                for(let i = 0; i < 9; i++) {
                    if(cubeState[face][i] === 'gray') {
                        return {valid: false, message: `Face ${face} não está completa!`};
                    }
                }
            }
            
            // Verificar se tem exatamente 9 de cada cor
            const colorCount = {};
            faces.forEach(face => {
                cubeState[face].forEach(color => {
                    colorCount[color] = (colorCount[color] || 0) + 1;
                });
            });
            
            const expectedColors = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];
            for(let color of expectedColors) {
                if(colorCount[color] !== 9) {
                    return {valid: false, message: `Quantidade incorreta da cor ${color}!`};
                }
            }
            
            return {valid: true};
        }

        async function validateAndSolve() {
            if(!isSolverReady) {
                alert('Solver ainda está inicializando. Aguarde...');
                return;
            }
            
            const validation = validateCube();
            if(!validation.valid) {
                alert(validation.message);
                return;
            }
            
            const faceletStr = getFaceletString();
            console.log('Facelet string:', faceletStr);
            
            updateStatus('Resolvendo com Kociemba...');
            document.getElementById('solve-btn').disabled = true;
            document.getElementById('solve-btn').textContent = 'Resolvendo...';
            
            try {
                // Usar o solver Kociemba
                const result = await cubeSolver.solve(faceletStr, 'kociemba');
                
                if(result && result.length > 0) {
                    solution = result.split(' ').filter(m => m.length > 0);
                    currentMoveIndex = 0;
                    displaySolution();
                    updateStatus(`Solução encontrada: ${solution.length} movimentos`);
                } else {
                    throw new Error('Solução vazia');
                }
            } catch (error) {
                console.error('Erro ao resolver:', error);
                alert('Erro ao resolver o cubo. Verifique se as cores estão corretas.');
                updateStatus('Erro na solução');
            } finally {
                document.getElementById('solve-btn').disabled = false;
                document.getElementById('solve-btn').textContent = 'Resolver com Kociemba';
            }
        }

        function displaySolution() {
            const panel = document.getElementById('solution-panel');
            panel.classList.remove('hidden');
            
            const container = document.getElementById('moves-display');
            container.innerHTML = '';
            
            solution.forEach((move, idx) => {
                const span = document.createElement('span');
                span.className = `move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all ${idx === 0 ? 'bg-blue-500 text-white scale-110' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`;
                span.textContent = move;
                span.onclick = () => jumpToMove(idx);
                container.appendChild(span);
            });
            
            updateMoveInfo();
            scrollToCurrentMove();
        }

        function hideSolution() {
            document.getElementById('solution-panel').classList.add('hidden');
            solution = [];
            currentMoveIndex = 0;
            if(playInterval) clearInterval(playInterval);
            isPlaying = false;
            updatePlayButton();
        }

        function updateMoveInfo() {
            document.getElementById('move-counter').textContent = `Passo ${currentMoveIndex + 1}/${solution.length}`;
            document.getElementById('move-notation').textContent = solution[currentMoveIndex] || '';
        }

        function scrollToCurrentMove() {
            const moves = document.getElementById('moves-display').children;
            if(moves[currentMoveIndex]) {
                moves[currentMoveIndex].scrollIntoView({behavior: 'smooth', inline: 'center', block: 'nearest'});
            }
        }

        function highlightCurrentMove() {
            const moves = document.getElementById('moves-display').children;
            Array.from(moves).forEach((move, idx) => {
                if(idx === currentMoveIndex) {
                    move.className = 'move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-blue-500 text-white scale-110';
                } else if(idx < currentMoveIndex) {
                    move.className = 'move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-green-600/50 text-green-200';
                } else {
                    move.className = 'move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';
                }
            });
            scrollToCurrentMove();
            updateMoveInfo();
        }

        function jumpToMove(index) {
            if(index === currentMoveIndex) return;
            
            // Executar movimentos até o índice desejado
            if(index > currentMoveIndex) {
                for(let i = currentMoveIndex; i < index; i++) {
                    executeMoveAnimation(solution[i]);
                }
            } else {
                // Voltar movimentos (inverso)
                for(let i = currentMoveIndex - 1; i >= index; i--) {
                    const inverse = getInverseMove(solution[i]);
                    executeMoveAnimation(inverse);
                }
            }
            
            currentMoveIndex = index;
            highlightCurrentMove();
        }

        function nextMove() {
            if(currentMoveIndex < solution.length) {
                executeMoveAnimation(solution[currentMoveIndex]);
                currentMoveIndex++;
                highlightCurrentMove();
            }
        }

        function prevMove() {
            if(currentMoveIndex > 0) {
                currentMoveIndex--;
                const inverse = getInverseMove(solution[currentMoveIndex]);
                executeMoveAnimation(inverse);
                highlightCurrentMove();
            }
        }

        function getInverseMove(move) {
            if(move.includes('2')) return move; // 180 graus é próprio inverso
            if(move.includes("'")) return move.replace("'", "");
            return move + "'";
        }

        function togglePlay() {
            if(isPlaying) {
                stopPlay();
            } else {
                startPlay();
            }
        }

        function startPlay() {
            isPlaying = true;
            updatePlayButton();
            
            if(currentMoveIndex >= solution.length) {
                currentMoveIndex = 0;
            }
            
            playInterval = setInterval(() => {
                if(currentMoveIndex >= solution.length) {
                    stopPlay();
                    return;
                }
                nextMove();
            }, 800);
        }

        function stopPlay() {
            isPlaying = false;
            if(playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
            updatePlayButton();
        }

        function updatePlayButton() {
            const btn = document.getElementById('play-btn');
            btn.textContent = isPlaying ? '⏸' : '▶';
        }

        function executeMoveAnimation(move) {
            // Animação visual do movimento no cubo 3D
            const face = move.charAt(0);
            const clockwise = !move.includes("'");
            const double = move.includes("2");
            
            const axisMap = {
                'U': {axis: 'y', layer: 1, angle: -1},
                'D': {axis: 'y', layer: -1, angle: 1},
                'F': {axis: 'z', layer: 1, angle: -1},
                'B': {axis: 'z', layer: -1, angle: 1},
                'L': {axis: 'x', layer: -1, angle: 1},
                'R': {axis: 'x', layer: 1, angle: -1}
            };
            
            const info = axisMap[face];
            if(!info) return;
            
            const angle = info.angle * (clockwise ? 1 : -1) * Math.PI/2 * (double ? 2 : 1);
            animateFaceRotation(info.axis, info.layer, angle);
        }

        function animateFaceRotation(axis, layer, angle) {
            const threshold = 0.5;
            const cubiesToRotate = [];
            
            cubeGroup.children.forEach(child => {
                const pos = child.position;
                let inLayer = false;
                
                if(axis === 'x' && Math.abs(pos.x - layer * 1.02) < threshold) inLayer = true;
                if(axis === 'y' && Math.abs(pos.y - layer * 1.02) < threshold) inLayer = true;
                if(axis === 'z' && Math.abs(pos.z - layer * 1.02) < threshold) inLayer = true;
                
                if(inLayer) cubiesToRotate.push(child);
            });
            
            const pivot = new THREE.Group();
            scene.add(pivot);
            
            cubiesToRotate.forEach(cubie => {
                pivot.attach(cubie);
            });
            
            const duration = 400;
            const start = Date.now();
            const startRot = pivot.rotation[axis];
            
            function animate() {
                const elapsed = Date.now() - start;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 4);
                
                pivot.rotation[axis] = startRot + angle * ease;
                
                if(progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    cubiesToRotate.forEach(cubie => {
                        cubeGroup.attach(cubie);
                    });
                    scene.remove(pivot);
                }
            }
            animate();
        }

        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Rotação idle sutil
            if(!isPlaying && cubeGroup) {
                cubeGroup.rotation.y += 0.001;
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Inicialização
        init();
        selectColor('white');
        selectFace('F');
    </script>
</body>
</html>
