<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cubo Mágico - Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            overflow: hidden;
            background: #111827;
        }
        
        .cube-container {
            width: 100vw;
            height: 55vh;
            position: relative;
            cursor: grab;
        }
        
        .cube-container:active, .cube-container.dragging {
            cursor: grabbing;
        }
        
        .color-btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            border: 3px solid transparent;
        }
        
        .color-btn:active { transform: scale(0.9); }
        .color-btn.selected {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3), 0 8px 25px rgba(0,0,0,0.5);
        }
        
        .face-btn {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(75, 85, 99, 0.5);
            transition: all 0.3s ease;
            font-weight: 800;
            letter-spacing: 0.05em;
        }
        
        .face-btn.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.8);
            color: #60A5FA;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        .move-text { font-variant-numeric: tabular-nums; }
        
        .moves-list::-webkit-scrollbar { height: 6px; }
        .moves-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .moves-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        
        .success-toast { animation: slideUp 0.3s ease-out; }
        @keyframes slideUp {
            from { transform: translate(-50%, 100%); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }
        
        .gesture-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            color: rgba(255,255,255,0.7);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .cube-container:hover .gesture-hint { opacity: 1; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col">

    <div id="success-toast" class="fixed bottom-32 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-3 rounded-full font-bold shadow-lg z-40 hidden"></div>
    <div id="error-toast" class="fixed bottom-32 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-6 py-3 rounded-full font-bold shadow-lg z-40 hidden"></div>

    <div class="px-4 pt-3 pb-2 flex justify-between items-center bg-gray-800/80 backdrop-blur-md border-b border-gray-700">
        <div>
            <h1 class="text-lg font-bold tracking-tight text-white">Cubo Solver</h1>
            <p class="text-xs text-gray-400 mt-0.5">BFS + Heurística</p>
        </div>
        <div class="flex gap-2">
            <button onclick="resetCube()" class="px-3 py-1.5 bg-gray-700 hover:bg-gray-600 rounded-lg text-xs font-bold border border-gray-600">Limpar</button>
            <button onclick="scrambleCube()" class="px-3 py-1.5 bg-purple-600 hover:bg-purple-500 rounded-lg text-xs font-bold">Embaralhar</button>
        </div>
    </div>

    <div class="cube-container relative" id="canvas-container">
        <div class="absolute top-4 left-4 bg-black/50 backdrop-blur px-3 py-1.5 rounded-lg text-xs font-mono text-gray-300 border border-gray-700 z-10">
            <span id="status-text">Pronto</span>
        </div>
        <div class="gesture-hint">Arraste para girar • Toque para colorir</div>
    </div>

    <div class="px-3 py-2 bg-gray-800/50 backdrop-blur-sm">
        <div class="flex justify-center gap-1.5 mb-2 flex-wrap">
            <button onclick="selectFace('U')" id="btn-U" class="face-btn px-3 py-2 rounded-xl text-xs">UP</button>
            <button onclick="selectFace('D')" id="btn-D" class="face-btn px-3 py-2 rounded-xl text-xs">DOWN</button>
            <button onclick="selectFace('F')" id="btn-F" class="face-btn px-3 py-2 rounded-xl text-xs active">FRONT</button>
            <button onclick="selectFace('B')" id="btn-B" class="face-btn px-3 py-2 rounded-xl text-xs">BACK</button>
            <button onclick="selectFace('L')" id="btn-L" class="face-btn px-3 py-2 rounded-xl text-xs">LEFT</button>
            <button onclick="selectFace('R')" id="btn-R" class="face-btn px-3 py-2 rounded-xl text-xs">RIGHT</button>
        </div>
        <p class="text-center text-xs text-gray-400 font-medium" id="instruction-text">Toque para colorir: FRONT (Azul)</p>
    </div>

    <div class="flex-1 px-3 py-3 bg-gray-800/80 backdrop-blur-md flex flex-col">
        <div class="flex justify-center gap-2 mb-3 flex-wrap">
            <button onclick="selectColor('white')" id="color-white" class="color-btn w-10 h-10 rounded-xl bg-gray-100"></button>
            <button onclick="selectColor('yellow')" id="color-yellow" class="color-btn w-10 h-10 rounded-xl bg-yellow-400"></button>
            <button onclick="selectColor('red')" id="color-red" class="color-btn w-10 h-10 rounded-xl bg-red-500"></button>
            <button onclick="selectColor('orange')" id="color-orange" class="color-btn w-10 h-10 rounded-xl bg-orange-500"></button>
            <button onclick="selectColor('blue')" id="color-blue" class="color-btn w-10 h-10 rounded-xl bg-blue-500"></button>
            <button onclick="selectColor('green')" id="color-green" class="color-btn w-10 h-10 rounded-xl bg-green-500"></button>
        </div>

        <div class="flex gap-2 mb-3">
            <button onclick="validateAndSolve()" id="solve-btn" class="flex-1 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 py-3 rounded-xl font-bold text-sm shadow-lg transform transition-all active:scale-95 disabled:opacity-50">
                Resolver Cubo
            </button>
        </div>

        <div id="solution-panel" class="hidden flex-1 bg-gray-900/90 rounded-xl p-3 border border-gray-700 flex flex-col">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-bold text-gray-300 uppercase">Solução</span>
                <div class="flex gap-1.5">
                    <button onclick="prevMove()" class="w-7 h-7 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center text-xs font-bold">←</button>
                    <button onclick="togglePlay()" id="play-btn" class="w-7 h-7 bg-green-600 hover:bg-green-500 rounded-lg flex items-center justify-center text-xs font-bold">▶</button>
                    <button onclick="nextMove()" class="w-7 h-7 bg-gray-700 hover:bg-gray-600 rounded-lg flex items-center justify-center text-xs font-bold">→</button>
                </div>
            </div>
            <div class="moves-list flex gap-1.5 overflow-x-auto pb-2 text-xs font-mono mb-2" id="moves-display"></div>
            <div class="flex justify-between items-center text-xs text-gray-500 font-mono">
                <span id="move-counter">Passo 0/0</span>
                <span id="move-notation" class="text-blue-400 font-bold text-sm"></span>
            </div>
        </div>
    </div>

    <script>
        // Three.js
        let scene, camera, renderer, cubeGroup, stickers = [], raycaster, mouse;
        let physicalCube = [];
        let currentFace = 'F', selectedColor = 'white';
        let solution = [], currentMoveIndex = 0, isPlaying = false, playInterval;
        let isAnimating = false;
        
        const faces = ['U', 'D', 'F', 'B', 'L', 'R'];
        const centerColors = { 'U': 'white', 'D': 'yellow', 'F': 'blue', 'B': 'green', 'L': 'orange', 'R': 'red' };
        const colors = { 'white': 0xFFFFFF, 'yellow': 0xFFD500, 'red': 0xDC2626, 'orange': 0xF97316, 'blue': 0x2563EB, 'green': 0x16A34A, 'gray': 0x374151 };
        
        let cubeState = {};
        let isDragging = false, isMouseDown = false;
        let dragStartPos = { x: 0, y: 0 }, previousMousePosition = { x: 0, y: 0 }, rotationVelocity = { x: 0, y: 0 };
        const CLICK_THRESHOLD = 5;

        const MOVES = ['U', "U'", 'U2', 'D', "D'", 'D2', 'F', "F'", 'F2', 'B', "B'", 'B2', 'L', "L'", 'L2', 'R', "R'", 'R2'];

        function init() {
            faces.forEach(f => { cubeState[f] = Array(9).fill('gray'); cubeState[f][4] = centerColors[f]; });
            setupThreeJS();
            createCube();
            setupInteraction();
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0, 0, 13);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 7);
            scene.add(mainLight);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        function createCube() {
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            const geometry = new THREE.BoxGeometry(0.92, 0.92, 0.92);
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            stickers = [];
            physicalCube = [];
            
            for(let x = -1; x <= 1; x++) {
                for(let y = -1; y <= 1; y++) {
                    for(let z = -1; z <= 1; z++) {
                        if(x === 0 && y === 0 && z === 0) continue;
                        const cubie = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0x1F2937, shininess: 80 }));
                        cubie.position.set(x * 1.02, y * 1.02, z * 1.02);
                        cubie.userData.gridPos = {x, y, z};
                        const edges = new THREE.LineSegments(edgesGeometry, new THREE.LineBasicMaterial({ color: 0x111827 }));
                        cubie.add(edges);
                        const stickerGeo = new THREE.PlaneGeometry(0.75, 0.75);
                        if(z === 1) createSticker(cubie, stickerGeo, 'F', 0, 0, 0.47, 0, 0, 0, x, y);
                        if(z === -1) createSticker(cubie, stickerGeo, 'B', 0, 0, -0.47, 0, Math.PI, 0, -x, y);
                        if(y === 1) createSticker(cubie, stickerGeo, 'U', 0, 0.47, 0, -Math.PI/2, 0, 0, x, -z);
                        if(y === -1) createSticker(cubie, stickerGeo, 'D', 0, -0.47, 0, Math.PI/2, 0, 0, x, z);
                        if(x === -1) createSticker(cubie, stickerGeo, 'L', -0.47, 0, 0, 0, -Math.PI/2, 0, -z, y);
                        if(x === 1) createSticker(cubie, stickerGeo, 'R', 0.47, 0, 0, 0, Math.PI/2, 0, z, y);
                        cubeGroup.add(cubie);
                        physicalCube.push(cubie);
                    }
                }
            }
            updateCubeColors();
        }

        function createSticker(parent, geo, face, x, y, z, rx, ry, rz, posX, posY) {
            const sticker = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: colors.gray, shininess: 120 }));
            sticker.position.set(x, y, z);
            sticker.rotation.set(rx, ry, rz);
            sticker.userData = { face, index: Math.floor((1 - posY) * 3 + (posX + 1)), isSticker: true };
            parent.add(sticker);
            stickers.push(sticker);
        }

        function updateCubeColors() {
            stickers.forEach(s => {
                const c = cubeState[s.userData.face][s.userData.index];
                if(colors[c]) {
                    s.material.color.setHex(colors[c]);
                    s.material.emissive.setHex(colors[c]);
                    s.material.emissiveIntensity = c === 'gray' ? 0 : 0.15;
                }
            });
        }

        function setupInteraction() {
            const c = document.getElementById('canvas-container');
            c.addEventListener('mousedown', e => { if(isAnimating) return; isMouseDown = true; isDragging = false; dragStartPos = {x: e.clientX, y: e.clientY}; previousMousePosition = {x: e.clientX, y: e.clientY}; rotationVelocity = {x:0,y:0}; });
            c.addEventListener('mousemove', e => {
                if(!isMouseDown || isAnimating) return;
                const dx = e.clientX - previousMousePosition.x, dy = e.clientY - previousMousePosition.y;
                const dist = Math.hypot(e.clientX - dragStartPos.x, e.clientY - dragStartPos.y);
                if(dist > CLICK_THRESHOLD) { isDragging = true; c.classList.add('dragging'); cubeGroup.rotation.y += dx * 0.008; cubeGroup.rotation.x += dy * 0.008; rotationVelocity = {x: dy*0.008, y: dx*0.008}; }
                previousMousePosition = {x: e.clientX, y: e.clientY};
            });
            c.addEventListener('mouseup', e => handleUp(e.clientX, e.clientY));
            c.addEventListener('mouseleave', e => handleUp(e.clientX, e.clientY));
            c.addEventListener('touchstart', e => { if(isAnimating) return; const t = e.touches[0]; isMouseDown = true; isDragging = false; dragStartPos = {x: t.clientX, y: t.clientY}; previousMousePosition = {x: t.clientX, y: t.clientY}; }, {passive: false});
            c.addEventListener('touchmove', e => { if(!isMouseDown || isAnimating) return; e.preventDefault(); const t = e.touches[0]; const dx = t.clientX - previousMousePosition.x, dy = t.clientY - previousMousePosition.y; const dist = Math.hypot(t.clientX - dragStartPos.x, t.clientY - dragStartPos.y); if(dist > CLICK_THRESHOLD) { isDragging = true; cubeGroup.rotation.y += dx * 0.012; cubeGroup.rotation.x += dy * 0.012; rotationVelocity = {x: dy*0.012, y: dx*0.012}; } previousMousePosition = {x: t.clientX, y: t.clientY}; }, {passive: false});
            c.addEventListener('touchend', e => { const t = e.changedTouches[0]; handleUp(t.clientX, t.clientY); });
        }

        function handleUp(x, y) {
            if(!isMouseDown) return;
            const dist = Math.hypot(x - dragStartPos.x, y - dragStartPos.y);
            if(!isDragging && dist <= CLICK_THRESHOLD) handleClick(x, y);
            isMouseDown = false; isDragging = false;
            document.getElementById('canvas-container').classList.remove('dragging');
            if(dist > CLICK_THRESHOLD) applyInertia();
        }

        function handleClick(cx, cy) {
            const r = document.getElementById('canvas-container').getBoundingClientRect();
            mouse.x = ((cx - r.left) / r.width) * 2 - 1;
            mouse.y = -((cy - r.top) / r.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(stickers);
            if(hits.length) {
                const s = hits[0].object;
                if(s.userData.face !== currentFace) { currentFace = s.userData.face; updateFaceUI(); }
                if(s.userData.index === 4) { s.scale.set(0.95,0.95,0.95); setTimeout(()=>s.scale.set(1,1,1),100); return; }
                cubeState[s.userData.face][s.userData.index] = selectedColor;
                updateCubeColors(); s.scale.set(0.85,0.85,0.85); setTimeout(()=>s.scale.set(1,1,1),150);
                hideSolution();
            }
        }

        function applyInertia() {
            if(Math.abs(rotationVelocity.x) < 0.001 && Math.abs(rotationVelocity.y) < 0.001) return;
            const f = 0.95, step = () => { if(isMouseDown || isAnimating) return; cubeGroup.rotation.x += rotationVelocity.x; cubeGroup.rotation.y += rotationVelocity.y; rotationVelocity.x *= f; rotationVelocity.y *= f; if(Math.abs(rotationVelocity.x) > 0.001 || Math.abs(rotationVelocity.y) > 0.001) requestAnimationFrame(step); };
            step();
        }

        function updateFaceUI() { document.querySelectorAll('.face-btn').forEach(b => b.classList.remove('active')); document.getElementById(`btn-${currentFace}`).classList.add('active'); const n = {'U':'UP (Branco)','D':'DOWN (Amarelo)','F':'FRONT (Azul)','B':'BACK (Verde)','L':'LEFT (Laranja)','R':'RIGHT (Vermelho)'}; document.getElementById('instruction-text').textContent = `Toque para colorir: ${n[currentFace]}`; }
        function selectFace(f) { if(!isAnimating) { currentFace = f; updateFaceUI(); }}
        function selectColor(c) { selectedColor = c; document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected')); document.getElementById(`color-${c}`).classList.add('selected'); }

        function resetCube() {
            stopPlay(); faces.forEach(f => { cubeState[f] = Array(9).fill('gray'); cubeState[f][4] = centerColors[f]; });
            updateCubeColors(); hideSolution();
            scene.remove(cubeGroup);
            createCube();
            updateStatus('Cubo resetado');
        }

        function scrambleCube() {
            stopPlay(); const cols = ['white','yellow','red','orange','blue','green'];
            faces.forEach(f => { cubeState[f] = Array(9).fill('gray'); cubeState[f][4] = centerColors[f]; for(let i=0;i<9;i++) if(i!==4) cubeState[f][i] = cols[Math.floor(Math.random()*6)]; });
            updateCubeColors(); hideSolution(); updateStatus('Cubo embaralhado');
        }

        function validateCube() { for(let f of faces) for(let i=0;i<9;i++) if(cubeState[f][i]==='gray') return {valid:false,message:`Face ${f} incompleta!`}; const cnt={}; faces.forEach(f=>cubeState[f].forEach(c=>cnt[c]=(cnt[c]||0)+1)); for(let c of ['white','yellow','red','orange','blue','green']) if(cnt[c]!==9) return {valid:false,message:`Cor ${c} deve ter 9 stickers!`}; return {valid:true}; }

        // Solver BFS
        function copyState(s) { const n={}; faces.forEach(f=>n[f]=[...s[f]]); return n; }
        function stateKey(s) { return faces.map(f=>s[f].join('')).join(''); }
        function isSolved(s) { return faces.every(f=>s[f].every(c=>c===s[f][0])); }

        function applyMove(state, move) {
            const ns = copyState(state);
            const face = move.charAt(0), cw = !move.includes("'"), dbl = move.includes('2'), times = dbl?2:1;
            for(let t=0;t<times;t++) {
                const f = [...ns[face]];
                ns[face] = cw ? [f[6],f[3],f[0],f[7],f[4],f[1],f[8],f[5],f[2]] : [f[2],f[5],f[8],f[1],f[4],f[7],f[0],f[3],f[6]];
                if(face==='U') { const t=[ns.F[0],ns.F[1],ns.F[2]]; ns.F[0]=ns.R[0];ns.F[1]=ns.R[1];ns.F[2]=ns.R[2]; ns.R[0]=ns.B[0];ns.R[1]=ns.B[1];ns.R[2]=ns.B[2]; ns.B[0]=ns.L[0];ns.B[1]=ns.L[1];ns.B[2]=ns.L[2]; ns.L[0]=t[0];ns.L[1]=t[1];ns.L[2]=t[2]; }
                else if(face==='D') { const t=[ns.F[6],ns.F[7],ns.F[8]]; ns.F[6]=ns.L[6];ns.F[7]=ns.L[7];ns.F[8]=ns.L[8]; ns.L[6]=ns.B[6];ns.L[7]=ns.B[7];ns.L[8]=ns.B[8]; ns.B[6]=ns.R[6];ns.B[7]=ns.R[7];ns.B[8]=ns.R[8]; ns.R[6]=t[0];ns.R[7]=t[1];ns.R[8]=t[2]; }
                else if(face==='F') { const t=[ns.U[6],ns.U[7],ns.U[8]]; ns.U[6]=ns.L[8];ns.U[7]=ns.L[5];ns.U[8]=ns.L[2]; ns.L[2]=ns.D[0];ns.L[5]=ns.D[1];ns.L[8]=ns.D[2]; ns.D[0]=ns.R[6];ns.D[1]=ns.R[3];ns.D[2]=ns.R[0]; ns.R[0]=t[0];ns.R[3]=t[1];ns.R[6]=t[2]; }
                else if(face==='B') { const t=[ns.U[0],ns.U[1],ns.U[2]]; ns.U[0]=ns.R[2];ns.U[1]=ns.R[5];ns.U[2]=ns.R[8]; ns.R[2]=ns.D[8];ns.R[5]=ns.D[7];ns.R[8]=ns.D[6]; ns.D[6]=ns.L[0];ns.D[7]=ns.L[3];ns.D[8]=ns.L[6]; ns.L[0]=t[2];ns.L[3]=t[1];ns.L[6]=t[0]; }
                else if(face==='L') { const t=[ns.U[0],ns.U[3],ns.U[6]]; ns.U[0]=ns.B[8];ns.U[3]=ns.B[5];ns.U[6]=ns.B[2]; ns.B[2]=ns.D[6];ns.B[5]=ns.D[3];ns.B[8]=ns.D[0]; ns.D[0]=ns.F[0];ns.D[3]=ns.F[3];ns.D[6]=ns.F[6]; ns.F[0]=t[0];ns.F[3]=t[1];ns.F[6]=t[2]; }
                else if(face==='R') { const t=[ns.U[2],ns.U[5],ns.U[8]]; ns.U[2]=ns.F[2];ns.U[5]=ns.F[5];ns.U[8]=ns.F[8]; ns.F[2]=ns.D[2];ns.F[5]=ns.D[5];ns.F[8]=ns.D[8]; ns.D[2]=ns.B[6];ns.D[5]=ns.B[3];ns.D[8]=ns.B[0]; ns.B[0]=t[2];ns.B[3]=t[1];ns.B[6]=t[0]; }
            }
            return ns;
        }

        async function solveCube() {
            const q = [{state: cubeState, moves: []}];
            const vis = new Set(); vis.add(stateKey(cubeState));
            while(q.length) {
                const {state,moves} = q.shift();
                if(isSolved(state)) return moves;
                if(moves.length >= 7) continue;
                for(const m of MOVES) {
                    const ns = applyMove(state, m);
                    const k = stateKey(ns);
                    if(!vis.has(k)) { vis.add(k); q.push({state: ns, moves: [...moves, m]}); }
                }
            }
            return null;
        }

        async function validateAndSolve() {
            if(isAnimating) return;
            const v = validateCube(); if(!v.valid) { showError(v.message); return; }
            if(isSolved(cubeState)) { showSuccess('Cubo já resolvido!'); return; }
            updateStatus('Analisando...'); document.getElementById('solve-btn').disabled = true;
            const sol = await solveCube();
            if(sol) { solution = sol; currentMoveIndex = 0; displaySolution(); updateStatus(`Solução ótima: ${solution.length} movimentos`); }
            else { showError('Solução não encontrada em 7 movimentos'); }
            document.getElementById('solve-btn').disabled = false;
        }

        function showSuccess(m) { const t=document.getElementById('success-toast'); t.textContent=m; t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'),3000); }
        function showError(m) { const t=document.getElementById('error-toast'); t.textContent=m; t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'),3000); }

        function displaySolution() { document.getElementById('solution-panel').classList.remove('hidden'); const c=document.getElementById('moves-display'); c.innerHTML=''; solution.forEach((m,i)=>{const s=document.createElement('span'); s.className=`move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all ${i===0?'bg-blue-500 text-white scale-110':'bg-gray-700 text-gray-300 hover:bg-gray-600'}`; s.textContent=m; s.onclick=()=>jumpToMove(i); c.appendChild(s);}); updateMoveInfo(); scrollToCurrentMove(); }
        function hideSolution() { document.getElementById('solution-panel').classList.add('hidden'); solution=[]; currentMoveIndex=0; stopPlay(); }
        function updateMoveInfo() { document.getElementById('move-counter').textContent=`Passo ${currentMoveIndex}/${solution.length}`; document.getElementById('move-notation').textContent=solution[currentMoveIndex]||''; }
        function scrollToCurrentMove() { const m=document.getElementById('moves-display').children; if(m[currentMoveIndex]) m[currentMoveIndex].scrollIntoView({behavior:'smooth',inline:'center'}); }
        function highlightCurrentMove() { const m=document.getElementById('moves-display').children; Array.from(m).forEach((e,i)=>{if(i===currentMoveIndex)e.className='move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-blue-500 text-white scale-110'; else if(i<currentMoveIndex)e.className='move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-green-600/50 text-green-200'; else e.className='move-text px-2 py-1 rounded-lg font-bold text-xs cursor-pointer transition-all bg-gray-700 text-gray-300 hover:bg-gray-600';}); scrollToCurrentMove(); updateMoveInfo(); }
        function jumpToMove(idx) { if(idx===currentMoveIndex||isAnimating) return; if(idx>currentMoveIndex) for(let i=currentMoveIndex;i<idx;i++) animateMove(solution[i]); else for(let i=currentMoveIndex-1;i>=idx;i--) animateMove(inverse(solution[i])); currentMoveIndex=idx; highlightCurrentMove(); }
        function nextMove() { if(currentMoveIndex>=solution.length||isAnimating) return; animateMove(solution[currentMoveIndex]); currentMoveIndex++; highlightCurrentMove(); }
        function prevMove() { if(currentMoveIndex<=0||isAnimating) return; currentMoveIndex--; animateMove(inverse(solution[currentMoveIndex])); highlightCurrentMove(); }
        function inverse(m) { if(!m)return''; if(m.includes('2'))return m; if(m.includes("'"))return m.replace("'",""); return m+"'"; }
        function togglePlay() { if(isPlaying) stopPlay(); else startPlay(); }
        function startPlay() { if(solution.length===0||currentMoveIndex>=solution.length) return; isPlaying=true; document.getElementById('play-btn').textContent='⏸'; playInterval=setInterval(()=>{if(currentMoveIndex>=solution.length||!isPlaying){stopPlay();return;}nextMove();},700); }
        function stopPlay() { isPlaying=false; clearInterval(playInterval); document.getElementById('play-btn').textContent='▶'; }

        // ANIMAÇÃO: Rotacionar cada cubie individualmente em torno do centro do cubo
        function animateMove(move) {
            if(!move || isAnimating) return;
            isAnimating = true;
            
            const face = move.charAt(0);
            const cw = !move.includes("'");
            const dbl = move.includes('2');
            
            // Configuração do eixo de rotação
            const axisConfig = {
                'U': { axis: new THREE.Vector3(0, 1, 0), layer: 1 },
                'D': { axis: new THREE.Vector3(0, 1, 0), layer: -1 },
                'F': { axis: new THREE.Vector3(0, 0, 1), layer: 1 },
                'B': { axis: new THREE.Vector3(0, 0, 1), layer: -1 },
                'L': { axis: new THREE.Vector3(1, 0, 0), layer: -1 },
                'R': { axis: new THREE.Vector3(1, 0, 0), layer: 1 }
            };
            
            const config = axisConfig[face];
            const angle = (face === 'U' || face === 'B' || face === 'L' ? -1 : 1) * (cw ? 1 : -1) * Math.PI/2 * (dbl ? 2 : 1);
            
            // Selecionar cubies na camada
            const toRotate = physicalCube.filter(c => {
                const p = c.position;
                const v = config.axis.x ? p.x : config.axis.y ? p.y : p.z;
                return Math.abs(v - config.layer * 1.02) < 0.6;
            });
            
            // Guardar dados iniciais
            const startData = toRotate.map(c => ({
                cubie: c,
                startPos: c.position.clone(),
                startRot: c.rotation.clone(),
                startQuat: c.quaternion.clone()
            }));
            
            const start = Date.now();
            const duration = 300;
            
            function step() {
                const elapsed = Date.now() - start;
                const p = Math.min(elapsed/duration, 1);
                const ease = 1 - Math.pow(1-p, 3);
                const currentAngle = angle * ease;
                
                // Rotacionar cada cubie individualmente em torno do centro (0,0,0)
                startData.forEach(data => {
                    // Rotacionar posição em torno do eixo
                    const rotatedPos = data.startPos.clone().applyAxisAngle(config.axis, currentAngle);
                    data.cubie.position.copy(rotatedPos);
                    
                    // Rotacionar orientação
                    const rotQuat = new THREE.Quaternion().setFromAxisAngle(config.axis, currentAngle);
                    data.cubie.quaternion.copy(data.startQuat).premultiply(rotQuat);
                });
                
                if(p < 1) {
                    requestAnimationFrame(step);
                } else {
                    // Snap final
                    startData.forEach(data => {
                        // Arredondar posição para múltiplos de 1.02
                        data.cubie.position.x = Math.round(data.cubie.position.x / 1.02) * 1.02;
                        data.cubie.position.y = Math.round(data.cubie.position.y / 1.02) * 1.02;
                        data.cubie.position.z = Math.round(data.cubie.position.z / 1.02) * 1.02;
                        
                        // Converter quaternion para Euler e arredondar
                        const euler = new THREE.Euler().setFromQuaternion(data.cubie.quaternion);
                        euler.x = Math.round(euler.x / (Math.PI/2)) * (Math.PI/2);
                        euler.y = Math.round(euler.y / (Math.PI/2)) * (Math.PI/2);
                        euler.z = Math.round(euler.z / (Math.PI/2)) * (Math.PI/2);
                        data.cubie.rotation.copy(euler);
                        
                        // Normalizar quaternion
                        data.cubie.quaternion.setFromEuler(euler);
                    });
                    
                    isAnimating = false;
                }
            }
            step();
        }

        function updateStatus(t) { document.getElementById('status-text').textContent = t; }
        function animate() {
            requestAnimationFrame(animate);
            if(!isMouseDown && !isAnimating && !isPlaying && cubeGroup) {
                if(Math.abs(rotationVelocity.x)>0.001||Math.abs(rotationVelocity.y)>0.001) {
                    cubeGroup.rotation.x += rotationVelocity.x;
                    cubeGroup.rotation.y += rotationVelocity.y;
                    rotationVelocity.x *= 0.95;
                    rotationVelocity.y *= 0.95;
                } else {
                    cubeGroup.rotation.y += 0.0002;
                }
            }
            renderer.render(scene, camera);
        }
        function onWindowResize() { const c=document.getElementById('canvas-container'); camera.aspect=c.clientWidth/c.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(c.clientWidth,c.clientHeight); }

        init(); selectColor('white'); selectFace('F');
    </script>
</body>
</html>
